{
  "address": "0x67d269191c92Caf3cD7723F116c85e6E9bf55933",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "feePerClaim",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "feeManagerBank",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "feeManagerOwner",
          "type": "address"
        }
      ],
      "name": "FeeManagerInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "inputDuration",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "challengePeriod",
          "type": "uint256"
        }
      ],
      "name": "RollupsInitialized",
      "type": "event"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "templateHash",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "inputDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "challengePeriod",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "inputLog2Size",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "feePerClaim",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "feeManagerBank",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "feeManagerOwner",
              "type": "address"
            },
            {
              "internalType": "address payable[]",
              "name": "validators",
              "type": "address[]"
            }
          ],
          "internalType": "struct DiamondConfig",
          "name": "_dConfig",
          "type": "tuple"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x0043e0f7ea63d055c67e444b35395305aeedcdb5eef5f28f22825ddb11581b93",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x67d269191c92Caf3cD7723F116c85e6E9bf55933",
    "transactionIndex": 0,
    "gasUsed": "644157",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x03b7f7b6d3ae79074203c186eedfec931fa9dd9af10c068ca1dedc090f0c752d",
    "transactionHash": "0x0043e0f7ea63d055c67e444b35395305aeedcdb5eef5f28f22825ddb11581b93",
    "logs": [],
    "blockNumber": 30,
    "cumulativeGasUsed": "644157",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "853463bf44733f3d929a32fa4eacb9e6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePerClaim\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeManagerBank\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeManagerOwner\",\"type\":\"address\"}],\"name\":\"FeeManagerInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengePeriod\",\"type\":\"uint256\"}],\"name\":\"RollupsInitialized\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"templateHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"inputDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputLog2Size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePerClaim\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeManagerBank\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeManagerOwner\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"validators\",\"type\":\"address[]\"}],\"internalType\":\"struct DiamondConfig\",\"name\":\"_dConfig\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"FeeManagerInitialized(uint256,address,address)\":{\"params\":{\"feeManagerBank\":\"fee manager bank address\",\"feeManagerOwner\":\"fee manager owner address\",\"feePerClaim\":\"fee per claim to reward the validators\"}},\"RollupsInitialized(uint256,uint256)\":{\"params\":{\"challengePeriod\":\"duration of challenge period in seconds\",\"inputDuration\":\"duration of input accumulation phase in seconds\"}}},\"kind\":\"dev\",\"methods\":{\"init((bytes32,uint256,uint256,uint256,uint256,address,address,address[]))\":{\"params\":{\"_dConfig\":\"diamond configurations\"}}},\"version\":1},\"userdoc\":{\"events\":{\"FeeManagerInitialized(uint256,address,address)\":{\"notice\":\"FeeManagerImpl contract initialized\"},\"RollupsInitialized(uint256,uint256)\":{\"notice\":\"rollups contract initialized\"}},\"kind\":\"user\",\"methods\":{\"init((bytes32,uint256,uint256,uint256,uint256,address,address,address[]))\":{\"notice\":\"initialize the diamond\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/upgrade_initializers/DiamondInit.sol\":\"DiamondInit\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/IBank.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n// @title Bank interface\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IBank {\\n    /// @notice returns the token used internally\\n    function getToken() external view returns (IERC20);\\n\\n    /// @notice get balance of `_owner`\\n    /// @param _owner account owner\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice transfer `_value` tokens from bank to `_to`\\n    /// @notice decrease the balance of caller by `_value`\\n    /// @param _to account that will receive `_value` tokens\\n    /// @param _value amount of tokens to be transfered\\n    function transferTokens(address _to, uint256 _value) external;\\n\\n    /// @notice transfer `_value` tokens from caller to bank\\n    /// @notice increase the balance of `_to` by `_value`\\n    /// @dev you may need to call `token.approve(bank, _value)`\\n    /// @param _to account that will have their balance increased by `_value`\\n    /// @param _value amount of tokens to be transfered\\n    function depositTokens(address _to, uint256 _value) external;\\n\\n    /// @notice `value` tokens were transfered from the bank to `to`\\n    /// @notice the balance of `from` was decreased by `value`\\n    /// @dev is triggered on any successful call to `transferTokens`\\n    /// @param from the account/contract that called `transferTokens` and\\n    ///              got their balance decreased by `value`\\n    /// @param to the one that received `value` tokens from the bank\\n    /// @param value amount of tokens that were transfered\\n    event Transfer(address indexed from, address to, uint256 value);\\n\\n    /// @notice `value` tokens were transfered from `from` to bank\\n    /// @notice the balance of `to` was increased by `value`\\n    /// @dev is triggered on any successful call to `depositTokens`\\n    /// @param from the account/contract that called `depositTokens` and\\n    ///              transfered `value` tokens to the bank\\n    /// @param to the one that got their balance increased by `value`\\n    /// @param value amount of tokens that were transfered\\n    event Deposit(address from, address indexed to, uint256 value);\\n}\\n\",\"keccak256\":\"0x483dc9b0c26e3a5d43148cf847bd4df2af03438a0d76d60d33549de3ca2dd77d\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] diamondCut, address init, bytes callData);\\n}\\n\",\"keccak256\":\"0x6a3129be1f39b6fec871f2c94bf7debf2d6a4e665547a4d83e7f2def38359e44\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0xd6c3796a7c45baea6e47fdd5f2cec95d7796991bc9a949604f99875590962a67\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0xc47289cda9c9cdb749612eb82ccb9abf9ab08dca74bdca22292ae7f765a15a5f\",\"license\":\"MIT\"},\"contracts/interfaces/IRollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups interface\\npragma solidity >=0.7.0;\\n\\n// InputAccumulation - Inputs being accumulated for currrent epoch\\n// AwaitingConsensus - No disagreeing claims (or no claims)\\n// AwaitingDispute - Waiting for dispute to be over\\n// inputs received during InputAccumulation will be included in the\\n// current epoch. Inputs received while WaitingClaims or ChallengesInProgress\\n// are accumulated for the next epoch\\nenum Phase {\\n    InputAccumulation,\\n    AwaitingConsensus,\\n    AwaitingDispute\\n}\\n\\ninterface IRollups {\\n    /// @notice claim the result of current epoch\\n    /// @param _epochHash hash of epoch\\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\\n    ///      and that claim != bytes32(0)\\n    /// TODO: add signatures for aggregated claims\\n    function claim(bytes32 _epochHash) external;\\n\\n    /// @notice finalize epoch after timeout\\n    /// @dev can only be called if challenge period is over\\n    function finalizeEpoch() external;\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two epochs two non\\n    ///      finalized epochs, one awaiting consensus/dispute and another\\n    ///      accumulating input\\n    function getCurrentEpoch() external view returns (uint256);\\n\\n    /// @notice claim submitted\\n    /// @param epochHash claim being submitted by this epoch\\n    /// @param claimer address of current claimer\\n    /// @param epochNumber number of the epoch being submitted\\n    event Claim(\\n        uint256 indexed epochNumber,\\n        address claimer,\\n        bytes32 epochHash\\n    );\\n\\n    /// @notice epoch finalized\\n    /// @param epochNumber number of the epoch being finalized\\n    /// @param epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\\n\\n    /// @notice phase change\\n    /// @param newPhase new phase\\n    event PhaseChange(Phase newPhase);\\n}\\n\",\"keccak256\":\"0x241c3ee8bb900067903ac836d5f3ee81eca587c7f225ad6df686478a6b27329b\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/IValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager interface\\npragma solidity >=0.7.0;\\n\\n// NoConflict - No conflicting claims or consensus\\n// Consensus - All validators had equal claims\\n// Conflict - Claim is conflicting with previous one\\nenum Result {\\n    NoConflict,\\n    Consensus,\\n    Conflict\\n}\\n\\n// TODO: What is the incentive for validators to not just copy the first claim that arrived?\\ninterface IValidatorManager {\\n    /// @notice get current claim\\n    function getCurrentClaim() external view returns (bytes32);\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n}\\n\",\"keccak256\":\"0x7eccbaf15dc80cd402459e8c940b0012fd3d3b8d2882fa13798afe92a9ea3b86\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibClaimsMask.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title ClaimsMask library\\npragma solidity >=0.8.8;\\n\\n// ClaimsMask is used to keep track of the number of claims for up to 8 validators\\n// | agreement mask | consensus goal mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n// |     8 bits     |        8 bits       |      30 bits       |      30 bits       | ... |      30 bits       |\\n// In Validator Manager, #claims_validator indicates the #claims the validator has made.\\n// In Fee Manager, #claims_validator indicates the #claims the validator has redeemed. In this case,\\n//      agreement mask and consensus goal mask are not used.\\n\\ntype ClaimsMask is uint256;\\n\\nlibrary LibClaimsMask {\\n    uint256 constant claimsBitLen = 30; // #bits used for each #claims\\n\\n    /// @notice this function creates a new ClaimsMask variable with value _value\\n    /// @param  _value the value following the format of ClaimsMask\\n    function newClaimsMask(uint256 _value) internal pure returns (ClaimsMask) {\\n        return ClaimsMask.wrap(_value);\\n    }\\n\\n    /// @notice this function creates a new ClaimsMask variable with the consensus goal mask set,\\n    ///         according to the number of validators\\n    /// @param  _numValidators the number of validators\\n    function newClaimsMaskWithConsensusGoalSet(uint256 _numValidators)\\n        internal\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_numValidators <= 8, \\\"up to 8 validators\\\");\\n        uint256 consensusMask = (1 << _numValidators) - 1;\\n        return ClaimsMask.wrap(consensusMask << 240); // 256 - 8 - 8 = 240\\n    }\\n\\n    /// @notice this function returns the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    ///     this index can be obtained though `getNumberOfClaimsByIndex` function in Validator Manager\\n    function getNumClaims(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 bitmask = (1 << claimsBitLen) - 1;\\n        return\\n            (ClaimsMask.unwrap(_claimsMask) >>\\n                (claimsBitLen * _validatorIndex)) & bitmask;\\n    }\\n\\n    /// @notice this function increases the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the increase amount\\n    function increaseNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) internal pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 currentNum = getNumClaims(_claimsMask, _validatorIndex);\\n        uint256 newNum = currentNum + _value; // overflows checked by default with sol0.8\\n        return setNumClaims(_claimsMask, _validatorIndex, newNum);\\n    }\\n\\n    /// @notice this function sets the #claims for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    /// @param  _value the set value\\n    function setNumClaims(\\n        ClaimsMask _claimsMask,\\n        uint256 _validatorIndex,\\n        uint256 _value\\n    ) internal pure returns (ClaimsMask) {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        require(_value <= ((1 << claimsBitLen) - 1), \\\"ClaimsMask Overflow\\\");\\n        uint256 bitmask = ~(((1 << claimsBitLen) - 1) <<\\n            (claimsBitLen * _validatorIndex));\\n        uint256 clearedClaimsMask = ClaimsMask.unwrap(_claimsMask) & bitmask;\\n        _claimsMask = ClaimsMask.wrap(\\n            clearedClaimsMask | (_value << (claimsBitLen * _validatorIndex))\\n        );\\n        return _claimsMask;\\n    }\\n\\n    /// @notice get consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function clearAgreementMask(ClaimsMask _claimsMask)\\n        internal\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        uint256 clearedMask = ClaimsMask.unwrap(_claimsMask) & ((1 << 248) - 1); // 256 - 8 = 248\\n        return ClaimsMask.wrap(clearedMask);\\n    }\\n\\n    /// @notice get the entire agreement mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getAgreementMask(ClaimsMask _claimsMask)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (ClaimsMask.unwrap(_claimsMask) >> 248); // get the first 8 bits\\n    }\\n\\n    /// @notice check if a validator has already claimed\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function alreadyClaimed(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        // get the first 8 bits. Then & operation on the validator's bit to see if it's set\\n        return\\n            (((ClaimsMask.unwrap(_claimsMask) >> 248) >> _validatorIndex) &\\n                1) != 0;\\n    }\\n\\n    /// @notice set agreement mask for the specified validator\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function setAgreementMask(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        internal\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 setMask = (ClaimsMask.unwrap(_claimsMask) |\\n            (1 << (248 + _validatorIndex))); // 256 - 8 = 248\\n        return ClaimsMask.wrap(setMask);\\n    }\\n\\n    /// @notice get the entire consensus goal mask\\n    /// @param  _claimsMask the ClaimsMask value\\n    function getConsensusGoalMask(ClaimsMask _claimsMask)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return ((ClaimsMask.unwrap(_claimsMask) << 8) >> 248); // get the second 8 bits\\n    }\\n\\n    /// @notice remove validator from the ClaimsMask\\n    /// @param  _claimsMask the ClaimsMask value\\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\\n    function removeValidator(ClaimsMask _claimsMask, uint256 _validatorIndex)\\n        internal\\n        pure\\n        returns (ClaimsMask)\\n    {\\n        require(_validatorIndex < 8, \\\"index out of range\\\");\\n        uint256 claimsMaskValue = ClaimsMask.unwrap(_claimsMask);\\n        // remove validator from agreement bitmask\\n        uint256 zeroMask = ~(1 << (_validatorIndex + 248)); // 256 - 8 = 248\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from consensus goal mask\\n        zeroMask = ~(1 << (_validatorIndex + 240)); // 256 - 8 - 8 = 240\\n        claimsMaskValue = (claimsMaskValue & zeroMask);\\n        // remove validator from #claims\\n        return\\n            setNumClaims(ClaimsMask.wrap(claimsMaskValue), _validatorIndex, 0);\\n    }\\n}\\n\",\"keccak256\":\"0x80b7355ef8d176c87e9c446542c4a7de8ee208601639af8acc23f6854f8f0080\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(\\n            msg.sender == diamondStorage().contractOwner,\\n            \\\"LibDiamond: Must be contract owner\\\"\\n        );\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] diamondCut,\\n        address init,\\n        bytes callData\\n    );\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK =\\n        bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _selectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(\\n                _newFacetAddress,\\n                \\\"LibDiamondCut: Add facet has no code\\\"\\n            );\\n            for (\\n                uint256 selectorIndex;\\n                selectorIndex < _selectors.length;\\n                selectorIndex++\\n            ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    \\\"LibDiamondCut: Can't add function that already exists\\\"\\n                );\\n                // add facet for selector\\n                ds.facets[selector] =\\n                    bytes20(_newFacetAddress) |\\n                    bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot =\\n                    (_selectorSlot &\\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(\\n                _newFacetAddress,\\n                \\\"LibDiamondCut: Replace facet has no code\\\"\\n            );\\n            for (\\n                uint256 selectorIndex;\\n                selectorIndex < _selectors.length;\\n                selectorIndex++\\n            ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(\\n                    oldFacetAddress != address(this),\\n                    \\\"LibDiamondCut: Can't replace immutable function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != _newFacetAddress,\\n                    \\\"LibDiamondCut: Can't replace function with same function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != address(0),\\n                    \\\"LibDiamondCut: Can't replace function that doesn't exist\\\"\\n                );\\n                // replace old facet address\\n                ds.facets[selector] =\\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\\n                    bytes20(_newFacetAddress);\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(\\n                _newFacetAddress == address(0),\\n                \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n            );\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (\\n                uint256 selectorIndex;\\n                selectorIndex < _selectors.length;\\n                selectorIndex++\\n            ) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(\\n                        address(bytes20(oldFacet)) != address(0),\\n                        \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n                    );\\n                    // only useful if immutable functions exist\\n                    require(\\n                        address(bytes20(oldFacet)) != address(this),\\n                        \\\"LibDiamondCut: Can't remove immutable function\\\"\\n                    );\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(\\n                        _selectorSlot << (selectorInSlotIndex << 5)\\n                    );\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] =\\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\\n                            bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\\n                        oldSelectorsSlotCount\\n                    ];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata)\\n        internal\\n    {\\n        if (_init == address(0)) {\\n            require(\\n                _calldata.length == 0,\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n            );\\n        } else {\\n            require(\\n                _calldata.length > 0,\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n            );\\n            if (_init != address(this)) {\\n                enforceHasContractCode(\\n                    _init,\\n                    \\\"LibDiamondCut: _init address has no code\\\"\\n                );\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x740ea3845282f09bb822e66a189ed431ac799ab08184de7457ef53799b2e99d6\",\"license\":\"MIT\"},\"contracts/libraries/LibDisputeManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Dispute Manager library\\npragma solidity ^0.8.0;\\n\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\n\\nlibrary LibDisputeManager {\\n    using LibRollups for LibRollups.DiamondStorage;\\n\\n    /// @notice initiates a dispute betweent two players\\n    /// @param claims conflicting claims\\n    /// @param claimers addresses of senders of conflicting claim\\n    /// @dev this is a mock implementation that just gives the win\\n    ///      to the address in the first posititon of claimers array\\n    function initiateDispute(\\n        bytes32[2] memory claims,\\n        address payable[2] memory claimers\\n    ) internal {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n        rollupsDS.resolveDispute(claimers[0], claimers[1], claims[0]);\\n    }\\n}\\n\",\"keccak256\":\"0x7d3fdb94a17c7f61ef8f6431f42eaa307b30398e3c24093c0526f449752563c9\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibFeeManager.sol\":{\"content\":\"// Copyright 2022 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Fee Manager library\\npragma solidity ^0.8.0;\\n\\nimport {LibValidatorManager} from \\\"../libraries/LibValidatorManager.sol\\\";\\nimport {LibClaimsMask, ClaimsMask} from \\\"../libraries/LibClaimsMask.sol\\\";\\nimport {IBank} from \\\"../IBank.sol\\\";\\n\\nlibrary LibFeeManager {\\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\\n    using LibFeeManager for LibFeeManager.DiamondStorage;\\n    using LibClaimsMask for ClaimsMask;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"FeeManager.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        address owner; // owner of Fee Manager\\n        uint256 feePerClaim;\\n        IBank bank; // bank that holds the tokens to pay validators\\n        bool lock; // reentrancy lock\\n        // A bit set used for up to 8 validators.\\n        // The first 16 bits are not used to keep compatibility with the validator manager contract.\\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\\n        // |     not used    | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n        // |     16 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\\n        ClaimsMask numClaimsRedeemed;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function onlyOwner(DiamondStorage storage ds) internal view {\\n        require(ds.owner == msg.sender, \\\"caller is not the owner\\\");\\n    }\\n\\n    /// @notice this function can be called to check the number of claims that's redeemable for the validator\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _validator address of the validator\\n    function numClaimsRedeemable(DiamondStorage storage ds, address _validator)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(_validator != address(0), \\\"address should not be 0\\\");\\n\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\\n        uint256 totalClaims = validatorManagerDS.claimsMask.getNumClaims(\\n            valIndex\\n        );\\n        uint256 redeemedClaims = ds.numClaimsRedeemed.getNumClaims(valIndex);\\n\\n        // underflow checked by default with sol0.8\\n        // which means if the validator is removed, calling this function will\\n        // either return 0 or revert\\n        return totalClaims - redeemedClaims;\\n    }\\n\\n    /// @notice this function can be called to check the number of claims that has been redeemed for the validator\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _validator address of the validator\\n    function getNumClaimsRedeemed(DiamondStorage storage ds, address _validator)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(_validator != address(0), \\\"address should not be 0\\\");\\n\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\\n        uint256 redeemedClaims = ds.numClaimsRedeemed.getNumClaims(valIndex);\\n\\n        return redeemedClaims;\\n    }\\n\\n    /// @notice contract owner can reset the value of fee per claim\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _value the new value of fee per claim\\n    function resetFeePerClaim(DiamondStorage storage ds, uint256 _value)\\n        internal\\n    {\\n        // before resetting the feePerClaim, pay fees for all validators as per current rates\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        for (\\n            uint256 valIndex;\\n            valIndex < validatorManagerDS.maxNumValidators;\\n            valIndex++\\n        ) {\\n            address validator = validatorManagerDS.validators[valIndex];\\n            if (validator != address(0)) {\\n                uint256 nowRedeemingClaims = ds.numClaimsRedeemable(validator);\\n                if (nowRedeemingClaims > 0) {\\n                    ds.numClaimsRedeemed = ds\\n                        .numClaimsRedeemed\\n                        .increaseNumClaims(valIndex, nowRedeemingClaims);\\n\\n                    uint256 feesToSend = nowRedeemingClaims * ds.feePerClaim; // number of erc20 tokens to send\\n                    ds.bank.transferTokens(validator, feesToSend); // will revert if transfer fails\\n                    // emit the number of claimed being redeemed, instead of the amount of tokens\\n                    emit FeeRedeemed(validator, nowRedeemingClaims);\\n                }\\n            }\\n        }\\n        ds.feePerClaim = _value;\\n        emit FeePerClaimReset(_value);\\n    }\\n\\n    /// @notice this function can be called to redeem fees for validators\\n    /// @param  ds pointer to FeeManager's diamond storage\\n    /// @param  _validator address of the validator that is redeeming\\n    function redeemFee(DiamondStorage storage ds, address _validator) internal {\\n        // follow the Checks-Effects-Interactions pattern for security\\n\\n        // ** checks **\\n        uint256 nowRedeemingClaims = ds.numClaimsRedeemable(_validator);\\n        require(nowRedeemingClaims > 0, \\\"nothing to redeem yet\\\");\\n\\n        // ** effects **\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\\n        ds.numClaimsRedeemed = ds.numClaimsRedeemed.increaseNumClaims(\\n            valIndex,\\n            nowRedeemingClaims\\n        );\\n\\n        // ** interactions **\\n        uint256 feesToSend = nowRedeemingClaims * ds.feePerClaim; // number of erc20 tokens to send\\n        ds.bank.transferTokens(_validator, feesToSend); // will revert if transfer fails\\n        // emit the number of claimed being redeemed, instead of the amount of tokens\\n        emit FeeRedeemed(_validator, nowRedeemingClaims);\\n    }\\n\\n    /// @notice removes a validator\\n    /// @param ds diamond storage pointer\\n    /// @param index index of validator to be removed\\n    function removeValidator(DiamondStorage storage ds, uint256 index)\\n        internal\\n    {\\n        ds.numClaimsRedeemed = ds.numClaimsRedeemed.setNumClaims(index, 0);\\n    }\\n\\n    /// @notice emitted on resetting feePerClaim\\n    event FeePerClaimReset(uint256 value);\\n\\n    /// @notice emitted on ERC20 funds redeemed by validator\\n    event FeeRedeemed(address validator, uint256 claims);\\n}\\n\",\"keccak256\":\"0xb06531049bb43f957ad6fd40635bbfdd16668bf0cc3dc637f11535122e9ce968\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibInput.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Input library\\npragma solidity ^0.8.0;\\n\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\n\\nlibrary LibInput {\\n    using LibRollups for LibRollups.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Input.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // always needs to keep track of two input boxes:\\n        // 1 for the input accumulation of next epoch\\n        // and 1 for the messages during current epoch. To save gas we alternate\\n        // between inputBox0 and inputBox1\\n        bytes32[] inputBox0;\\n        bytes32[] inputBox1;\\n        uint256 inputDriveSize; // size of input flashdrive\\n        uint256 currentInputBox;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice get input inside inbox of currently proposed claim\\n    /// @param ds diamond storage pointer\\n    /// @param index index of input inside that inbox\\n    /// @return hash of input at index index\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getInput(DiamondStorage storage ds, uint256 index)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            ds.currentInputBox == 0 ? ds.inputBox1[index] : ds.inputBox0[index];\\n    }\\n\\n    /// @notice get number of inputs inside inbox of currently proposed claim\\n    /// @param ds diamond storage pointer\\n    /// @return number of inputs on that input box\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getNumberOfInputs(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            ds.currentInputBox == 0 ? ds.inputBox1.length : ds.inputBox0.length;\\n    }\\n\\n    /// @notice add input to processed by next epoch\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInput(DiamondStorage storage ds, bytes memory input)\\n        internal\\n        returns (bytes32)\\n    {\\n        return addInputFromSender(ds, input, msg.sender);\\n    }\\n\\n    /// @notice add internal input to processed by next epoch\\n    /// @notice this function is to be reserved for internal usage only\\n    /// @notice for normal inputs, call `addInput` instead\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInternalInput(DiamondStorage storage ds, bytes memory input)\\n        internal\\n        returns (bytes32)\\n    {\\n        return addInputFromSender(ds, input, address(this));\\n    }\\n\\n    /// @notice add input from a specific sender to processed by next epoch\\n    /// @notice this function is to be reserved for internal usage only\\n    /// @notice for normal inputs, call `addInput` instead\\n    /// @param ds diamond storage pointer\\n    /// @param input input to be understood by offchain machine\\n    /// @param sender input sender address\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    ///      the offchain machine has a 8 byte word\\n    function addInputFromSender(\\n        DiamondStorage storage ds,\\n        bytes memory input,\\n        address sender\\n    ) internal returns (bytes32) {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n\\n        require(input.length <= ds.inputDriveSize, \\\"input len: [0,driveSize]\\\");\\n\\n        // notifyInput returns true if that input\\n        // belongs to a new epoch\\n        if (rollupsDS.notifyInput()) {\\n            swapInputBox(ds);\\n        }\\n\\n        // points to correct inputBox\\n        bytes32[] storage inputBox = ds.currentInputBox == 0\\n            ? ds.inputBox0\\n            : ds.inputBox1;\\n\\n        // get current epoch index\\n        uint256 currentEpoch = rollupsDS.getCurrentEpoch();\\n\\n        // keccak 64 bytes into 32 bytes\\n        bytes32 keccakMetadata = keccak256(\\n            abi.encode(\\n                sender,\\n                block.number,\\n                block.timestamp,\\n                currentEpoch, // epoch index\\n                inputBox.length // input index\\n            )\\n        );\\n\\n        bytes32 keccakInput = keccak256(input);\\n\\n        bytes32 inputHash = keccak256(abi.encode(keccakMetadata, keccakInput));\\n\\n        // add input to correct inbox\\n        inputBox.push(inputHash);\\n\\n        emit InputAdded(\\n            currentEpoch,\\n            inputBox.length - 1,\\n            sender,\\n            block.timestamp,\\n            input\\n        );\\n\\n        return inputHash;\\n    }\\n\\n    /// @notice called when a new input accumulation phase begins\\n    ///         swap inbox to receive inputs for upcoming epoch\\n    /// @param ds diamond storage pointer\\n    function onNewInputAccumulation(DiamondStorage storage ds) internal {\\n        swapInputBox(ds);\\n    }\\n\\n    /// @notice called when a new epoch begins, clears deprecated inputs\\n    /// @param ds diamond storage pointer\\n    function onNewEpoch(DiamondStorage storage ds) internal {\\n        // clear input box for new inputs\\n        // the current input box should be accumulating inputs\\n        // for the new epoch already. So we clear the other one.\\n        ds.currentInputBox == 0 ? delete ds.inputBox1 : delete ds.inputBox0;\\n    }\\n\\n    /// @notice changes current input box\\n    /// @param ds diamond storage pointer\\n    function swapInputBox(DiamondStorage storage ds) internal {\\n        ds.currentInputBox = (ds.currentInputBox == 0) ? 1 : 0;\\n    }\\n\\n    /// @notice input added\\n    /// @param epochNumber which epoch this input belongs to\\n    /// @param inputIndex index of the input just added\\n    /// @param sender msg.sender\\n    /// @param timestamp block.timestamp\\n    /// @param input input data\\n    event InputAdded(\\n        uint256 indexed epochNumber,\\n        uint256 indexed inputIndex,\\n        address sender,\\n        uint256 timestamp,\\n        bytes input\\n    );\\n}\\n\",\"keccak256\":\"0x9fec6d72c872e8f7f3adc79fa2bc5de8396d6ae97e2e23817e780e7d7a6cfaea\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibOutput.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Output library\\npragma solidity ^0.8.0;\\n\\nlibrary LibOutput {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Output.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        mapping(uint256 => uint256) voucherBitmask;\\n        bytes32[] epochHashes;\\n        bool lock; //reentrancy lock\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice to be called when an epoch is finalized\\n    /// @param ds diamond storage pointer\\n    /// @param epochHash hash of finalized epoch\\n    /// @dev an epoch being finalized means that its vouchers can be called\\n    function onNewEpoch(DiamondStorage storage ds, bytes32 epochHash) internal {\\n        ds.epochHashes.push(epochHash);\\n    }\\n\\n    /// @notice get number of finalized epochs\\n    /// @param ds diamond storage pointer\\n    function getNumberOfFinalizedEpochs(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.epochHashes.length;\\n    }\\n}\\n\",\"keccak256\":\"0xd0f88e13210013e9d5bde03399bb76304d6ab4e1f06d01c7e3525adc87a2d65e\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibRollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups library\\npragma solidity ^0.8.0;\\n\\nimport {Phase} from \\\"../interfaces/IRollups.sol\\\";\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibInput} from \\\"../libraries/LibInput.sol\\\";\\nimport {LibOutput} from \\\"../libraries/LibOutput.sol\\\";\\nimport {LibValidatorManager} from \\\"../libraries/LibValidatorManager.sol\\\";\\nimport {LibDisputeManager} from \\\"../libraries/LibDisputeManager.sol\\\";\\n\\nlibrary LibRollups {\\n    using LibInput for LibInput.DiamondStorage;\\n    using LibOutput for LibOutput.DiamondStorage;\\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"Rollups.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 templateHash; // state hash of the cartesi machine at t0\\n        uint32 inputDuration; // duration of input accumulation phase in seconds\\n        uint32 challengePeriod; // duration of challenge period in seconds\\n        uint32 inputAccumulationStart; // timestamp when current input accumulation phase started\\n        uint32 sealingEpochTimestamp; // timestamp on when a proposed epoch (claim) becomes challengeable\\n        uint32 currentPhase_int; // current phase in integer form\\n    }\\n\\n    /// @notice epoch finalized\\n    /// @param epochNumber number of the epoch being finalized\\n    /// @param epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\\n\\n    /// @notice phase change\\n    /// @param newPhase new phase\\n    event PhaseChange(Phase newPhase);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when new input arrives, manages the phase changes\\n    /// @param ds diamond storage pointer\\n    /// @dev can only be called by input contract\\n    function notifyInput(DiamondStorage storage ds) internal returns (bool) {\\n        Phase currentPhase = Phase(ds.currentPhase_int);\\n        uint256 inputAccumulationStart = ds.inputAccumulationStart;\\n        uint256 inputDuration = ds.inputDuration;\\n\\n        if (\\n            currentPhase == Phase.InputAccumulation &&\\n            block.timestamp > inputAccumulationStart + inputDuration\\n        ) {\\n            ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n            emit PhaseChange(Phase.AwaitingConsensus);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @notice called when a dispute is resolved by the dispute manager\\n    /// @param ds diamond storage pointer\\n    /// @param winner winner of dispute\\n    /// @param loser loser of dispute\\n    /// @param winningClaim initial claim of winning validator\\n    function resolveDispute(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    ) internal {\\n        Result result;\\n        bytes32[2] memory claims;\\n        address payable[2] memory claimers;\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        (result, claims, claimers) = validatorManagerDS.onDisputeEnd(\\n            winner,\\n            loser,\\n            winningClaim\\n        );\\n\\n        // restart challenge period\\n        ds.sealingEpochTimestamp = uint32(block.timestamp);\\n\\n        emit ResolveDispute(winner, loser, winningClaim);\\n        resolveValidatorResult(ds, result, claims, claimers);\\n    }\\n\\n    /// @notice resolve results returned by validator manager\\n    /// @param ds diamond storage pointer\\n    /// @param result result from claim or dispute operation\\n    /// @param claims array of claims in case of new conflict\\n    /// @param claimers array of claimers in case of new conflict\\n    function resolveValidatorResult(\\n        DiamondStorage storage ds,\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory claimers\\n    ) internal {\\n        if (result == Result.NoConflict) {\\n            Phase currentPhase = Phase(ds.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingConsensus) {\\n                ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n                emit PhaseChange(Phase.AwaitingConsensus);\\n            }\\n        } else if (result == Result.Consensus) {\\n            startNewEpoch(ds);\\n        } else {\\n            // for the case when result == Result.Conflict\\n            Phase currentPhase = Phase(ds.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingDispute) {\\n                ds.currentPhase_int = uint32(Phase.AwaitingDispute);\\n                emit PhaseChange(Phase.AwaitingDispute);\\n            }\\n            LibDisputeManager.initiateDispute(claims, claimers);\\n        }\\n    }\\n\\n    /// @notice starts new epoch\\n    /// @param ds diamond storage pointer\\n    function startNewEpoch(DiamondStorage storage ds) internal {\\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        // reset input accumulation start and deactivate challenge period start\\n        ds.currentPhase_int = uint32(Phase.InputAccumulation);\\n        emit PhaseChange(Phase.InputAccumulation);\\n        ds.inputAccumulationStart = uint32(block.timestamp);\\n        ds.sealingEpochTimestamp = type(uint32).max;\\n\\n        bytes32 finalClaim = validatorManagerDS.onNewEpoch();\\n\\n        // emit event before finalized epoch is added to the Output storage\\n        emit FinalizeEpoch(outputDS.getNumberOfFinalizedEpochs(), finalClaim);\\n\\n        outputDS.onNewEpoch(finalClaim);\\n        inputDS.onNewEpoch();\\n    }\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @param ds diamond storage pointer\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    ///      of finalized epochs array, else there are two non finalized epochs,\\n    ///      one awaiting consensus/dispute and another accumulating input\\n    function getCurrentEpoch(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\\n\\n        uint256 finalizedEpochs = outputDS.getNumberOfFinalizedEpochs();\\n\\n        Phase currentPhase = Phase(ds.currentPhase_int);\\n\\n        return\\n            currentPhase == Phase.InputAccumulation\\n                ? finalizedEpochs\\n                : finalizedEpochs + 1;\\n    }\\n}\\n\",\"keccak256\":\"0x04f72881c6032af40537ac14ff3720df2899a5746a42abd841b2292d66db11ca\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager library\\npragma solidity ^0.8.0;\\n\\nimport {Result} from \\\"../interfaces/IValidatorManager.sol\\\";\\n\\nimport {LibClaimsMask, ClaimsMask} from \\\"../libraries/LibClaimsMask.sol\\\";\\nimport {LibFeeManager} from \\\"../libraries/LibFeeManager.sol\\\";\\n\\nlibrary LibValidatorManager {\\n    using LibClaimsMask for ClaimsMask;\\n    using LibFeeManager for LibFeeManager.DiamondStorage;\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"ValidatorManager.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        bytes32 currentClaim; // current claim - first claim of this epoch\\n        address payable[] validators; // up to 8 validators\\n        uint256 maxNumValidators; // the maximum number of validators, set in the constructor\\n        // A bit set used for up to 8 validators.\\n        // The first 8 bits are used to indicate whom supports the current claim\\n        // The second 8 bits are used to indicate those should have claimed in order to reach consensus\\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\\n        // | agreement mask | consensus mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\\n        // |     8 bits     |     8 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\\n        ClaimsMask claimsMask;\\n    }\\n\\n    /// @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    /// @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /// @notice called when a dispute ends in rollups\\n    /// @param ds diamond storage pointer\\n    /// @param winner address of dispute winner\\n    /// @param loser address of dispute loser\\n    /// @param winningClaim the winnning claim\\n    /// @return result of dispute being finished\\n    function onDisputeEnd(\\n        DiamondStorage storage ds,\\n        address payable winner,\\n        address payable loser,\\n        bytes32 winningClaim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        removeValidator(ds, loser);\\n\\n        if (winningClaim == ds.currentClaim) {\\n            // first claim stood, dont need to update the bitmask\\n            return\\n                isConsensus(ds)\\n                    ? emitDisputeEndedAndReturn(\\n                        Result.Consensus,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    )\\n                    : emitDisputeEndedAndReturn(\\n                        Result.NoConflict,\\n                        [winningClaim, bytes32(0)],\\n                        [winner, payable(0)]\\n                    );\\n        }\\n\\n        // if first claim lost, and other validators have agreed with it\\n        // there is a new dispute to be played\\n        if (ds.claimsMask.getAgreementMask() != 0) {\\n            return\\n                emitDisputeEndedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, winningClaim],\\n                    [getClaimerOfCurrentClaim(ds), winner]\\n                );\\n        }\\n        // else there are no valdiators that agree with losing claim\\n        // we can update current claim and check for consensus in case\\n        // the winner is the only validator left\\n        ds.currentClaim = winningClaim;\\n        updateClaimAgreementMask(ds, winner);\\n        return\\n            isConsensus(ds)\\n                ? emitDisputeEndedAndReturn(\\n                    Result.Consensus,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                )\\n                : emitDisputeEndedAndReturn(\\n                    Result.NoConflict,\\n                    [winningClaim, bytes32(0)],\\n                    [winner, payable(0)]\\n                );\\n    }\\n\\n    /// @notice called when a new epoch starts\\n    /// @param ds diamond storage pointer\\n    /// @return current claim\\n    function onNewEpoch(DiamondStorage storage ds) internal returns (bytes32) {\\n        // reward validators who has made the correct claim by increasing their #claims\\n        claimFinalizedIncreaseCounts(ds);\\n\\n        bytes32 tmpClaim = ds.currentClaim;\\n\\n        // clear current claim\\n        ds.currentClaim = bytes32(0);\\n        // clear validator agreement bit mask\\n        ds.claimsMask = ds.claimsMask.clearAgreementMask();\\n\\n        emit NewEpoch(tmpClaim);\\n        return tmpClaim;\\n    }\\n\\n    /// @notice called when a claim is received by rollups\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of sender of that claim\\n    /// @param claim claim received by rollups\\n    /// @return result of claim, Consensus | NoConflict | Conflict\\n    /// @return [currentClaim, conflicting claim] if there is Conflict\\n    ///         [currentClaim, bytes32(0)] if there is Consensus or NoConflcit\\n    /// @return [claimer1, claimer2] if there is  Conflcit\\n    ///         [claimer1, address(0)] if there is Consensus or NoConflcit\\n    function onClaim(\\n        DiamondStorage storage ds,\\n        address payable sender,\\n        bytes32 claim\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        require(claim != bytes32(0), \\\"empty claim\\\");\\n        require(isValidator(ds, sender), \\\"sender not allowed\\\");\\n\\n        // require the validator hasn't claimed in the same epoch before\\n        uint256 index = getValidatorIndex(ds, sender);\\n        require(\\n            !ds.claimsMask.alreadyClaimed(index),\\n            \\\"sender had claimed in this epoch before\\\"\\n        );\\n\\n        // cant return because a single claim might mean consensus\\n        if (ds.currentClaim == bytes32(0)) {\\n            ds.currentClaim = claim;\\n        } else if (claim != ds.currentClaim) {\\n            return\\n                emitClaimReceivedAndReturn(\\n                    Result.Conflict,\\n                    [ds.currentClaim, claim],\\n                    [getClaimerOfCurrentClaim(ds), sender]\\n                );\\n        }\\n        updateClaimAgreementMask(ds, sender);\\n\\n        return\\n            isConsensus(ds)\\n                ? emitClaimReceivedAndReturn(\\n                    Result.Consensus,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                )\\n                : emitClaimReceivedAndReturn(\\n                    Result.NoConflict,\\n                    [claim, bytes32(0)],\\n                    [sender, payable(0)]\\n                );\\n    }\\n\\n    /// @notice emits dispute ended event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitDisputeEndedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit DisputeEnded(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice emits claim received event and then return\\n    /// @param result to be emitted and returned\\n    /// @param claims to be emitted and returned\\n    /// @param validators to be emitted and returned\\n    /// @dev this function existis to make code more clear/concise\\n    function emitClaimReceivedAndReturn(\\n        Result result,\\n        bytes32[2] memory claims,\\n        address payable[2] memory validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit ClaimReceived(result, claims, validators);\\n        return (result, claims, validators);\\n    }\\n\\n    /// @notice only call this function when a claim has been finalized\\n    ///         Either a consensus has been reached or challenge period has past\\n    /// @param ds pointer to diamond storage\\n    function claimFinalizedIncreaseCounts(DiamondStorage storage ds) internal {\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            // if a validator agrees with the current claim\\n            if ((agreementMask & (1 << i)) != 0) {\\n                // increase #claims by 1\\n                ds.claimsMask = ds.claimsMask.increaseNumClaims(i, 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice removes a validator\\n    /// @param ds diamond storage pointer\\n    /// @param validator address of validator to be removed\\n    function removeValidator(DiamondStorage storage ds, address validator)\\n        internal\\n    {\\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\\n            .diamondStorage();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (validator == ds.validators[i]) {\\n                // put address(0) in validators position\\n                ds.validators[i] = payable(0);\\n                // remove the validator from ValidatorManager's claimsMask\\n                ds.claimsMask = ds.claimsMask.removeValidator(i);\\n                // remove the validator from FeeManager's claimsMask (#redeems)\\n                feeManagerDS.removeValidator(i);\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @notice check if consensus has been reached\\n    /// @param ds pointer to diamond storage\\n    function isConsensus(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        ClaimsMask claimsMask = ds.claimsMask;\\n        return\\n            claimsMask.getAgreementMask() == claimsMask.getConsensusGoalMask();\\n    }\\n\\n    /// @notice get one of the validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @return validator that agreed with current claim\\n    function getClaimerOfCurrentClaim(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (address payable)\\n    {\\n        // TODO: we are always getting the first validator\\n        // on the array that agrees with the current claim to enter a dispute\\n        // should this be random?\\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (agreementMask & (1 << i) != 0) {\\n                return ds.validators[i];\\n            }\\n        }\\n        revert(\\\"Agreeing validator not found\\\");\\n    }\\n\\n    /// @notice updates mask of validators that agreed with current claim\\n    /// @param ds diamond storage pointer\\n    /// @param sender address of validator that will be included in mask\\n    function updateClaimAgreementMask(\\n        DiamondStorage storage ds,\\n        address payable sender\\n    ) internal {\\n        uint256 validatorIndex = getValidatorIndex(ds, sender);\\n        ds.claimsMask = ds.claimsMask.setAgreementMask(validatorIndex);\\n    }\\n\\n    /// @notice check if the sender is a validator\\n    /// @param ds pointer to diamond storage\\n    /// @param sender sender address\\n    function isValidator(DiamondStorage storage ds, address sender)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(sender != address(0), \\\"address 0\\\");\\n\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice find the validator and return the index or revert\\n    /// @param ds pointer to diamond storage\\n    /// @param sender validator address\\n    /// @return validator index or revert\\n    function getValidatorIndex(DiamondStorage storage ds, address sender)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(sender != address(0), \\\"address 0\\\");\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (sender == ds.validators[i]) return i;\\n        }\\n        revert(\\\"validator not found\\\");\\n    }\\n\\n    /// @notice get number of claims the sender has made\\n    /// @param ds pointer to diamond storage\\n    /// @param _sender validator address\\n    /// @return #claims\\n    function getNumberOfClaimsByAddress(\\n        DiamondStorage storage ds,\\n        address payable _sender\\n    ) internal view returns (uint256) {\\n        for (uint256 i; i < ds.validators.length; i++) {\\n            if (_sender == ds.validators[i]) {\\n                return getNumberOfClaimsByIndex(ds, i);\\n            }\\n        }\\n        // if validator not found\\n        return 0;\\n    }\\n\\n    /// @notice get number of claims by the index in the validator set\\n    /// @param ds pointer to diamond storage\\n    /// @param index the index in validator set\\n    /// @return #claims\\n    function getNumberOfClaimsByIndex(DiamondStorage storage ds, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.claimsMask.getNumClaims(index);\\n    }\\n\\n    /// @notice get the maximum number of validators defined in validator manager\\n    /// @param ds pointer to diamond storage\\n    /// @return the maximum number of validators\\n    function getMaxNumValidators(DiamondStorage storage ds)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ds.maxNumValidators;\\n    }\\n}\\n\",\"keccak256\":\"0xc5c11d8a0f745c785a8ca19b27f3ab232a53ecdab6b179b4d0c5df353690bce5\",\"license\":\"Apache-2.0\"},\"contracts/upgrade_initializers/DiamondInit.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n// @title Diamond Initialization Contract\\npragma solidity ^0.8.0;\\n\\n// Rollups-related dependencies\\nimport {Phase} from \\\"../interfaces/IRollups.sol\\\";\\nimport {LibRollups} from \\\"../libraries/LibRollups.sol\\\";\\nimport {LibInput} from \\\"../libraries/LibInput.sol\\\";\\nimport {LibValidatorManager} from \\\"../libraries/LibValidatorManager.sol\\\";\\nimport {LibClaimsMask} from \\\"../libraries/LibClaimsMask.sol\\\";\\nimport {LibFeeManager} from \\\"../libraries/LibFeeManager.sol\\\";\\nimport {IBank} from \\\"../IBank.sol\\\";\\n\\n// Diamond-related dependencies\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\";\\nimport {IDiamondLoupe} from \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport {IERC173} from \\\"../interfaces/IERC173.sol\\\"; // not in openzeppelin-contracts yet\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice diamond configurations\\n/// @param templateHash state hash of the cartesi machine at t0\\n/// @param inputDuration duration of input accumulation phase in seconds\\n/// @param challengePeriod duration of challenge period in seconds\\n/// @param inputLog2Size size of the input memory range in this machine\\n/// @param feePerClaim fee per claim to reward the validators\\n/// @param feeManagerBank fee manager bank address\\n/// @param feeManagerOwner fee manager owner address\\n/// @param validators initial validator set\\n/// @dev validators have to be unique, if the same validator is added twice\\n///      consensus will never be reached\\nstruct DiamondConfig {\\n    // RollupsFacet\\n    bytes32 templateHash;\\n    uint256 inputDuration;\\n    uint256 challengePeriod;\\n    // InputFacet\\n    uint256 inputLog2Size;\\n    // FeeManagerFacet\\n    uint256 feePerClaim;\\n    address feeManagerBank;\\n    address feeManagerOwner;\\n    // ValidatorManagerFacet\\n    address payable[] validators;\\n}\\n\\ncontract DiamondInit {\\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\\n    using LibInput for LibInput.DiamondStorage;\\n\\n    /// @notice initialize the diamond\\n    /// @param _dConfig diamond configurations\\n    function init(DiamondConfig calldata _dConfig) external {\\n        initERC165();\\n        initValidatorManager(_dConfig.validators);\\n        initRollups(\\n            _dConfig.templateHash,\\n            _dConfig.inputDuration,\\n            _dConfig.challengePeriod\\n        );\\n        initFeeManager(\\n            _dConfig.feePerClaim,\\n            _dConfig.feeManagerBank,\\n            _dConfig.feeManagerOwner\\n        );\\n        initInput(_dConfig.inputLog2Size);\\n    }\\n\\n    /// @notice initialize ERC165 data\\n    function initERC165() private {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n    }\\n\\n    /// @notice initalize the Input facet\\n    /// @param _inputLog2Size size of the input memory range in this machine\\n    function initInput(uint256 _inputLog2Size) private {\\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\\n\\n        require(\\n            _inputLog2Size >= 3 && _inputLog2Size <= 64,\\n            \\\"Log of input size: [3,64]\\\"\\n        );\\n\\n        inputDS.inputDriveSize = (1 << _inputLog2Size);\\n\\n        // input box gets initialized with one empty input\\n        // so that the L2 DApp knows it's own address\\n        inputDS.addInternalInput(\\\"\\\");\\n    }\\n\\n    /// @notice initialize the Validator Manager facet\\n    /// @param _validators initial validator set\\n    function initValidatorManager(address payable[] memory _validators)\\n        private\\n    {\\n        LibValidatorManager.DiamondStorage\\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\\n\\n        uint256 maxNumValidators = _validators.length;\\n\\n        require(maxNumValidators <= 8, \\\"up to 8 validators\\\");\\n\\n        validatorManagerDS.validators = _validators;\\n        validatorManagerDS.maxNumValidators = maxNumValidators;\\n\\n        // create a new ClaimsMask, with only the consensus goal set,\\n        //      according to the number of validators\\n        validatorManagerDS.claimsMask = LibClaimsMask\\n            .newClaimsMaskWithConsensusGoalSet(maxNumValidators);\\n    }\\n\\n    /// @notice rollups contract initialized\\n    /// @param inputDuration duration of input accumulation phase in seconds\\n    /// @param challengePeriod duration of challenge period in seconds\\n    event RollupsInitialized(uint256 inputDuration, uint256 challengePeriod);\\n\\n    /// @notice initialize the Rollups facet\\n    /// @param _templateHash state hash of the cartesi machine at t0\\n    /// @param _inputDuration duration of input accumulation phase in seconds\\n    /// @param _challengePeriod duration of challenge period in seconds\\n    function initRollups(\\n        bytes32 _templateHash,\\n        uint256 _inputDuration,\\n        uint256 _challengePeriod\\n    ) private {\\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\\n            .diamondStorage();\\n\\n        rollupsDS.templateHash = _templateHash;\\n        rollupsDS.inputDuration = uint32(_inputDuration);\\n        rollupsDS.challengePeriod = uint32(_challengePeriod);\\n        rollupsDS.inputAccumulationStart = uint32(block.timestamp);\\n        rollupsDS.currentPhase_int = uint32(Phase.InputAccumulation);\\n\\n        emit RollupsInitialized(_inputDuration, _challengePeriod);\\n    }\\n\\n    /// @notice FeeManagerImpl contract initialized\\n    /// @param feePerClaim fee per claim to reward the validators\\n    /// @param feeManagerBank fee manager bank address\\n    /// @param feeManagerOwner fee manager owner address\\n    event FeeManagerInitialized(\\n        uint256 feePerClaim,\\n        address feeManagerBank,\\n        address feeManagerOwner\\n    );\\n\\n    /// @notice initalize the Fee Manager facet\\n    /// @param _feePerClaim fee per claim to reward the validators\\n    /// @param _feeManagerBank fee manager bank address\\n    /// @param _feeManagerOwner fee manager owner address\\n    function initFeeManager(\\n        uint256 _feePerClaim,\\n        address _feeManagerBank,\\n        address _feeManagerOwner\\n    ) private {\\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\\n            .diamondStorage();\\n\\n        feeManagerDS.feePerClaim = _feePerClaim;\\n        feeManagerDS.bank = IBank(_feeManagerBank);\\n        feeManagerDS.owner = _feeManagerOwner;\\n\\n        emit FeeManagerInitialized(\\n            _feePerClaim,\\n            _feeManagerBank,\\n            _feeManagerOwner\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xe627b754df9ee7265f1031cc946bb27d1de8dbb29a7e745453682420b5d9ee76\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610ab1806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063af52770114610030575b600080fd5b61004361003e3660046108d6565b610045565b005b6101267fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131f6020527f699d9daa71b280d05a152715774afa0a81a312594b2d731d6b0b2552b7d6f69f8054600160ff1991821681179092557ff97e938d8af42f52387bb74b8b526fda8f184cc2aa534340a8d75a88fbecc77580548216831790557f65d510a5d8f7ef134ec444f7f34ee808c8eeb5177cdfd16be0c40fe1ab43369580548216831790556307f5828d60e41b6000527f5622121b47b8cd0120c4efe45dd5483242f54a3d49bd7679be565d47694918c380549091169091179055565b61016d61013660e0830183610912565b808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506101be92505050565b610181813560208301356040840135610260565b6101ae608082013561019960c0840160a08501610963565b6101a960e0850160c08601610963565b610339565b6101bb8160600135610407565b50565b80517f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fc90600881111561022d5760405162461bcd60e51b8152602060048201526012602482015271757020746f20382076616c696461746f727360701b60448201526064015b60405180910390fd5b8251610242906001840190602086019061085c565b5060028201819055610253816104ae565b8260030181905550505050565b7fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189c8381557fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189d805463ffffffff8481166401000000000267ffffffffffffffff19909216868216179190911773ffffffff00000000ffffffff0000000000000000191642909116600160401b0263ffffffff60801b191617905560408051848152602081018490527fd6f5a5cd17f05cf9045751ee10f662f62e569c9371ffec8380510aabe63012d391015b60405180910390a150505050565b7f844e22529543d6e722c6477171dd50ffe5b412198b92cd9aeea62bbfabe4cc748390557f844e22529543d6e722c6477171dd50ffe5b412198b92cd9aeea62bbfabe4cc7580546001600160a01b038481166001600160a01b031992831681179093557f844e22529543d6e722c6477171dd50ffe5b412198b92cd9aeea62bbfabe4cc7380549185169190921681178255604080518781526020810194909452830152907f5b54873359173c3d639e39928ad34e113039ce7c799d500e57f8a2c703adb4779060600161032b565b7f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff6003821080159061043a575060408211155b6104865760405162461bcd60e51b815260206004820152601960248201527f4c6f67206f6620696e7075742073697a653a205b332c36345d000000000000006044820152606401610224565b6001821b60028201556040805160208101909152600081526104a990829061050f565b505050565b600060088211156104f65760405162461bcd60e51b8152602060048201526012602482015271757020746f20382076616c696461746f727360701b6044820152606401610224565b6000610505600180851b6109b8565b60f01b9392505050565b600061051c838330610523565b9392505050565b600283015482516000917fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189c91111561059d5760405162461bcd60e51b815260206004820152601860248201527f696e707574206c656e3a205b302c647269766553697a655d00000000000000006044820152606401610224565b6105a6816106c8565b156105b4576105b48561079b565b600085600301546000146105cb57856001016105cd565b855b905060006105da836107ba565b8254604080516001600160a01b03891660208083019190915243828401524260608301526080820185905260a08083018590528351808403909101815260c0830184528051908201208b518c83012060e0840182905261010080850182905285518086039091018152610120909401909452825192820192909220600180860189556000898152929092209094018490558654949550909391929161067f91906109b8565b847fa15a0da5519c084484141aaa73e525cee96062f5decc97e070f0c4da27738bc78a428d6040516106b3939291906109cf565b60405180910390a39998505050505050505050565b60018101546000908190600160801b900463ffffffff1660028111156106f0576106f061098c565b600184015490915063ffffffff600160401b820481169116600083600281111561071c5761071c61098c565b148015610731575061072e8183610a3b565b42115b15610790576001858101805463ffffffff60801b1916600160801b1790556040517fed606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8f9161077d91610a53565b60405180910390a1506001949350505050565b506000949350505050565b6003810154156107ac5760006107af565b60015b60ff16600390910155565b7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5675460018201546000917f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566918390600160801b900463ffffffff1660028111156108265761082661098c565b9050600081600281111561083c5761083c61098c565b146108515761084c826001610a3b565b610853565b815b95945050505050565b8280548282559060005260206000209081019282156108b1579160200282015b828111156108b157825182546001600160a01b0319166001600160a01b0390911617825560209092019160019091019061087c565b506108bd9291506108c1565b5090565b5b808211156108bd57600081556001016108c2565b6000602082840312156108e857600080fd5b813567ffffffffffffffff8111156108ff57600080fd5b8201610100818503121561051c57600080fd5b6000808335601e1984360301811261092957600080fd5b83018035915067ffffffffffffffff82111561094457600080fd5b6020019150600581901b360382131561095c57600080fd5b9250929050565b60006020828403121561097557600080fd5b81356001600160a01b038116811461051c57600080fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000828210156109ca576109ca6109a2565b500390565b60018060a01b038416815260006020848184015260606040840152835180606085015260005b81811015610a11578581018301518582016080015282016109f5565b81811115610a23576000608083870101525b50601f01601f19169290920160800195945050505050565b60008219821115610a4e57610a4e6109a2565b500190565b6020810160038310610a7557634e487b7160e01b600052602160045260246000fd5b9190529056fea26469706673582212205c1aea48b8585467b96c762ebc1e8162451390f82e4d8071d25e6dfba85f22bb64736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063af52770114610030575b600080fd5b61004361003e3660046108d6565b610045565b005b6101267fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131f6020527f699d9daa71b280d05a152715774afa0a81a312594b2d731d6b0b2552b7d6f69f8054600160ff1991821681179092557ff97e938d8af42f52387bb74b8b526fda8f184cc2aa534340a8d75a88fbecc77580548216831790557f65d510a5d8f7ef134ec444f7f34ee808c8eeb5177cdfd16be0c40fe1ab43369580548216831790556307f5828d60e41b6000527f5622121b47b8cd0120c4efe45dd5483242f54a3d49bd7679be565d47694918c380549091169091179055565b61016d61013660e0830183610912565b808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506101be92505050565b610181813560208301356040840135610260565b6101ae608082013561019960c0840160a08501610963565b6101a960e0850160c08601610963565b610339565b6101bb8160600135610407565b50565b80517f8ab37fef2b2e34c4b62ff9948ee661cdcf34e209d7c20f4d1f6e83085e93b1fc90600881111561022d5760405162461bcd60e51b8152602060048201526012602482015271757020746f20382076616c696461746f727360701b60448201526064015b60405180910390fd5b8251610242906001840190602086019061085c565b5060028201819055610253816104ae565b8260030181905550505050565b7fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189c8381557fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189d805463ffffffff8481166401000000000267ffffffffffffffff19909216868216179190911773ffffffff00000000ffffffff0000000000000000191642909116600160401b0263ffffffff60801b191617905560408051848152602081018490527fd6f5a5cd17f05cf9045751ee10f662f62e569c9371ffec8380510aabe63012d391015b60405180910390a150505050565b7f844e22529543d6e722c6477171dd50ffe5b412198b92cd9aeea62bbfabe4cc748390557f844e22529543d6e722c6477171dd50ffe5b412198b92cd9aeea62bbfabe4cc7580546001600160a01b038481166001600160a01b031992831681179093557f844e22529543d6e722c6477171dd50ffe5b412198b92cd9aeea62bbfabe4cc7380549185169190921681178255604080518781526020810194909452830152907f5b54873359173c3d639e39928ad34e113039ce7c799d500e57f8a2c703adb4779060600161032b565b7f943d5d24442f02461445e15c5d7d4a4ef0acb0d32c5d6f6af37a6882249912ff6003821080159061043a575060408211155b6104865760405162461bcd60e51b815260206004820152601960248201527f4c6f67206f6620696e7075742073697a653a205b332c36345d000000000000006044820152606401610224565b6001821b60028201556040805160208101909152600081526104a990829061050f565b505050565b600060088211156104f65760405162461bcd60e51b8152602060048201526012602482015271757020746f20382076616c696461746f727360701b6044820152606401610224565b6000610505600180851b6109b8565b60f01b9392505050565b600061051c838330610523565b9392505050565b600283015482516000917fd32d7f90491bee81172a406b65f3270d810392fe53bb0379dde8bdd4e624189c91111561059d5760405162461bcd60e51b815260206004820152601860248201527f696e707574206c656e3a205b302c647269766553697a655d00000000000000006044820152606401610224565b6105a6816106c8565b156105b4576105b48561079b565b600085600301546000146105cb57856001016105cd565b855b905060006105da836107ba565b8254604080516001600160a01b03891660208083019190915243828401524260608301526080820185905260a08083018590528351808403909101815260c0830184528051908201208b518c83012060e0840182905261010080850182905285518086039091018152610120909401909452825192820192909220600180860189556000898152929092209094018490558654949550909391929161067f91906109b8565b847fa15a0da5519c084484141aaa73e525cee96062f5decc97e070f0c4da27738bc78a428d6040516106b3939291906109cf565b60405180910390a39998505050505050505050565b60018101546000908190600160801b900463ffffffff1660028111156106f0576106f061098c565b600184015490915063ffffffff600160401b820481169116600083600281111561071c5761071c61098c565b148015610731575061072e8183610a3b565b42115b15610790576001858101805463ffffffff60801b1916600160801b1790556040517fed606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8f9161077d91610a53565b60405180910390a1506001949350505050565b506000949350505050565b6003810154156107ac5760006107af565b60015b60ff16600390910155565b7f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea5675460018201546000917f0635ad75fae4d4e8d896461a635d23700076a1c3fd8da26276f18cb1c09ea566918390600160801b900463ffffffff1660028111156108265761082661098c565b9050600081600281111561083c5761083c61098c565b146108515761084c826001610a3b565b610853565b815b95945050505050565b8280548282559060005260206000209081019282156108b1579160200282015b828111156108b157825182546001600160a01b0319166001600160a01b0390911617825560209092019160019091019061087c565b506108bd9291506108c1565b5090565b5b808211156108bd57600081556001016108c2565b6000602082840312156108e857600080fd5b813567ffffffffffffffff8111156108ff57600080fd5b8201610100818503121561051c57600080fd5b6000808335601e1984360301811261092957600080fd5b83018035915067ffffffffffffffff82111561094457600080fd5b6020019150600581901b360382131561095c57600080fd5b9250929050565b60006020828403121561097557600080fd5b81356001600160a01b038116811461051c57600080fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000828210156109ca576109ca6109a2565b500390565b60018060a01b038416815260006020848184015260606040840152835180606085015260005b81811015610a11578581018301518582016080015282016109f5565b81811115610a23576000608083870101525b50601f01601f19169290920160800195945050505050565b60008219821115610a4e57610a4e6109a2565b500190565b6020810160038310610a7557634e487b7160e01b600052602160045260246000fd5b9190529056fea26469706673582212205c1aea48b8585467b96c762ebc1e8162451390f82e4d8071d25e6dfba85f22bb64736f6c634300080d0033",
  "libraries": {
    "LibClaimsMask": "0x9A676e781A523b5d0C0e43731313A708CB607508"
  },
  "devdoc": {
    "events": {
      "FeeManagerInitialized(uint256,address,address)": {
        "params": {
          "feeManagerBank": "fee manager bank address",
          "feeManagerOwner": "fee manager owner address",
          "feePerClaim": "fee per claim to reward the validators"
        }
      },
      "RollupsInitialized(uint256,uint256)": {
        "params": {
          "challengePeriod": "duration of challenge period in seconds",
          "inputDuration": "duration of input accumulation phase in seconds"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "init((bytes32,uint256,uint256,uint256,uint256,address,address,address[]))": {
        "params": {
          "_dConfig": "diamond configurations"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "FeeManagerInitialized(uint256,address,address)": {
        "notice": "FeeManagerImpl contract initialized"
      },
      "RollupsInitialized(uint256,uint256)": {
        "notice": "rollups contract initialized"
      }
    },
    "kind": "user",
    "methods": {
      "init((bytes32,uint256,uint256,uint256,uint256,address,address,address[]))": {
        "notice": "initialize the diamond"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}