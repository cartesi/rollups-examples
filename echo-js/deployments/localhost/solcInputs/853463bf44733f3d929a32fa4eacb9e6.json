{
  "language": "Solidity",
  "sources": {
    "contracts/Bank.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// @title Bank contract\npragma solidity ^0.8.0;\n\nimport {IBank} from \"./IBank.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Bank is IBank {\n    IERC20 private immutable token;\n\n    // `balances` maps account/contract addresses to balances\n    mapping(address => uint256) private balances;\n\n    constructor(address _token) {\n        require(_token != address(0), \"Bank: invalid token\");\n        token = IERC20(_token);\n    }\n\n    function getToken() public view override returns (IERC20) {\n        return token;\n    }\n\n    function balanceOf(address _owner) public view override returns (uint256) {\n        return balances[_owner];\n    }\n\n    function transferTokens(address _to, uint256 _value) public override {\n        // checks\n        uint256 balance = balances[msg.sender];\n        require(_value <= balance, \"Bank: not enough balance\");\n\n        // effects\n        // Note: this should not underflow because we checked that\n        // `_value <= balance` in the `require` above\n        unchecked {\n            balances[msg.sender] = balance - _value;\n        }\n\n        // interactions\n        // Note: a well-implemented ERC-20 contract should already\n        // require the recipient (in this case, `_to`) to be different\n        // than address(0), so we don't need to check it ourselves\n        require(token.transfer(_to, _value), \"Bank: transfer failed\");\n        emit Transfer(msg.sender, _to, _value);\n    }\n\n    function depositTokens(address _to, uint256 _value) public override {\n        // checks\n        require(_to != address(0), \"Bank: invalid recipient\");\n\n        // effects\n        // Note: this should not overflow because `IERC20.totalSupply`\n        // returns a `uint256` value, so there can't be more than\n        // `uint256.max` tokens in an ERC-20 contract.\n        balances[_to] += _value;\n\n        // interactions\n        // Note: transfers tokens to bank, but emits `Deposit` event\n        // with recipient being `_to`\n        require(\n            token.transferFrom(msg.sender, address(this), _value),\n            \"Bank: transferFrom failed\"\n        );\n        emit Deposit(msg.sender, _to, _value);\n    }\n}\n"
    },
    "contracts/IBank.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// @title Bank interface\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBank {\n    /// @notice returns the token used internally\n    function getToken() external view returns (IERC20);\n\n    /// @notice get balance of `_owner`\n    /// @param _owner account owner\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice transfer `_value` tokens from bank to `_to`\n    /// @notice decrease the balance of caller by `_value`\n    /// @param _to account that will receive `_value` tokens\n    /// @param _value amount of tokens to be transfered\n    function transferTokens(address _to, uint256 _value) external;\n\n    /// @notice transfer `_value` tokens from caller to bank\n    /// @notice increase the balance of `_to` by `_value`\n    /// @dev you may need to call `token.approve(bank, _value)`\n    /// @param _to account that will have their balance increased by `_value`\n    /// @param _value amount of tokens to be transfered\n    function depositTokens(address _to, uint256 _value) external;\n\n    /// @notice `value` tokens were transfered from the bank to `to`\n    /// @notice the balance of `from` was decreased by `value`\n    /// @dev is triggered on any successful call to `transferTokens`\n    /// @param from the account/contract that called `transferTokens` and\n    ///              got their balance decreased by `value`\n    /// @param to the one that received `value` tokens from the bank\n    /// @param value amount of tokens that were transfered\n    event Transfer(address indexed from, address to, uint256 value);\n\n    /// @notice `value` tokens were transfered from `from` to bank\n    /// @notice the balance of `to` was increased by `value`\n    /// @dev is triggered on any successful call to `depositTokens`\n    /// @param from the account/contract that called `depositTokens` and\n    ///              transfered `value` tokens to the bank\n    /// @param to the one that got their balance increased by `value`\n    /// @param value amount of tokens that were transfered\n    event Deposit(address from, address indexed to, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/facets/ERC721PortalFacet.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Generic ERC721 Portal facet\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IERC721Portal} from \"../interfaces/IERC721Portal.sol\";\n\nimport {LibInput} from \"../libraries/LibInput.sol\";\n\ncontract ERC721PortalFacet is IERC721Portal {\n    using LibInput for LibInput.DiamondStorage;\n\n    bytes32 constant INPUT_HEADER = keccak256(\"ERC721_Transfer\");\n\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data to be interpreted by L2\n    /// @return this function selector unless throwing\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) public override returns (bytes4) {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        address erc721Contract = msg.sender;\n\n        bytes memory input = abi.encode(\n            INPUT_HEADER,\n            erc721Contract,\n            _operator,\n            _from,\n            _tokenId,\n            _data\n        );\n\n        inputDS.addInternalInput(input);\n\n        emit ERC721Received(erc721Contract, _operator, _from, _tokenId, _data);\n\n        // return the magic value to approve the transfer\n        return this.onERC721Received.selector;\n    }\n\n    /// @notice withdraw an ERC721 token from the portal\n    /// @param _data data with withdrawal information\n    /// @dev can only be called by the Rollups contract\n    function erc721Withdrawal(bytes calldata _data)\n        public\n        override\n        returns (bool)\n    {\n        // Delegate calls preserve msg.sender, msg.value and address(this)\n        require(msg.sender == address(this), \"only itself\");\n\n        (address tokenAddr, address payable receiver, uint256 tokenId) = abi\n            .decode(_data, (address, address, uint256));\n\n        IERC721 token = IERC721(tokenAddr);\n\n        // transfer reverts on failure\n        token.safeTransferFrom(address(this), receiver, tokenId);\n\n        emit ERC721Withdrawn(tokenAddr, receiver, tokenId);\n        return true;\n    }\n}\n"
    },
    "contracts/interfaces/IERC721Portal.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Generic ERC721 Portal interface\npragma solidity >=0.7.0;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ninterface IERC721Portal is IERC721Receiver {\n    /// @notice withdraw an ERC721 token from the portal\n    /// @param _data data with withdrawal information\n    /// @dev can only be called by the Rollups contract\n    function erc721Withdrawal(bytes calldata _data) external returns (bool);\n\n    /// @notice emitted on a call to `onERC721Received`\n    event ERC721Received(\n        address ERC721,\n        address operator,\n        address sender,\n        uint256 tokenId,\n        bytes data\n    );\n\n    /// @notice emitted on ERC721 withdrawal\n    event ERC721Withdrawn(\n        address ERC721,\n        address payable receiver,\n        uint256 tokenId\n    );\n}\n"
    },
    "contracts/libraries/LibInput.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Input library\npragma solidity ^0.8.0;\n\nimport {LibRollups} from \"../libraries/LibRollups.sol\";\n\nlibrary LibInput {\n    using LibRollups for LibRollups.DiamondStorage;\n\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"Input.diamond.storage\");\n\n    struct DiamondStorage {\n        // always needs to keep track of two input boxes:\n        // 1 for the input accumulation of next epoch\n        // and 1 for the messages during current epoch. To save gas we alternate\n        // between inputBox0 and inputBox1\n        bytes32[] inputBox0;\n        bytes32[] inputBox1;\n        uint256 inputDriveSize; // size of input flashdrive\n        uint256 currentInputBox;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice get input inside inbox of currently proposed claim\n    /// @param ds diamond storage pointer\n    /// @param index index of input inside that inbox\n    /// @return hash of input at index index\n    /// @dev currentInputBox being zero means that the inputs for\n    ///      the claimed epoch are on input box one\n    function getInput(DiamondStorage storage ds, uint256 index)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            ds.currentInputBox == 0 ? ds.inputBox1[index] : ds.inputBox0[index];\n    }\n\n    /// @notice get number of inputs inside inbox of currently proposed claim\n    /// @param ds diamond storage pointer\n    /// @return number of inputs on that input box\n    /// @dev currentInputBox being zero means that the inputs for\n    ///      the claimed epoch are on input box one\n    function getNumberOfInputs(DiamondStorage storage ds)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            ds.currentInputBox == 0 ? ds.inputBox1.length : ds.inputBox0.length;\n    }\n\n    /// @notice add input to processed by next epoch\n    /// @param ds diamond storage pointer\n    /// @param input input to be understood by offchain machine\n    /// @dev offchain code is responsible for making sure\n    ///      that input size is power of 2 and multiple of 8 since\n    ///      the offchain machine has a 8 byte word\n    function addInput(DiamondStorage storage ds, bytes memory input)\n        internal\n        returns (bytes32)\n    {\n        return addInputFromSender(ds, input, msg.sender);\n    }\n\n    /// @notice add internal input to processed by next epoch\n    /// @notice this function is to be reserved for internal usage only\n    /// @notice for normal inputs, call `addInput` instead\n    /// @param ds diamond storage pointer\n    /// @param input input to be understood by offchain machine\n    /// @dev offchain code is responsible for making sure\n    ///      that input size is power of 2 and multiple of 8 since\n    ///      the offchain machine has a 8 byte word\n    function addInternalInput(DiamondStorage storage ds, bytes memory input)\n        internal\n        returns (bytes32)\n    {\n        return addInputFromSender(ds, input, address(this));\n    }\n\n    /// @notice add input from a specific sender to processed by next epoch\n    /// @notice this function is to be reserved for internal usage only\n    /// @notice for normal inputs, call `addInput` instead\n    /// @param ds diamond storage pointer\n    /// @param input input to be understood by offchain machine\n    /// @param sender input sender address\n    /// @dev offchain code is responsible for making sure\n    ///      that input size is power of 2 and multiple of 8 since\n    ///      the offchain machine has a 8 byte word\n    function addInputFromSender(\n        DiamondStorage storage ds,\n        bytes memory input,\n        address sender\n    ) internal returns (bytes32) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n\n        require(input.length <= ds.inputDriveSize, \"input len: [0,driveSize]\");\n\n        // notifyInput returns true if that input\n        // belongs to a new epoch\n        if (rollupsDS.notifyInput()) {\n            swapInputBox(ds);\n        }\n\n        // points to correct inputBox\n        bytes32[] storage inputBox = ds.currentInputBox == 0\n            ? ds.inputBox0\n            : ds.inputBox1;\n\n        // get current epoch index\n        uint256 currentEpoch = rollupsDS.getCurrentEpoch();\n\n        // keccak 64 bytes into 32 bytes\n        bytes32 keccakMetadata = keccak256(\n            abi.encode(\n                sender,\n                block.number,\n                block.timestamp,\n                currentEpoch, // epoch index\n                inputBox.length // input index\n            )\n        );\n\n        bytes32 keccakInput = keccak256(input);\n\n        bytes32 inputHash = keccak256(abi.encode(keccakMetadata, keccakInput));\n\n        // add input to correct inbox\n        inputBox.push(inputHash);\n\n        emit InputAdded(\n            currentEpoch,\n            inputBox.length - 1,\n            sender,\n            block.timestamp,\n            input\n        );\n\n        return inputHash;\n    }\n\n    /// @notice called when a new input accumulation phase begins\n    ///         swap inbox to receive inputs for upcoming epoch\n    /// @param ds diamond storage pointer\n    function onNewInputAccumulation(DiamondStorage storage ds) internal {\n        swapInputBox(ds);\n    }\n\n    /// @notice called when a new epoch begins, clears deprecated inputs\n    /// @param ds diamond storage pointer\n    function onNewEpoch(DiamondStorage storage ds) internal {\n        // clear input box for new inputs\n        // the current input box should be accumulating inputs\n        // for the new epoch already. So we clear the other one.\n        ds.currentInputBox == 0 ? delete ds.inputBox1 : delete ds.inputBox0;\n    }\n\n    /// @notice changes current input box\n    /// @param ds diamond storage pointer\n    function swapInputBox(DiamondStorage storage ds) internal {\n        ds.currentInputBox = (ds.currentInputBox == 0) ? 1 : 0;\n    }\n\n    /// @notice input added\n    /// @param epochNumber which epoch this input belongs to\n    /// @param inputIndex index of the input just added\n    /// @param sender msg.sender\n    /// @param timestamp block.timestamp\n    /// @param input input data\n    event InputAdded(\n        uint256 indexed epochNumber,\n        uint256 indexed inputIndex,\n        address sender,\n        uint256 timestamp,\n        bytes input\n    );\n}\n"
    },
    "contracts/libraries/LibRollups.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Rollups library\npragma solidity ^0.8.0;\n\nimport {Phase} from \"../interfaces/IRollups.sol\";\nimport {Result} from \"../interfaces/IValidatorManager.sol\";\n\nimport {LibInput} from \"../libraries/LibInput.sol\";\nimport {LibOutput} from \"../libraries/LibOutput.sol\";\nimport {LibValidatorManager} from \"../libraries/LibValidatorManager.sol\";\nimport {LibDisputeManager} from \"../libraries/LibDisputeManager.sol\";\n\nlibrary LibRollups {\n    using LibInput for LibInput.DiamondStorage;\n    using LibOutput for LibOutput.DiamondStorage;\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\n\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"Rollups.diamond.storage\");\n\n    struct DiamondStorage {\n        bytes32 templateHash; // state hash of the cartesi machine at t0\n        uint32 inputDuration; // duration of input accumulation phase in seconds\n        uint32 challengePeriod; // duration of challenge period in seconds\n        uint32 inputAccumulationStart; // timestamp when current input accumulation phase started\n        uint32 sealingEpochTimestamp; // timestamp on when a proposed epoch (claim) becomes challengeable\n        uint32 currentPhase_int; // current phase in integer form\n    }\n\n    /// @notice epoch finalized\n    /// @param epochNumber number of the epoch being finalized\n    /// @param epochHash claim being submitted by this epoch\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\n\n    /// @notice dispute resolved\n    /// @param winner winner of dispute\n    /// @param loser loser of dispute\n    /// @param winningClaim initial claim of winning validator\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\n\n    /// @notice phase change\n    /// @param newPhase new phase\n    event PhaseChange(Phase newPhase);\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice called when new input arrives, manages the phase changes\n    /// @param ds diamond storage pointer\n    /// @dev can only be called by input contract\n    function notifyInput(DiamondStorage storage ds) internal returns (bool) {\n        Phase currentPhase = Phase(ds.currentPhase_int);\n        uint256 inputAccumulationStart = ds.inputAccumulationStart;\n        uint256 inputDuration = ds.inputDuration;\n\n        if (\n            currentPhase == Phase.InputAccumulation &&\n            block.timestamp > inputAccumulationStart + inputDuration\n        ) {\n            ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\n            emit PhaseChange(Phase.AwaitingConsensus);\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice called when a dispute is resolved by the dispute manager\n    /// @param ds diamond storage pointer\n    /// @param winner winner of dispute\n    /// @param loser loser of dispute\n    /// @param winningClaim initial claim of winning validator\n    function resolveDispute(\n        DiamondStorage storage ds,\n        address payable winner,\n        address payable loser,\n        bytes32 winningClaim\n    ) internal {\n        Result result;\n        bytes32[2] memory claims;\n        address payable[2] memory claimers;\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n\n        (result, claims, claimers) = validatorManagerDS.onDisputeEnd(\n            winner,\n            loser,\n            winningClaim\n        );\n\n        // restart challenge period\n        ds.sealingEpochTimestamp = uint32(block.timestamp);\n\n        emit ResolveDispute(winner, loser, winningClaim);\n        resolveValidatorResult(ds, result, claims, claimers);\n    }\n\n    /// @notice resolve results returned by validator manager\n    /// @param ds diamond storage pointer\n    /// @param result result from claim or dispute operation\n    /// @param claims array of claims in case of new conflict\n    /// @param claimers array of claimers in case of new conflict\n    function resolveValidatorResult(\n        DiamondStorage storage ds,\n        Result result,\n        bytes32[2] memory claims,\n        address payable[2] memory claimers\n    ) internal {\n        if (result == Result.NoConflict) {\n            Phase currentPhase = Phase(ds.currentPhase_int);\n            if (currentPhase != Phase.AwaitingConsensus) {\n                ds.currentPhase_int = uint32(Phase.AwaitingConsensus);\n                emit PhaseChange(Phase.AwaitingConsensus);\n            }\n        } else if (result == Result.Consensus) {\n            startNewEpoch(ds);\n        } else {\n            // for the case when result == Result.Conflict\n            Phase currentPhase = Phase(ds.currentPhase_int);\n            if (currentPhase != Phase.AwaitingDispute) {\n                ds.currentPhase_int = uint32(Phase.AwaitingDispute);\n                emit PhaseChange(Phase.AwaitingDispute);\n            }\n            LibDisputeManager.initiateDispute(claims, claimers);\n        }\n    }\n\n    /// @notice starts new epoch\n    /// @param ds diamond storage pointer\n    function startNewEpoch(DiamondStorage storage ds) internal {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n\n        // reset input accumulation start and deactivate challenge period start\n        ds.currentPhase_int = uint32(Phase.InputAccumulation);\n        emit PhaseChange(Phase.InputAccumulation);\n        ds.inputAccumulationStart = uint32(block.timestamp);\n        ds.sealingEpochTimestamp = type(uint32).max;\n\n        bytes32 finalClaim = validatorManagerDS.onNewEpoch();\n\n        // emit event before finalized epoch is added to the Output storage\n        emit FinalizeEpoch(outputDS.getNumberOfFinalizedEpochs(), finalClaim);\n\n        outputDS.onNewEpoch(finalClaim);\n        inputDS.onNewEpoch();\n    }\n\n    /// @notice returns index of current (accumulating) epoch\n    /// @param ds diamond storage pointer\n    /// @return index of current epoch\n    /// @dev if phase is input accumulation, then the epoch number is length\n    ///      of finalized epochs array, else there are two non finalized epochs,\n    ///      one awaiting consensus/dispute and another accumulating input\n    function getCurrentEpoch(DiamondStorage storage ds)\n        internal\n        view\n        returns (uint256)\n    {\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\n\n        uint256 finalizedEpochs = outputDS.getNumberOfFinalizedEpochs();\n\n        Phase currentPhase = Phase(ds.currentPhase_int);\n\n        return\n            currentPhase == Phase.InputAccumulation\n                ? finalizedEpochs\n                : finalizedEpochs + 1;\n    }\n}\n"
    },
    "contracts/interfaces/IRollups.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Rollups interface\npragma solidity >=0.7.0;\n\n// InputAccumulation - Inputs being accumulated for currrent epoch\n// AwaitingConsensus - No disagreeing claims (or no claims)\n// AwaitingDispute - Waiting for dispute to be over\n// inputs received during InputAccumulation will be included in the\n// current epoch. Inputs received while WaitingClaims or ChallengesInProgress\n// are accumulated for the next epoch\nenum Phase {\n    InputAccumulation,\n    AwaitingConsensus,\n    AwaitingDispute\n}\n\ninterface IRollups {\n    /// @notice claim the result of current epoch\n    /// @param _epochHash hash of epoch\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\n    ///      and that claim != bytes32(0)\n    /// TODO: add signatures for aggregated claims\n    function claim(bytes32 _epochHash) external;\n\n    /// @notice finalize epoch after timeout\n    /// @dev can only be called if challenge period is over\n    function finalizeEpoch() external;\n\n    /// @notice returns index of current (accumulating) epoch\n    /// @return index of current epoch\n    /// @dev if phase is input accumulation, then the epoch number is length\n    ///      of finalized epochs array, else there are two epochs two non\n    ///      finalized epochs, one awaiting consensus/dispute and another\n    ///      accumulating input\n    function getCurrentEpoch() external view returns (uint256);\n\n    /// @notice claim submitted\n    /// @param epochHash claim being submitted by this epoch\n    /// @param claimer address of current claimer\n    /// @param epochNumber number of the epoch being submitted\n    event Claim(\n        uint256 indexed epochNumber,\n        address claimer,\n        bytes32 epochHash\n    );\n\n    /// @notice epoch finalized\n    /// @param epochNumber number of the epoch being finalized\n    /// @param epochHash claim being submitted by this epoch\n    event FinalizeEpoch(uint256 indexed epochNumber, bytes32 epochHash);\n\n    /// @notice dispute resolved\n    /// @param winner winner of dispute\n    /// @param loser loser of dispute\n    /// @param winningClaim initial claim of winning validator\n    event ResolveDispute(address winner, address loser, bytes32 winningClaim);\n\n    /// @notice phase change\n    /// @param newPhase new phase\n    event PhaseChange(Phase newPhase);\n}\n"
    },
    "contracts/interfaces/IValidatorManager.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Validator Manager interface\npragma solidity >=0.7.0;\n\n// NoConflict - No conflicting claims or consensus\n// Consensus - All validators had equal claims\n// Conflict - Claim is conflicting with previous one\nenum Result {\n    NoConflict,\n    Consensus,\n    Conflict\n}\n\n// TODO: What is the incentive for validators to not just copy the first claim that arrived?\ninterface IValidatorManager {\n    /// @notice get current claim\n    function getCurrentClaim() external view returns (bytes32);\n\n    /// @notice emitted on Claim received\n    event ClaimReceived(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on Dispute end\n    event DisputeEnded(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on new Epoch\n    event NewEpoch(bytes32 claim);\n}\n"
    },
    "contracts/libraries/LibOutput.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Output library\npragma solidity ^0.8.0;\n\nlibrary LibOutput {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"Output.diamond.storage\");\n\n    struct DiamondStorage {\n        mapping(uint256 => uint256) voucherBitmask;\n        bytes32[] epochHashes;\n        bool lock; //reentrancy lock\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice to be called when an epoch is finalized\n    /// @param ds diamond storage pointer\n    /// @param epochHash hash of finalized epoch\n    /// @dev an epoch being finalized means that its vouchers can be called\n    function onNewEpoch(DiamondStorage storage ds, bytes32 epochHash) internal {\n        ds.epochHashes.push(epochHash);\n    }\n\n    /// @notice get number of finalized epochs\n    /// @param ds diamond storage pointer\n    function getNumberOfFinalizedEpochs(DiamondStorage storage ds)\n        internal\n        view\n        returns (uint256)\n    {\n        return ds.epochHashes.length;\n    }\n}\n"
    },
    "contracts/libraries/LibValidatorManager.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Validator Manager library\npragma solidity ^0.8.0;\n\nimport {Result} from \"../interfaces/IValidatorManager.sol\";\n\nimport {LibClaimsMask, ClaimsMask} from \"../libraries/LibClaimsMask.sol\";\nimport {LibFeeManager} from \"../libraries/LibFeeManager.sol\";\n\nlibrary LibValidatorManager {\n    using LibClaimsMask for ClaimsMask;\n    using LibFeeManager for LibFeeManager.DiamondStorage;\n\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"ValidatorManager.diamond.storage\");\n\n    struct DiamondStorage {\n        bytes32 currentClaim; // current claim - first claim of this epoch\n        address payable[] validators; // up to 8 validators\n        uint256 maxNumValidators; // the maximum number of validators, set in the constructor\n        // A bit set used for up to 8 validators.\n        // The first 8 bits are used to indicate whom supports the current claim\n        // The second 8 bits are used to indicate those should have claimed in order to reach consensus\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\n        // | agreement mask | consensus mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\n        // |     8 bits     |     8 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\n        ClaimsMask claimsMask;\n    }\n\n    /// @notice emitted on Claim received\n    event ClaimReceived(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on Dispute end\n    event DisputeEnded(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on new Epoch\n    event NewEpoch(bytes32 claim);\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice called when a dispute ends in rollups\n    /// @param ds diamond storage pointer\n    /// @param winner address of dispute winner\n    /// @param loser address of dispute loser\n    /// @param winningClaim the winnning claim\n    /// @return result of dispute being finished\n    function onDisputeEnd(\n        DiamondStorage storage ds,\n        address payable winner,\n        address payable loser,\n        bytes32 winningClaim\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        removeValidator(ds, loser);\n\n        if (winningClaim == ds.currentClaim) {\n            // first claim stood, dont need to update the bitmask\n            return\n                isConsensus(ds)\n                    ? emitDisputeEndedAndReturn(\n                        Result.Consensus,\n                        [winningClaim, bytes32(0)],\n                        [winner, payable(0)]\n                    )\n                    : emitDisputeEndedAndReturn(\n                        Result.NoConflict,\n                        [winningClaim, bytes32(0)],\n                        [winner, payable(0)]\n                    );\n        }\n\n        // if first claim lost, and other validators have agreed with it\n        // there is a new dispute to be played\n        if (ds.claimsMask.getAgreementMask() != 0) {\n            return\n                emitDisputeEndedAndReturn(\n                    Result.Conflict,\n                    [ds.currentClaim, winningClaim],\n                    [getClaimerOfCurrentClaim(ds), winner]\n                );\n        }\n        // else there are no valdiators that agree with losing claim\n        // we can update current claim and check for consensus in case\n        // the winner is the only validator left\n        ds.currentClaim = winningClaim;\n        updateClaimAgreementMask(ds, winner);\n        return\n            isConsensus(ds)\n                ? emitDisputeEndedAndReturn(\n                    Result.Consensus,\n                    [winningClaim, bytes32(0)],\n                    [winner, payable(0)]\n                )\n                : emitDisputeEndedAndReturn(\n                    Result.NoConflict,\n                    [winningClaim, bytes32(0)],\n                    [winner, payable(0)]\n                );\n    }\n\n    /// @notice called when a new epoch starts\n    /// @param ds diamond storage pointer\n    /// @return current claim\n    function onNewEpoch(DiamondStorage storage ds) internal returns (bytes32) {\n        // reward validators who has made the correct claim by increasing their #claims\n        claimFinalizedIncreaseCounts(ds);\n\n        bytes32 tmpClaim = ds.currentClaim;\n\n        // clear current claim\n        ds.currentClaim = bytes32(0);\n        // clear validator agreement bit mask\n        ds.claimsMask = ds.claimsMask.clearAgreementMask();\n\n        emit NewEpoch(tmpClaim);\n        return tmpClaim;\n    }\n\n    /// @notice called when a claim is received by rollups\n    /// @param ds diamond storage pointer\n    /// @param sender address of sender of that claim\n    /// @param claim claim received by rollups\n    /// @return result of claim, Consensus | NoConflict | Conflict\n    /// @return [currentClaim, conflicting claim] if there is Conflict\n    ///         [currentClaim, bytes32(0)] if there is Consensus or NoConflcit\n    /// @return [claimer1, claimer2] if there is  Conflcit\n    ///         [claimer1, address(0)] if there is Consensus or NoConflcit\n    function onClaim(\n        DiamondStorage storage ds,\n        address payable sender,\n        bytes32 claim\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        require(claim != bytes32(0), \"empty claim\");\n        require(isValidator(ds, sender), \"sender not allowed\");\n\n        // require the validator hasn't claimed in the same epoch before\n        uint256 index = getValidatorIndex(ds, sender);\n        require(\n            !ds.claimsMask.alreadyClaimed(index),\n            \"sender had claimed in this epoch before\"\n        );\n\n        // cant return because a single claim might mean consensus\n        if (ds.currentClaim == bytes32(0)) {\n            ds.currentClaim = claim;\n        } else if (claim != ds.currentClaim) {\n            return\n                emitClaimReceivedAndReturn(\n                    Result.Conflict,\n                    [ds.currentClaim, claim],\n                    [getClaimerOfCurrentClaim(ds), sender]\n                );\n        }\n        updateClaimAgreementMask(ds, sender);\n\n        return\n            isConsensus(ds)\n                ? emitClaimReceivedAndReturn(\n                    Result.Consensus,\n                    [claim, bytes32(0)],\n                    [sender, payable(0)]\n                )\n                : emitClaimReceivedAndReturn(\n                    Result.NoConflict,\n                    [claim, bytes32(0)],\n                    [sender, payable(0)]\n                );\n    }\n\n    /// @notice emits dispute ended event and then return\n    /// @param result to be emitted and returned\n    /// @param claims to be emitted and returned\n    /// @param validators to be emitted and returned\n    /// @dev this function existis to make code more clear/concise\n    function emitDisputeEndedAndReturn(\n        Result result,\n        bytes32[2] memory claims,\n        address payable[2] memory validators\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        emit DisputeEnded(result, claims, validators);\n        return (result, claims, validators);\n    }\n\n    /// @notice emits claim received event and then return\n    /// @param result to be emitted and returned\n    /// @param claims to be emitted and returned\n    /// @param validators to be emitted and returned\n    /// @dev this function existis to make code more clear/concise\n    function emitClaimReceivedAndReturn(\n        Result result,\n        bytes32[2] memory claims,\n        address payable[2] memory validators\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        emit ClaimReceived(result, claims, validators);\n        return (result, claims, validators);\n    }\n\n    /// @notice only call this function when a claim has been finalized\n    ///         Either a consensus has been reached or challenge period has past\n    /// @param ds pointer to diamond storage\n    function claimFinalizedIncreaseCounts(DiamondStorage storage ds) internal {\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\n        for (uint256 i; i < ds.validators.length; i++) {\n            // if a validator agrees with the current claim\n            if ((agreementMask & (1 << i)) != 0) {\n                // increase #claims by 1\n                ds.claimsMask = ds.claimsMask.increaseNumClaims(i, 1);\n            }\n        }\n    }\n\n    /// @notice removes a validator\n    /// @param ds diamond storage pointer\n    /// @param validator address of validator to be removed\n    function removeValidator(DiamondStorage storage ds, address validator)\n        internal\n    {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (validator == ds.validators[i]) {\n                // put address(0) in validators position\n                ds.validators[i] = payable(0);\n                // remove the validator from ValidatorManager's claimsMask\n                ds.claimsMask = ds.claimsMask.removeValidator(i);\n                // remove the validator from FeeManager's claimsMask (#redeems)\n                feeManagerDS.removeValidator(i);\n                break;\n            }\n        }\n    }\n\n    /// @notice check if consensus has been reached\n    /// @param ds pointer to diamond storage\n    function isConsensus(DiamondStorage storage ds)\n        internal\n        view\n        returns (bool)\n    {\n        ClaimsMask claimsMask = ds.claimsMask;\n        return\n            claimsMask.getAgreementMask() == claimsMask.getConsensusGoalMask();\n    }\n\n    /// @notice get one of the validators that agreed with current claim\n    /// @param ds diamond storage pointer\n    /// @return validator that agreed with current claim\n    function getClaimerOfCurrentClaim(DiamondStorage storage ds)\n        internal\n        view\n        returns (address payable)\n    {\n        // TODO: we are always getting the first validator\n        // on the array that agrees with the current claim to enter a dispute\n        // should this be random?\n        uint256 agreementMask = ds.claimsMask.getAgreementMask();\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (agreementMask & (1 << i) != 0) {\n                return ds.validators[i];\n            }\n        }\n        revert(\"Agreeing validator not found\");\n    }\n\n    /// @notice updates mask of validators that agreed with current claim\n    /// @param ds diamond storage pointer\n    /// @param sender address of validator that will be included in mask\n    function updateClaimAgreementMask(\n        DiamondStorage storage ds,\n        address payable sender\n    ) internal {\n        uint256 validatorIndex = getValidatorIndex(ds, sender);\n        ds.claimsMask = ds.claimsMask.setAgreementMask(validatorIndex);\n    }\n\n    /// @notice check if the sender is a validator\n    /// @param ds pointer to diamond storage\n    /// @param sender sender address\n    function isValidator(DiamondStorage storage ds, address sender)\n        internal\n        view\n        returns (bool)\n    {\n        require(sender != address(0), \"address 0\");\n\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (sender == ds.validators[i]) return true;\n        }\n\n        return false;\n    }\n\n    /// @notice find the validator and return the index or revert\n    /// @param ds pointer to diamond storage\n    /// @param sender validator address\n    /// @return validator index or revert\n    function getValidatorIndex(DiamondStorage storage ds, address sender)\n        internal\n        view\n        returns (uint256)\n    {\n        require(sender != address(0), \"address 0\");\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (sender == ds.validators[i]) return i;\n        }\n        revert(\"validator not found\");\n    }\n\n    /// @notice get number of claims the sender has made\n    /// @param ds pointer to diamond storage\n    /// @param _sender validator address\n    /// @return #claims\n    function getNumberOfClaimsByAddress(\n        DiamondStorage storage ds,\n        address payable _sender\n    ) internal view returns (uint256) {\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (_sender == ds.validators[i]) {\n                return getNumberOfClaimsByIndex(ds, i);\n            }\n        }\n        // if validator not found\n        return 0;\n    }\n\n    /// @notice get number of claims by the index in the validator set\n    /// @param ds pointer to diamond storage\n    /// @param index the index in validator set\n    /// @return #claims\n    function getNumberOfClaimsByIndex(DiamondStorage storage ds, uint256 index)\n        internal\n        view\n        returns (uint256)\n    {\n        return ds.claimsMask.getNumClaims(index);\n    }\n\n    /// @notice get the maximum number of validators defined in validator manager\n    /// @param ds pointer to diamond storage\n    /// @return the maximum number of validators\n    function getMaxNumValidators(DiamondStorage storage ds)\n        internal\n        view\n        returns (uint256)\n    {\n        return ds.maxNumValidators;\n    }\n}\n"
    },
    "contracts/libraries/LibDisputeManager.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Dispute Manager library\npragma solidity ^0.8.0;\n\nimport {LibRollups} from \"../libraries/LibRollups.sol\";\n\nlibrary LibDisputeManager {\n    using LibRollups for LibRollups.DiamondStorage;\n\n    /// @notice initiates a dispute betweent two players\n    /// @param claims conflicting claims\n    /// @param claimers addresses of senders of conflicting claim\n    /// @dev this is a mock implementation that just gives the win\n    ///      to the address in the first posititon of claimers array\n    function initiateDispute(\n        bytes32[2] memory claims,\n        address payable[2] memory claimers\n    ) internal {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        rollupsDS.resolveDispute(claimers[0], claimers[1], claims[0]);\n    }\n}\n"
    },
    "contracts/libraries/LibClaimsMask.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title ClaimsMask library\npragma solidity >=0.8.8;\n\n// ClaimsMask is used to keep track of the number of claims for up to 8 validators\n// | agreement mask | consensus goal mask | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\n// |     8 bits     |        8 bits       |      30 bits       |      30 bits       | ... |      30 bits       |\n// In Validator Manager, #claims_validator indicates the #claims the validator has made.\n// In Fee Manager, #claims_validator indicates the #claims the validator has redeemed. In this case,\n//      agreement mask and consensus goal mask are not used.\n\ntype ClaimsMask is uint256;\n\nlibrary LibClaimsMask {\n    uint256 constant claimsBitLen = 30; // #bits used for each #claims\n\n    /// @notice this function creates a new ClaimsMask variable with value _value\n    /// @param  _value the value following the format of ClaimsMask\n    function newClaimsMask(uint256 _value) internal pure returns (ClaimsMask) {\n        return ClaimsMask.wrap(_value);\n    }\n\n    /// @notice this function creates a new ClaimsMask variable with the consensus goal mask set,\n    ///         according to the number of validators\n    /// @param  _numValidators the number of validators\n    function newClaimsMaskWithConsensusGoalSet(uint256 _numValidators)\n        internal\n        pure\n        returns (ClaimsMask)\n    {\n        require(_numValidators <= 8, \"up to 8 validators\");\n        uint256 consensusMask = (1 << _numValidators) - 1;\n        return ClaimsMask.wrap(consensusMask << 240); // 256 - 8 - 8 = 240\n    }\n\n    /// @notice this function returns the #claims for the specified validator\n    /// @param  _claimsMask the ClaimsMask value\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\n    ///     this index can be obtained though `getNumberOfClaimsByIndex` function in Validator Manager\n    function getNumClaims(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(_validatorIndex < 8, \"index out of range\");\n        uint256 bitmask = (1 << claimsBitLen) - 1;\n        return\n            (ClaimsMask.unwrap(_claimsMask) >>\n                (claimsBitLen * _validatorIndex)) & bitmask;\n    }\n\n    /// @notice this function increases the #claims for the specified validator\n    /// @param  _claimsMask the ClaimsMask value\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\n    /// @param  _value the increase amount\n    function increaseNumClaims(\n        ClaimsMask _claimsMask,\n        uint256 _validatorIndex,\n        uint256 _value\n    ) internal pure returns (ClaimsMask) {\n        require(_validatorIndex < 8, \"index out of range\");\n        uint256 currentNum = getNumClaims(_claimsMask, _validatorIndex);\n        uint256 newNum = currentNum + _value; // overflows checked by default with sol0.8\n        return setNumClaims(_claimsMask, _validatorIndex, newNum);\n    }\n\n    /// @notice this function sets the #claims for the specified validator\n    /// @param  _claimsMask the ClaimsMask value\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\n    /// @param  _value the set value\n    function setNumClaims(\n        ClaimsMask _claimsMask,\n        uint256 _validatorIndex,\n        uint256 _value\n    ) internal pure returns (ClaimsMask) {\n        require(_validatorIndex < 8, \"index out of range\");\n        require(_value <= ((1 << claimsBitLen) - 1), \"ClaimsMask Overflow\");\n        uint256 bitmask = ~(((1 << claimsBitLen) - 1) <<\n            (claimsBitLen * _validatorIndex));\n        uint256 clearedClaimsMask = ClaimsMask.unwrap(_claimsMask) & bitmask;\n        _claimsMask = ClaimsMask.wrap(\n            clearedClaimsMask | (_value << (claimsBitLen * _validatorIndex))\n        );\n        return _claimsMask;\n    }\n\n    /// @notice get consensus goal mask\n    /// @param  _claimsMask the ClaimsMask value\n    function clearAgreementMask(ClaimsMask _claimsMask)\n        internal\n        pure\n        returns (ClaimsMask)\n    {\n        uint256 clearedMask = ClaimsMask.unwrap(_claimsMask) & ((1 << 248) - 1); // 256 - 8 = 248\n        return ClaimsMask.wrap(clearedMask);\n    }\n\n    /// @notice get the entire agreement mask\n    /// @param  _claimsMask the ClaimsMask value\n    function getAgreementMask(ClaimsMask _claimsMask)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (ClaimsMask.unwrap(_claimsMask) >> 248); // get the first 8 bits\n    }\n\n    /// @notice check if a validator has already claimed\n    /// @param  _claimsMask the ClaimsMask value\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\n    function alreadyClaimed(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        internal\n        pure\n        returns (bool)\n    {\n        // get the first 8 bits. Then & operation on the validator's bit to see if it's set\n        return\n            (((ClaimsMask.unwrap(_claimsMask) >> 248) >> _validatorIndex) &\n                1) != 0;\n    }\n\n    /// @notice set agreement mask for the specified validator\n    /// @param  _claimsMask the ClaimsMask value\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\n    function setAgreementMask(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        internal\n        pure\n        returns (ClaimsMask)\n    {\n        require(_validatorIndex < 8, \"index out of range\");\n        uint256 setMask = (ClaimsMask.unwrap(_claimsMask) |\n            (1 << (248 + _validatorIndex))); // 256 - 8 = 248\n        return ClaimsMask.wrap(setMask);\n    }\n\n    /// @notice get the entire consensus goal mask\n    /// @param  _claimsMask the ClaimsMask value\n    function getConsensusGoalMask(ClaimsMask _claimsMask)\n        internal\n        pure\n        returns (uint256)\n    {\n        return ((ClaimsMask.unwrap(_claimsMask) << 8) >> 248); // get the second 8 bits\n    }\n\n    /// @notice remove validator from the ClaimsMask\n    /// @param  _claimsMask the ClaimsMask value\n    /// @param  _validatorIndex index of the validator in the validator array, starting from 0\n    function removeValidator(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        internal\n        pure\n        returns (ClaimsMask)\n    {\n        require(_validatorIndex < 8, \"index out of range\");\n        uint256 claimsMaskValue = ClaimsMask.unwrap(_claimsMask);\n        // remove validator from agreement bitmask\n        uint256 zeroMask = ~(1 << (_validatorIndex + 248)); // 256 - 8 = 248\n        claimsMaskValue = (claimsMaskValue & zeroMask);\n        // remove validator from consensus goal mask\n        zeroMask = ~(1 << (_validatorIndex + 240)); // 256 - 8 - 8 = 240\n        claimsMaskValue = (claimsMaskValue & zeroMask);\n        // remove validator from #claims\n        return\n            setNumClaims(ClaimsMask.wrap(claimsMaskValue), _validatorIndex, 0);\n    }\n}\n"
    },
    "contracts/libraries/LibFeeManager.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Fee Manager library\npragma solidity ^0.8.0;\n\nimport {LibValidatorManager} from \"../libraries/LibValidatorManager.sol\";\nimport {LibClaimsMask, ClaimsMask} from \"../libraries/LibClaimsMask.sol\";\nimport {IBank} from \"../IBank.sol\";\n\nlibrary LibFeeManager {\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\n    using LibFeeManager for LibFeeManager.DiamondStorage;\n    using LibClaimsMask for ClaimsMask;\n\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"FeeManager.diamond.storage\");\n\n    struct DiamondStorage {\n        address owner; // owner of Fee Manager\n        uint256 feePerClaim;\n        IBank bank; // bank that holds the tokens to pay validators\n        bool lock; // reentrancy lock\n        // A bit set used for up to 8 validators.\n        // The first 16 bits are not used to keep compatibility with the validator manager contract.\n        // The following every 30 bits are used to indicate the number of total claims each validator has made\n        // |     not used    | #claims_validator7 | #claims_validator6 | ... | #claims_validator0 |\n        // |     16 bits     |      30 bits       |      30 bits       | ... |      30 bits       |\n        ClaimsMask numClaimsRedeemed;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function onlyOwner(DiamondStorage storage ds) internal view {\n        require(ds.owner == msg.sender, \"caller is not the owner\");\n    }\n\n    /// @notice this function can be called to check the number of claims that's redeemable for the validator\n    /// @param  ds pointer to FeeManager's diamond storage\n    /// @param  _validator address of the validator\n    function numClaimsRedeemable(DiamondStorage storage ds, address _validator)\n        internal\n        view\n        returns (uint256)\n    {\n        require(_validator != address(0), \"address should not be 0\");\n\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\n        uint256 totalClaims = validatorManagerDS.claimsMask.getNumClaims(\n            valIndex\n        );\n        uint256 redeemedClaims = ds.numClaimsRedeemed.getNumClaims(valIndex);\n\n        // underflow checked by default with sol0.8\n        // which means if the validator is removed, calling this function will\n        // either return 0 or revert\n        return totalClaims - redeemedClaims;\n    }\n\n    /// @notice this function can be called to check the number of claims that has been redeemed for the validator\n    /// @param  ds pointer to FeeManager's diamond storage\n    /// @param  _validator address of the validator\n    function getNumClaimsRedeemed(DiamondStorage storage ds, address _validator)\n        internal\n        view\n        returns (uint256)\n    {\n        require(_validator != address(0), \"address should not be 0\");\n\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\n        uint256 redeemedClaims = ds.numClaimsRedeemed.getNumClaims(valIndex);\n\n        return redeemedClaims;\n    }\n\n    /// @notice contract owner can reset the value of fee per claim\n    /// @param  ds pointer to FeeManager's diamond storage\n    /// @param  _value the new value of fee per claim\n    function resetFeePerClaim(DiamondStorage storage ds, uint256 _value)\n        internal\n    {\n        // before resetting the feePerClaim, pay fees for all validators as per current rates\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        for (\n            uint256 valIndex;\n            valIndex < validatorManagerDS.maxNumValidators;\n            valIndex++\n        ) {\n            address validator = validatorManagerDS.validators[valIndex];\n            if (validator != address(0)) {\n                uint256 nowRedeemingClaims = ds.numClaimsRedeemable(validator);\n                if (nowRedeemingClaims > 0) {\n                    ds.numClaimsRedeemed = ds\n                        .numClaimsRedeemed\n                        .increaseNumClaims(valIndex, nowRedeemingClaims);\n\n                    uint256 feesToSend = nowRedeemingClaims * ds.feePerClaim; // number of erc20 tokens to send\n                    ds.bank.transferTokens(validator, feesToSend); // will revert if transfer fails\n                    // emit the number of claimed being redeemed, instead of the amount of tokens\n                    emit FeeRedeemed(validator, nowRedeemingClaims);\n                }\n            }\n        }\n        ds.feePerClaim = _value;\n        emit FeePerClaimReset(_value);\n    }\n\n    /// @notice this function can be called to redeem fees for validators\n    /// @param  ds pointer to FeeManager's diamond storage\n    /// @param  _validator address of the validator that is redeeming\n    function redeemFee(DiamondStorage storage ds, address _validator) internal {\n        // follow the Checks-Effects-Interactions pattern for security\n\n        // ** checks **\n        uint256 nowRedeemingClaims = ds.numClaimsRedeemable(_validator);\n        require(nowRedeemingClaims > 0, \"nothing to redeem yet\");\n\n        // ** effects **\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        uint256 valIndex = validatorManagerDS.getValidatorIndex(_validator); // will revert if not found\n        ds.numClaimsRedeemed = ds.numClaimsRedeemed.increaseNumClaims(\n            valIndex,\n            nowRedeemingClaims\n        );\n\n        // ** interactions **\n        uint256 feesToSend = nowRedeemingClaims * ds.feePerClaim; // number of erc20 tokens to send\n        ds.bank.transferTokens(_validator, feesToSend); // will revert if transfer fails\n        // emit the number of claimed being redeemed, instead of the amount of tokens\n        emit FeeRedeemed(_validator, nowRedeemingClaims);\n    }\n\n    /// @notice removes a validator\n    /// @param ds diamond storage pointer\n    /// @param index index of validator to be removed\n    function removeValidator(DiamondStorage storage ds, uint256 index)\n        internal\n    {\n        ds.numClaimsRedeemed = ds.numClaimsRedeemed.setNumClaims(index, 0);\n    }\n\n    /// @notice emitted on resetting feePerClaim\n    event FeePerClaimReset(uint256 value);\n\n    /// @notice emitted on ERC20 funds redeemed by validator\n    event FeeRedeemed(address validator, uint256 claims);\n}\n"
    },
    "contracts/facets/RollupsFacet.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Rollups facet\npragma solidity ^0.8.0;\n\nimport {IRollups, Phase} from \"../interfaces/IRollups.sol\";\nimport {Result} from \"../interfaces/IValidatorManager.sol\";\n\nimport {LibRollups} from \"../libraries/LibRollups.sol\";\nimport {LibInput} from \"../libraries/LibInput.sol\";\nimport {LibOutput} from \"../libraries/LibOutput.sol\";\nimport {LibValidatorManager} from \"../libraries/LibValidatorManager.sol\";\n\ncontract RollupsFacet is IRollups {\n    ////\n    //                             All claims agreed OR challenge period ended\n    //                              functions: claim() or finalizeEpoch()\n    //                        +--------------------------------------------------+\n    //                        |                                                  |\n    //               +--------v-----------+   new input after IPAD     +---------+----------+\n    //               |                    +--------------------------->+                    |\n    //   START  ---> | Input Accumulation |   firt claim after IPAD    | Awaiting Consensus |\n    //               |                    +--------------------------->+                    |\n    //               +-+------------------+                            +-----------------+--+\n    //                 ^                                                                 ^  |\n    //                 |                                              dispute resolved   |  |\n    //                 |  dispute resolved                            before challenge   |  |\n    //                 |  after challenge     +--------------------+  period ended       |  |\n    //                 |  period ended        |                    +---------------------+  |\n    //                 +----------------------+  Awaiting Dispute  |                        |\n    //                                        |                    +<-----------------------+\n    //                                        +--------------------+    conflicting claim\n    ///\n\n    using LibRollups for LibRollups.DiamondStorage;\n    using LibInput for LibInput.DiamondStorage;\n    using LibOutput for LibOutput.DiamondStorage;\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\n\n    /// @notice claim the result of current epoch\n    /// @param _epochHash hash of epoch\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\n    ///      and that claim != bytes32(0)\n    /// TODO: add signatures for aggregated claims\n    function claim(bytes32 _epochHash) public override {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n\n        Result result;\n        bytes32[2] memory claims;\n        address payable[2] memory claimers;\n\n        Phase currentPhase = Phase(rollupsDS.currentPhase_int);\n        uint256 inputAccumulationStart = rollupsDS.inputAccumulationStart;\n        uint256 inputDuration = rollupsDS.inputDuration;\n\n        if (\n            currentPhase == Phase.InputAccumulation &&\n            block.timestamp > inputAccumulationStart + inputDuration\n        ) {\n            currentPhase = Phase.AwaitingConsensus;\n            rollupsDS.currentPhase_int = uint32(Phase.AwaitingConsensus);\n            emit PhaseChange(Phase.AwaitingConsensus);\n\n            // warns input of new epoch\n            inputDS.onNewInputAccumulation();\n            // update timestamp of sealing epoch proposal\n            rollupsDS.sealingEpochTimestamp = uint32(block.timestamp);\n        }\n\n        require(\n            currentPhase == Phase.AwaitingConsensus,\n            \"Phase != AwaitingConsensus\"\n        );\n        (result, claims, claimers) = validatorManagerDS.onClaim(\n            payable(msg.sender),\n            _epochHash\n        );\n\n        // emit the claim event before processing it\n        // so if the epoch is finalized in this claim (consensus)\n        // the number of final epochs doesnt gets contaminated\n        emit Claim(\n            outputDS.getNumberOfFinalizedEpochs(),\n            msg.sender,\n            _epochHash\n        );\n\n        rollupsDS.resolveValidatorResult(result, claims, claimers);\n    }\n\n    /// @notice finalize epoch after timeout\n    /// @dev can only be called if challenge period is over\n    function finalizeEpoch() public override {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n\n        Phase currentPhase = Phase(rollupsDS.currentPhase_int);\n        require(\n            currentPhase == Phase.AwaitingConsensus,\n            \"Phase != Awaiting Consensus\"\n        );\n\n        uint256 sealingEpochTimestamp = rollupsDS.sealingEpochTimestamp;\n        uint256 challengePeriod = rollupsDS.challengePeriod;\n        require(\n            block.timestamp > sealingEpochTimestamp + challengePeriod,\n            \"Challenge period not over\"\n        );\n\n        require(\n            validatorManagerDS.currentClaim != bytes32(0),\n            \"No Claim to be finalized\"\n        );\n\n        rollupsDS.startNewEpoch();\n    }\n\n    /// @notice returns index of current (accumulating) epoch\n    /// @return index of current epoch\n    /// @dev if phase is input accumulation, then the epoch number is length\n    ///      of finalized epochs array, else there are two non finalized epochs,\n    ///      one awaiting consensus/dispute and another accumulating input\n    function getCurrentEpoch() public view override returns (uint256) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        return rollupsDS.getCurrentEpoch();\n    }\n\n    /// @notice returns the current phase\n    function getCurrentPhase() public view returns (Phase) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        return Phase(rollupsDS.currentPhase_int);\n    }\n\n    /// @notice returns the input accumulation start timestamp\n    function getInputAccumulationStart() public view returns (uint256) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        return uint256(rollupsDS.inputAccumulationStart);\n    }\n\n    /// @notice returns the sealing epoch timestamp\n    function getSealingEpochTimestamp() public view returns (uint256) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        return uint256(rollupsDS.sealingEpochTimestamp);\n    }\n\n    /// @notice returns the input duration in seconds\n    function getInputDuration() public view returns (uint256) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        return uint256(rollupsDS.inputDuration);\n    }\n\n    /// @notice returns the challenge period in seconds\n    function getChallengePeriod() public view returns (uint256) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        return uint256(rollupsDS.challengePeriod);\n    }\n\n    /// @notice returns the machine's template hash\n    function getTemplateHash() public view returns (bytes32) {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        return rollupsDS.templateHash;\n    }\n}\n"
    },
    "contracts/facets/ValidatorManagerFacet.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Validator Manager facet\npragma solidity ^0.8.0;\n\nimport {IValidatorManager} from \"../interfaces/IValidatorManager.sol\";\n\nimport {LibValidatorManager} from \"../libraries/LibValidatorManager.sol\";\n\nimport {LibClaimsMask, ClaimsMask} from \"../libraries/LibClaimsMask.sol\";\n\ncontract ValidatorManagerFacet is IValidatorManager {\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\n    using LibClaimsMask for ClaimsMask;\n\n    /// @notice get agreement mask\n    /// @return current state of agreement mask\n    function getAgreementMask() public view returns (uint256) {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.claimsMask.getAgreementMask();\n    }\n\n    /// @notice get consensus goal mask\n    /// @return current consensus goal mask\n    function getConsensusGoalMask() public view returns (uint256) {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.claimsMask.getConsensusGoalMask();\n    }\n\n    /// @notice get current claim\n    /// @return current claim\n    function getCurrentClaim() public view override returns (bytes32) {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.currentClaim;\n    }\n\n    /// @notice get number of claims the sender has made\n    /// @param _sender validator address\n    /// @return #claims\n    function getNumberOfClaimsByAddress(address payable _sender)\n        public\n        view\n        returns (uint256)\n    {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.getNumberOfClaimsByAddress(_sender);\n    }\n\n    /// @notice find the validator and return the index or revert\n    /// @param _sender validator address\n    /// @return validator index or revert\n    function getValidatorIndex(address _sender) public view returns (uint256) {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.getValidatorIndex(_sender);\n    }\n\n    /// @notice get number of claims by the index in the validator set\n    /// @param _index the index in validator set\n    /// @return #claims\n    function getNumberOfClaimsByIndex(uint256 _index)\n        public\n        view\n        returns (uint256)\n    {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.getNumberOfClaimsByIndex(_index);\n    }\n\n    /// @notice get the maximum number of validators defined in validator manager\n    /// @return the maximum number of validators\n    function getMaxNumValidators() public view returns (uint256) {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.getMaxNumValidators();\n    }\n}\n"
    },
    "contracts/test_helper/TestLibClaimsMask.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Test ClaimsMask library\npragma solidity >=0.8.8;\n\nimport \"../libraries/LibClaimsMask.sol\";\n\ncontract TestLibClaimsMask {\n    function newClaimsMask(uint256 _value) public pure returns (ClaimsMask) {\n        return LibClaimsMask.newClaimsMask(_value);\n    }\n\n    function newClaimsMaskWithConsensusGoalSet(uint256 _numValidators)\n        public\n        pure\n        returns (ClaimsMask)\n    {\n        return LibClaimsMask.newClaimsMaskWithConsensusGoalSet(_numValidators);\n    }\n\n    function getNumClaims(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        public\n        pure\n        returns (uint256)\n    {\n        return LibClaimsMask.getNumClaims(_claimsMask, _validatorIndex);\n    }\n\n    function increaseNumClaims(\n        ClaimsMask _claimsMask,\n        uint256 _validatorIndex,\n        uint256 _value\n    ) public pure returns (ClaimsMask) {\n        return\n            LibClaimsMask.increaseNumClaims(\n                _claimsMask,\n                _validatorIndex,\n                _value\n            );\n    }\n\n    function setNumClaims(\n        ClaimsMask _claimsMask,\n        uint256 _validatorIndex,\n        uint256 _value\n    ) public pure returns (ClaimsMask) {\n        return LibClaimsMask.setNumClaims(_claimsMask, _validatorIndex, _value);\n    }\n\n    function clearAgreementMask(ClaimsMask _claimsMask)\n        public\n        pure\n        returns (ClaimsMask)\n    {\n        return LibClaimsMask.clearAgreementMask(_claimsMask);\n    }\n\n    function getAgreementMask(ClaimsMask _claimsMask)\n        public\n        pure\n        returns (uint256)\n    {\n        return LibClaimsMask.getAgreementMask(_claimsMask);\n    }\n\n    function alreadyClaimed(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        public\n        pure\n        returns (bool)\n    {\n        return LibClaimsMask.alreadyClaimed(_claimsMask, _validatorIndex);\n    }\n\n    function setAgreementMask(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        public\n        pure\n        returns (ClaimsMask)\n    {\n        return LibClaimsMask.setAgreementMask(_claimsMask, _validatorIndex);\n    }\n\n    function getConsensusGoalMask(ClaimsMask _claimsMask)\n        public\n        pure\n        returns (uint256)\n    {\n        return LibClaimsMask.getConsensusGoalMask(_claimsMask);\n    }\n\n    function removeValidator(ClaimsMask _claimsMask, uint256 _validatorIndex)\n        public\n        pure\n        returns (ClaimsMask)\n    {\n        return LibClaimsMask.removeValidator(_claimsMask, _validatorIndex);\n    }\n}\n"
    },
    "contracts/facets/DebugFacet.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Debug facet\npragma solidity ^0.8.0;\n\nimport {Result} from \"../interfaces/IValidatorManager.sol\";\nimport {Phase} from \"../interfaces/IRollups.sol\";\nimport {IEtherPortal} from \"../interfaces/IEtherPortal.sol\";\nimport {IERC20Portal} from \"../interfaces/IERC20Portal.sol\";\nimport {IERC721Portal} from \"../interfaces/IERC721Portal.sol\";\n\nimport {LibRollups} from \"../libraries/LibRollups.sol\";\nimport {LibInput} from \"../libraries/LibInput.sol\";\nimport {LibOutput} from \"../libraries/LibOutput.sol\";\nimport {LibValidatorManager} from \"../libraries/LibValidatorManager.sol\";\nimport {LibFeeManager} from \"../libraries/LibFeeManager.sol\";\nimport {LibClaimsMask, ClaimsMask} from \"../libraries/LibClaimsMask.sol\";\n\ncontract DebugFacet {\n    using LibRollups for LibRollups.DiamondStorage;\n    using LibInput for LibInput.DiamondStorage;\n    using LibOutput for LibOutput.DiamondStorage;\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\n    using LibFeeManager for LibFeeManager.DiamondStorage;\n    using LibClaimsMask for ClaimsMask;\n\n    function _setCurrentPhase(Phase _phase) public {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n        rollupsDS.currentPhase_int = uint32(_phase);\n    }\n\n    function _getValidators() public view returns (address payable[] memory) {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.validators;\n    }\n\n    function _onClaim(address payable _sender, bytes32 _claim)\n        public\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.onClaim(_sender, _claim);\n    }\n\n    /// @notice called when a dispute ends in rollups\n    /// @param _winner address of dispute winner\n    /// @param _loser address of dispute loser\n    /// @param _winningClaim the winning claim\n    /// @return result of dispute being finished\n    function _onDisputeEnd(\n        address payable _winner,\n        address payable _loser,\n        bytes32 _winningClaim\n    )\n        public\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.onDisputeEnd(_winner, _loser, _winningClaim);\n    }\n\n    /// @notice called when a new epoch starts\n    /// @return current claim\n    function _onNewEpochVM() public returns (bytes32) {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        return validatorManagerDS.onNewEpoch();\n    }\n\n    function _getInputDriveSize() public view returns (uint256) {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        return inputDS.inputDriveSize;\n    }\n\n    function _etherWithdrawal(bytes calldata _data) public returns (bool) {\n        IEtherPortal etherPortal = IEtherPortal(address(this));\n        return etherPortal.etherWithdrawal(_data);\n    }\n\n    function _onNewEpochOutput(bytes32 epochHash) public {\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\n        outputDS.onNewEpoch(epochHash);\n    }\n\n    function _erc721Withdrawal(bytes calldata _data) public returns (bool) {\n        IERC721Portal erc721Portal = IERC721Portal(address(this));\n        return erc721Portal.erc721Withdrawal(_data);\n    }\n\n    function _getFeePerClaim() public view returns (uint256) {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        return feeManagerDS.feePerClaim;\n    }\n\n    function _setNumClaims(uint256 _validatorIndex, uint256 _value) public {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n        validatorManagerDS.claimsMask = validatorManagerDS\n            .claimsMask\n            .setNumClaims(_validatorIndex, _value);\n    }\n\n    function _getNumRedeems(uint256 _validatorIndex)\n        public\n        view\n        returns (uint256)\n    {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        return feeManagerDS.numClaimsRedeemed.getNumClaims(_validatorIndex);\n    }\n\n    /// @notice emitted on Claim received\n    event ClaimReceived(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on Dispute end\n    event DisputeEnded(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on new Epoch\n    event NewEpoch(bytes32 claim);\n}\n"
    },
    "contracts/interfaces/IEtherPortal.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Ether Portal interface\npragma solidity >=0.7.0;\n\ninterface IEtherPortal {\n    /// @notice deposit an amount of Ether in the portal and create Ether in L2\n    /// @param _data information to be interpreted by L2\n    /// @return hash of input generated by deposit\n    function etherDeposit(bytes calldata _data)\n        external\n        payable\n        returns (bytes32);\n\n    /// @notice withdraw an amount of Ether from the portal\n    /// @param _data data with withdrawal information\n    /// @dev can only be called by the Rollups contract\n    function etherWithdrawal(bytes calldata _data) external returns (bool);\n\n    /// @notice emitted on Ether deposited\n    event EtherDeposited(address sender, uint256 amount, bytes data);\n\n    /// @notice emitted on Ether withdrawal\n    event EtherWithdrawn(address payable receiver, uint256 amount);\n}\n"
    },
    "contracts/interfaces/IERC20Portal.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Generic ERC20 Portal interface\npragma solidity >=0.7.0;\n\ninterface IERC20Portal {\n    /// @notice deposit an amount of a generic ERC20 token in the portal and create tokens in L2\n    /// @param _ERC20 address of the ERC20 token contract\n    /// @param _amount amount of the ERC20 token to be deposited\n    /// @param _data information to be interpreted by L2\n    /// @return hash of input generated by deposit\n    function erc20Deposit(\n        address _ERC20,\n        uint256 _amount,\n        bytes calldata _data\n    ) external returns (bytes32);\n\n    /// @notice emitted on ERC20 deposited\n    event ERC20Deposited(\n        address ERC20,\n        address sender,\n        uint256 amount,\n        bytes data\n    );\n}\n"
    },
    "contracts/facets/OutputFacet.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Output facet\npragma solidity ^0.8.0;\n\nimport {Bitmask} from \"@cartesi/util/contracts/Bitmask.sol\";\nimport {Merkle} from \"@cartesi/util/contracts/Merkle.sol\";\n\nimport {IOutput, OutputValidityProof} from \"../interfaces/IOutput.sol\";\n\nimport {LibOutput} from \"../libraries/LibOutput.sol\";\nimport {LibFeeManager} from \"../libraries/LibFeeManager.sol\";\n\ncontract OutputFacet is IOutput {\n    using LibOutput for LibOutput.DiamondStorage;\n\n    // Here we only need 248 bits as keys in the mapping, but we use 256 bits for gas optimization\n    using Bitmask for mapping(uint256 => uint256);\n\n    uint256 constant KECCAK_LOG2_SIZE = 5; // keccak log2 size\n\n    // max size of voucher metadata memory range 32 * (2^16) bytes\n    uint256 constant VOUCHER_METADATA_LOG2_SIZE = 21;\n    // max size of epoch voucher memory range 32 * (2^32) bytes\n    uint256 constant EPOCH_VOUCHER_LOG2_SIZE = 37;\n\n    // max size of notice metadata memory range 32 * (2^16) bytes\n    uint256 constant NOTICE_METADATA_LOG2_SIZE = 21;\n    // max size of epoch notice memory range 32 * (2^32) bytes\n    uint256 constant EPOCH_NOTICE_LOG2_SIZE = 37;\n\n    /// @notice functions modified by noReentrancy are not subject to recursion\n    modifier noReentrancy() {\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\n\n        require(!outputDS.lock, \"reentrancy not allowed\");\n        outputDS.lock = true;\n        _;\n        outputDS.lock = false;\n    }\n\n    /// @notice executes voucher\n    /// @param _destination address that will execute the payload\n    /// @param _payload payload to be executed by destination\n    /// @param _v validity proof for this encoded voucher\n    /// @return true if voucher was executed successfully\n    /// @dev  vouchers can only be executed once\n    function executeVoucher(\n        address _destination,\n        bytes calldata _payload,\n        OutputValidityProof calldata _v\n    ) public override noReentrancy returns (bool) {\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n\n        // avoid a malicious DApp developer from draining the Fee Manager's bank account\n        require(_destination != address(feeManagerDS.bank), \"bad destination\");\n\n        bytes memory encodedVoucher = abi.encode(_destination, _payload);\n\n        // check if validity proof matches the voucher provided\n        isValidVoucherProof(\n            encodedVoucher,\n            outputDS.epochHashes[_v.epochIndex],\n            _v\n        );\n\n        uint256 voucherPosition = getBitMaskPosition(\n            _v.outputIndex,\n            _v.inputIndex,\n            _v.epochIndex\n        );\n\n        // check if voucher has been executed\n        require(\n            !outputDS.voucherBitmask.getBit(voucherPosition),\n            \"re-execution not allowed\"\n        );\n\n        // execute voucher\n        (bool succ, ) = _destination.call(_payload);\n\n        // if properly executed, mark it as executed and emit event\n        if (succ) {\n            outputDS.voucherBitmask.setBit(voucherPosition, true);\n            emit VoucherExecuted(voucherPosition);\n        }\n\n        return succ;\n    }\n\n    /// @notice isValidProof reverts if the proof is invalid\n    ///  @dev _outputsEpochRootHash must be _v.vouchersEpochRootHash or\n    ///                                  or _v.noticesEpochRootHash\n    function isValidProof(\n        bytes memory _encodedOutput,\n        bytes32 _epochHash,\n        bytes32 _outputsEpochRootHash,\n        uint256 _outputEpochLog2Size,\n        uint256 _outputHashesLog2Size,\n        OutputValidityProof calldata _v\n    ) internal pure {\n        // prove that outputs hash is represented in a finalized epoch\n        require(\n            keccak256(\n                abi.encodePacked(\n                    _v.vouchersEpochRootHash,\n                    _v.noticesEpochRootHash,\n                    _v.machineStateHash\n                )\n            ) == _epochHash,\n            \"epochHash incorrect\"\n        );\n\n        // prove that output metadata memory range is contained in epoch's output memory range\n        require(\n            Merkle.getRootAfterReplacementInDrive(\n                getIntraDrivePosition(_v.inputIndex, KECCAK_LOG2_SIZE),\n                KECCAK_LOG2_SIZE,\n                _outputEpochLog2Size,\n                keccak256(abi.encodePacked(_v.outputHashesRootHash)),\n                _v.outputHashesInEpochSiblings\n            ) == _outputsEpochRootHash,\n            \"outputsEpochRootHash incorrect\"\n        );\n\n        // The hash of the output is converted to bytes (abi.encode) and\n        // treated as data. The metadata output memory range stores that data while\n        // being indifferent to its contents. To prove that the received\n        // output is contained in the metadata output memory range we need to\n        // prove that x, where:\n        // x = keccak(\n        //          keccak(\n        //              keccak(hashOfOutput[0:7]),\n        //              keccak(hashOfOutput[8:15])\n        //          ),\n        //          keccak(\n        //              keccak(hashOfOutput[16:23]),\n        //              keccak(hashOfOutput[24:31])\n        //          )\n        //     )\n        // is contained in it. We can't simply use hashOfOutput because the\n        // log2size of the leaf is three (8 bytes) not  five (32 bytes)\n        bytes32 merkleRootOfHashOfOutput = Merkle.getMerkleRootFromBytes(\n            abi.encodePacked(keccak256(_encodedOutput)),\n            KECCAK_LOG2_SIZE\n        );\n\n        // prove that merkle root hash of bytes(hashOfOutput) is contained\n        // in the output metadata array memory range\n        require(\n            Merkle.getRootAfterReplacementInDrive(\n                getIntraDrivePosition(_v.outputIndex, KECCAK_LOG2_SIZE),\n                KECCAK_LOG2_SIZE,\n                _outputHashesLog2Size,\n                merkleRootOfHashOfOutput,\n                _v.keccakInHashesSiblings\n            ) == _v.outputHashesRootHash,\n            \"outputHashesRootHash incorrect\"\n        );\n    }\n\n    /// @notice isValidVoucherProof reverts if the proof is invalid\n    function isValidVoucherProof(\n        bytes memory _encodedVoucher,\n        bytes32 _epochHash,\n        OutputValidityProof calldata _v\n    ) public pure {\n        isValidProof(\n            _encodedVoucher,\n            _epochHash,\n            _v.vouchersEpochRootHash,\n            EPOCH_VOUCHER_LOG2_SIZE,\n            VOUCHER_METADATA_LOG2_SIZE,\n            _v\n        );\n    }\n\n    /// @notice isValidNoticeProof reverts if the proof is invalid\n    function isValidNoticeProof(\n        bytes memory _encodedNotice,\n        bytes32 _epochHash,\n        OutputValidityProof calldata _v\n    ) public pure {\n        isValidProof(\n            _encodedNotice,\n            _epochHash,\n            _v.noticesEpochRootHash,\n            EPOCH_NOTICE_LOG2_SIZE,\n            NOTICE_METADATA_LOG2_SIZE,\n            _v\n        );\n    }\n\n    /// @notice get voucher position on bitmask\n    /// @param _voucher of voucher inside the input\n    /// @param _input which input, inside the epoch, the voucher belongs to\n    /// @param _epoch which epoch the voucher belongs to\n    /// @return position of that voucher on bitmask\n    function getBitMaskPosition(\n        uint256 _voucher,\n        uint256 _input,\n        uint256 _epoch\n    ) public pure returns (uint256) {\n        // voucher * 2 ** 128 + input * 2 ** 64 + epoch\n        // this can't overflow because its impossible to have > 2**128 vouchers\n        return (((_voucher << 128) | (_input << 64)) | _epoch);\n    }\n\n    /// @notice returns the position of a intra memory range on a memory range\n    //          with  contents with the same size\n    /// @param _index index of intra memory range\n    /// @param _log2Size of intra memory range\n    function getIntraDrivePosition(uint256 _index, uint256 _log2Size)\n        public\n        pure\n        returns (uint256)\n    {\n        return (_index << _log2Size);\n    }\n\n    /// @notice get number of finalized epochs\n    function getNumberOfFinalizedEpochs()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        LibOutput.DiamondStorage storage outputDS = LibOutput.diamondStorage();\n        return outputDS.getNumberOfFinalizedEpochs();\n    }\n\n    /// @notice get log2 size of voucher metadata memory range\n    function getVoucherMetadataLog2Size()\n        public\n        pure\n        override\n        returns (uint256)\n    {\n        return VOUCHER_METADATA_LOG2_SIZE;\n    }\n\n    /// @notice get log2 size of epoch voucher memory range\n    function getEpochVoucherLog2Size() public pure override returns (uint256) {\n        return EPOCH_VOUCHER_LOG2_SIZE;\n    }\n\n    /// @notice get log2 size of notice metadata memory range\n    function getNoticeMetadataLog2Size()\n        public\n        pure\n        override\n        returns (uint256)\n    {\n        return NOTICE_METADATA_LOG2_SIZE;\n    }\n\n    /// @notice get log2 size of epoch notice memory range\n    function getEpochNoticeLog2Size() public pure override returns (uint256) {\n        return EPOCH_NOTICE_LOG2_SIZE;\n    }\n}\n"
    },
    "@cartesi/util/contracts/Bitmask.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\npragma solidity ^0.8.0;\n\n/// @title Bit Mask Library\n/// @author Stephen Chen\n/// @notice Implements bit mask with dynamic array\nlibrary Bitmask {\n    /// @notice Set a bit in the bit mask\n    function setBit(\n        mapping(uint256 => uint256) storage bitmask,\n        uint256 _bit,\n        bool _value\n    ) public {\n        // calculate the number of bits has been store in bitmask now\n        uint256 positionOfMask = uint256(_bit / 256);\n        uint256 positionOfBit = _bit % 256;\n\n        if (_value) {\n            bitmask[positionOfMask] =\n                bitmask[positionOfMask] |\n                (1 << positionOfBit);\n        } else {\n            bitmask[positionOfMask] =\n                bitmask[positionOfMask] &\n                ~(1 << positionOfBit);\n        }\n    }\n\n    /// @notice Get a bit in the bit mask\n    function getBit(mapping(uint256 => uint256) storage bitmask, uint256 _bit)\n        public\n        view\n        returns (bool)\n    {\n        // calculate the number of bits has been store in bitmask now\n        uint256 positionOfMask = uint256(_bit / 256);\n        uint256 positionOfBit = _bit % 256;\n\n        return ((bitmask[positionOfMask] & (1 << positionOfBit)) != 0);\n    }\n}\n"
    },
    "@cartesi/util/contracts/Merkle.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Library for Merkle proofs\npragma solidity ^0.8.0;\n\nimport \"./CartesiMath.sol\";\n\nlibrary Merkle {\n    using CartesiMath for uint256;\n\n    uint128 constant L_WORD_SIZE = 3; // word = 8 bytes, log = 3\n    // number of hashes in EMPTY_TREE_HASHES\n    uint128 constant EMPTY_TREE_SIZE = 1952; // 61*32=1952. 32 bytes per 61 indexes (64 words)\n\n    // merkle root hashes of trees of zero concatenated\n    // 32 bytes for each root, first one is keccak(0), second one is\n    // keccak(keccack(0), keccak(0)) and so on\n\n    bytes constant EMPTY_TREE_HASHES =\n        hex\"011b4d03dd8c01f1049143cf9c4c817e4b167f1d1b83e5c6f0f10d89ba1e7bce4d9470a821fbe90117ec357e30bad9305732fb19ddf54a07dd3e29f440619254ae39ce8537aca75e2eff3e38c98011dfe934e700a0967732fc07b430dd656a233fc9a15f5b4869c872f81087bb6104b7d63e6f9ab47f2c43f3535eae7172aa7f17d2dd614cddaa4d879276b11e0672c9560033d3e8453a1d045339d34ba601b9c37b8b13ca95166fb7af16988a70fcc90f38bf9126fd833da710a47fb37a55e68e7a427fa943d9966b389f4f257173676090c6e95f43e2cb6d65f8758111e30930b0b9deb73e155c59740bacf14a6ff04b64bb8e201a506409c3fe381ca4ea90cd5deac729d0fdaccc441d09d7325f41586ba13c801b7eccae0f95d8f3933efed8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e6163e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b72122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec517a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca892b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e152499af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8bf065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a233e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698caefdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d33abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf98dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f65d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f649929927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e6191b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c99876e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977ec61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f945ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f8647bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348cafff75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172dafa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e2496d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f6d1ab973982c7ccbe6c1fae02788e4422ae22282fa49cbdb04ba54a7a238c6fc41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683916ca832592485093644e8760cd7b4c01dba1ccc82b661bf13f0e3f34acd6b88\";\n\n    /// @notice Gets merkle root hash of drive with a replacement\n    /// @param _position position of _drive\n    /// @param _logSizeOfReplacement log2 of size the replacement\n    /// @param _logSizeOfFullDrive log2 of size the full drive, which can be the entire machine\n    /// @param _replacement hash of the replacement\n    /// @param siblings of replacement that merkle root can be calculated\n    function getRootAfterReplacementInDrive(\n        uint256 _position,\n        uint256 _logSizeOfReplacement,\n        uint256 _logSizeOfFullDrive,\n        bytes32 _replacement,\n        bytes32[] calldata siblings\n    ) public pure returns (bytes32) {\n        require(\n            _logSizeOfFullDrive >= _logSizeOfReplacement &&\n                _logSizeOfReplacement >= 3 &&\n                _logSizeOfFullDrive <= 64,\n            \"3 <= logSizeOfReplacement <= logSizeOfFullDrive <= 64\"\n        );\n\n        uint256 size = 1 << _logSizeOfReplacement;\n\n        require(((size - 1) & _position) == 0, \"Position is not aligned\");\n        require(\n            siblings.length == _logSizeOfFullDrive - _logSizeOfReplacement,\n            \"Proof length does not match\"\n        );\n\n        for (uint256 i; i < siblings.length; i++) {\n            if ((_position & (size << i)) == 0) {\n                _replacement = keccak256(\n                    abi.encodePacked(_replacement, siblings[i])\n                );\n            } else {\n                _replacement = keccak256(\n                    abi.encodePacked(siblings[i], _replacement)\n                );\n            }\n        }\n\n        return _replacement;\n    }\n\n    /// @notice Gets precomputed hash of zero in empty tree hashes\n    /// @param _index of hash wanted\n    /// @dev first index is keccak(0), second index is keccak(keccak(0), keccak(0))\n    function getEmptyTreeHashAtIndex(uint256 _index)\n        public\n        pure\n        returns (bytes32)\n    {\n        uint256 start = _index * 32;\n        require(EMPTY_TREE_SIZE >= start + 32, \"index out of bounds\");\n        bytes32 hashedZeros;\n        bytes memory zeroTree = EMPTY_TREE_HASHES;\n\n        // first word is length, then skip index words\n        assembly {\n            hashedZeros := mload(add(add(zeroTree, 0x20), start))\n        }\n        return hashedZeros;\n    }\n\n    /// @notice get merkle root of generic array of bytes\n    /// @param _data array of bytes to be merklelized\n    /// @param _log2Size log2 of total size of the drive\n    /// @dev _data is padded with zeroes until is multiple of 8\n    /// @dev root is completed with zero tree until log2size is complete\n    /// @dev hashes are taken word by word (8 bytes by 8 bytes)\n    function getMerkleRootFromBytes(bytes calldata _data, uint256 _log2Size)\n        public\n        pure\n        returns (bytes32)\n    {\n        require(_log2Size >= 3 && _log2Size <= 64, \"range of log2Size: [3,64]\");\n\n        // if _data is empty return pristine drive of size log2size\n        if (_data.length == 0) return getEmptyTreeHashAtIndex(_log2Size - 3);\n\n        // total size of the drive in words\n        uint256 size = 1 << (_log2Size - 3);\n        require(\n            size << L_WORD_SIZE >= _data.length,\n            \"data is bigger than drive\"\n        );\n        // the stack depth is log2(_data.length / 8) + 2\n        uint256 stack_depth = 2 +\n            ((_data.length) >> L_WORD_SIZE).getLog2Floor();\n        bytes32[] memory stack = new bytes32[](stack_depth);\n\n        uint256 numOfHashes; // total number of hashes on stack (counting levels)\n        uint256 stackLength; // total length of stack\n        uint256 numOfJoins; // number of hashes of the same level on stack\n        uint256 topStackLevel; // hash level of the top of the stack\n\n        while (numOfHashes < size) {\n            if ((numOfHashes << L_WORD_SIZE) < _data.length) {\n                // we still have words to hash\n                stack[stackLength] = getHashOfWordAtIndex(_data, numOfHashes);\n                numOfHashes++;\n\n                numOfJoins = numOfHashes;\n            } else {\n                // since padding happens in hashOfWordAtIndex function\n                // we only need to complete the stack with pre-computed\n                // hash(0), hash(hash(0),hash(0)) and so on\n                topStackLevel = numOfHashes.ctz();\n\n                stack[stackLength] = getEmptyTreeHashAtIndex(topStackLevel);\n\n                //Empty Tree Hash summarizes many hashes\n                numOfHashes = numOfHashes + (1 << topStackLevel);\n                numOfJoins = numOfHashes >> topStackLevel;\n            }\n\n            stackLength++;\n\n            // while there are joins, hash top of stack together\n            while (numOfJoins & 1 == 0) {\n                bytes32 h2 = stack[stackLength - 1];\n                bytes32 h1 = stack[stackLength - 2];\n\n                stack[stackLength - 2] = keccak256(abi.encodePacked(h1, h2));\n                stackLength = stackLength - 1; // remove hashes from stack\n\n                numOfJoins = numOfJoins >> 1;\n            }\n        }\n        require(stackLength == 1, \"stack error\");\n\n        return stack[0];\n    }\n\n    /// @notice Get the hash of a word in an array of bytes\n    /// @param _data array of bytes\n    /// @param _wordIndex index of word inside the bytes to get the hash of\n    /// @dev if word is incomplete (< 8 bytes) it gets padded with zeroes\n    function getHashOfWordAtIndex(bytes calldata _data, uint256 _wordIndex)\n        public\n        pure\n        returns (bytes32)\n    {\n        uint256 start = _wordIndex << L_WORD_SIZE;\n        uint256 end = start + (1 << L_WORD_SIZE);\n\n        // TODO: in .lua this just returns zero, but this might be more consistent\n        require(start <= _data.length, \"word out of bounds\");\n\n        if (end <= _data.length) {\n            return keccak256(abi.encodePacked(_data[start:end]));\n        }\n\n        // word is incomplete\n        // fill paddedSlice with incomplete words - the rest is going to be bytes(0)\n        bytes memory paddedSlice = new bytes(8);\n        uint256 remaining = _data.length - start;\n\n        for (uint256 i; i < remaining; i++) {\n            paddedSlice[i] = _data[start + i];\n        }\n\n        return keccak256(paddedSlice);\n    }\n\n    /// @notice Calculate the root of Merkle tree from an array of power of 2 elements\n    /// @param hashes The array containing power of 2 elements\n    /// @return byte32 the root hash being calculated\n    function calculateRootFromPowerOfTwo(bytes32[] memory hashes)\n        public\n        pure\n        returns (bytes32)\n    {\n        // revert when the input is not of power of 2\n        require((hashes.length).isPowerOf2(), \"array len not power of 2\");\n\n        if (hashes.length == 1) {\n            return hashes[0];\n        } else {\n            bytes32[] memory newHashes = new bytes32[](hashes.length >> 1);\n\n            for (uint256 i; i < hashes.length; i += 2) {\n                newHashes[i >> 1] = keccak256(\n                    abi.encodePacked(hashes[i], hashes[i + 1])\n                );\n            }\n\n            return calculateRootFromPowerOfTwo(newHashes);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOutput.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Output interface\npragma solidity >=0.7.0;\n\n/// @param epochIndex which epoch the output belongs to\n/// @param inputIndex which input, inside the epoch, the output belongs to\n/// @param outputIndex index of output inside the input\n/// @param outputHashesRootHash merkle root of all epoch's output metadata hashes\n/// @param vouchersEpochRootHash merkle root of all epoch's voucher metadata hashes\n/// @param noticesEpochRootHash merkle root of all epoch's notice metadata hashes\n/// @param machineStateHash hash of the machine state claimed this epoch\n/// @param keccakInHashesSiblings proof that this output metadata is in metadata memory range\n/// @param outputHashesInEpochSiblings proof that this output metadata is in epoch's output memory range\nstruct OutputValidityProof {\n    uint256 epochIndex;\n    uint256 inputIndex;\n    uint256 outputIndex;\n    bytes32 outputHashesRootHash;\n    bytes32 vouchersEpochRootHash;\n    bytes32 noticesEpochRootHash;\n    bytes32 machineStateHash;\n    bytes32[] keccakInHashesSiblings;\n    bytes32[] outputHashesInEpochSiblings;\n}\n\ninterface IOutput {\n    /// @notice executes voucher\n    /// @param _destination address that will execute the payload\n    /// @param _payload payload to be executed by destination\n    /// @param _v validity proof for this encoded voucher\n    /// @return true if voucher was executed successfully\n    /// @dev  vouchers can only be executed once\n    function executeVoucher(\n        address _destination,\n        bytes calldata _payload,\n        OutputValidityProof calldata _v\n    ) external returns (bool);\n\n    /// @notice get number of finalized epochs\n    function getNumberOfFinalizedEpochs() external view returns (uint256);\n\n    /// @notice get log2 size of voucher metadata memory range\n    function getVoucherMetadataLog2Size() external pure returns (uint256);\n\n    /// @notice get log2 size of epoch voucher memory range\n    function getEpochVoucherLog2Size() external pure returns (uint256);\n\n    /// @notice get log2 size of notice metadata memory range\n    function getNoticeMetadataLog2Size() external pure returns (uint256);\n\n    /// @notice get log2 size of epoch notice memory range\n    function getEpochNoticeLog2Size() external pure returns (uint256);\n\n    event VoucherExecuted(uint256 voucherPosition);\n}\n"
    },
    "@cartesi/util/contracts/CartesiMath.sol": {
      "content": "// Copyright 2020 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title CartesiMath\n/// @author Felipe Argento\npragma solidity ^0.8.0;\n\nlibrary CartesiMath {\n    // mapping values are packed as bytes3 each\n    // see test/TestCartesiMath.ts for decimal values\n    bytes constant log2tableTimes1M =\n        hex\"0000000F4240182F421E8480236E082771822AD63A2DC6C0305E8532B04834C96736B3C23876D73A187A3B9D4A3D09003E5EA63FA0C540D17741F28843057D440BA745062945F60246DC1047B917488DC7495ABA4A207C4ADF8A4B98544C4B404CF8AA4DA0E64E44434EE3054F7D6D5013B750A61A5134C851BFF05247BD52CC58534DE753CC8D54486954C19C55384255AC75561E50568DE956FB575766B057D00758376F589CFA5900BA5962BC59C3135A21CA5A7EF15ADA945B34BF5B8D805BE4DF5C3AEA5C8FA95CE3265D356C5D86835DD6735E25455E73005EBFAD5F0B525F55F75F9FA25FE85A60302460770860BD0A61023061467F6189FD61CCAE620E98624FBF62902762CFD5630ECD634D12638AA963C7966403DC643F7F647A8264B4E864EEB56527EC6560906598A365D029660724663D9766738566A8F066DDDA6712476746386779AF67ACAF67DF3A6811526842FA68743268A4FC68D55C6905536934E169640A6992CF69C13169EF326A1CD46A4A186A76FF6AA38C6ACFC0\";\n\n    /// @notice Approximates log2 * 1M\n    /// @param _num number to take log2 * 1M of\n    /// @return approximate log2 times 1M\n    function log2ApproxTimes1M(uint256 _num) public pure returns (uint256) {\n        require(_num > 0, \"Number cannot be zero\");\n        uint256 leading = 0;\n\n        if (_num == 1) return 0;\n\n        while (_num > 128) {\n            _num = _num >> 1;\n            leading += 1;\n        }\n        return (leading * uint256(1000000)) + (getLog2TableTimes1M(_num));\n    }\n\n    /// @notice navigates log2tableTimes1M\n    /// @param _num number to take log2 of\n    /// @return result after table look-up\n    function getLog2TableTimes1M(uint256 _num) public pure returns (uint256) {\n        bytes3 result = 0;\n        for (uint8 i = 0; i < 3; i++) {\n            bytes3 tempResult = log2tableTimes1M[(_num - 1) * 3 + i];\n            result = result | (tempResult >> (i * 8));\n        }\n\n        return uint256(uint24(result));\n    }\n\n    /// @notice get floor of log2 of number\n    /// @param _num number to take floor(log2) of\n    /// @return floor(log2) of _num\n   function getLog2Floor(uint256 _num) public pure returns (uint8) {\n       require(_num != 0, \"log of zero is undefined\");\n\n       return uint8(255 - clz(_num));\n    }\n\n    /// @notice checks if a number is Power of 2\n    /// @param _num number to check\n    /// @return true if number is power of 2, false if not\n    function isPowerOf2(uint256 _num) public pure returns (bool) {\n        if (_num == 0) return false;\n\n        return _num & (_num - 1) == 0;\n    }\n\n    /// @notice count trailing zeros\n    /// @param _num number you want the ctz of\n    /// @dev this a binary search implementation\n    function ctz(uint256 _num) public pure returns (uint256) {\n        if (_num == 0) return 256;\n\n        uint256 n = 0;\n        if (_num & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) { n = n + 128; _num = _num >> 128; }\n        if (_num & 0x000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF == 0) { n = n + 64; _num = _num >> 64; }\n        if (_num & 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF == 0) { n = n + 32; _num = _num >> 32; }\n        if (_num & 0x000000000000000000000000000000000000000000000000000000000000FFFF == 0) { n = n + 16; _num = _num >> 16; }\n        if (_num & 0x00000000000000000000000000000000000000000000000000000000000000FF == 0) { n = n +  8; _num = _num >>  8; }\n        if (_num & 0x000000000000000000000000000000000000000000000000000000000000000F == 0) { n = n +  4; _num = _num >>  4; }\n        if (_num & 0x0000000000000000000000000000000000000000000000000000000000000003 == 0) { n = n +  2; _num = _num >>  2; }\n        if (_num & 0x0000000000000000000000000000000000000000000000000000000000000001 == 0) { n = n +  1; }\n\n        return n;\n    }\n\n    /// @notice count leading zeros\n    /// @param _num number you want the clz of\n    /// @dev this a binary search implementation\n    function clz(uint256 _num) public pure returns (uint256) {\n        if (_num == 0) return 256;\n\n        uint256 n = 0;\n        if (_num & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000 == 0) { n = n + 128; _num = _num << 128; }\n        if (_num & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 == 0) { n = n + 64; _num = _num << 64; }\n        if (_num & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000 == 0) { n = n + 32; _num = _num << 32; }\n        if (_num & 0xFFFF000000000000000000000000000000000000000000000000000000000000 == 0) { n = n + 16; _num = _num << 16; }\n        if (_num & 0xFF00000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  8; _num = _num <<  8; }\n        if (_num & 0xF000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  4; _num = _num <<  4; }\n        if (_num & 0xC000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  2; _num = _num <<  2; }\n        if (_num & 0x8000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  1; }\n\n        return n;\n    }\n}\n"
    },
    "contracts/libraries/alternatives/LibValidatorManager1.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Validator Manager library (alternative version)\npragma solidity ^0.8.0;\n\nimport {Result} from \"../../interfaces/IValidatorManager.sol\";\n\n// TODO: this libray seems to be very unsafe, need to think about security implications\nlibrary LibValidatorManager1 {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"ValidatorManager.diamond.storage\");\n\n    struct DiamondStorage {\n        bytes32 currentClaim; // current claim - first claim of this epoch\n        address payable[] validators; // current validators\n        // A bit set for each validator that agrees with current claim,\n        // on their respective positions\n        uint32 claimAgreementMask;\n        // Every validator who should approve (in order to reach consensus) will have a one set on this mask\n        // This mask is updated if a validator is added or removed\n        uint32 consensusGoalMask;\n    }\n\n    /// @notice emitted on Claim received\n    event ClaimReceived(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on Dispute end\n    event DisputeEnded(\n        Result result,\n        bytes32[2] claims,\n        address payable[2] validators\n    );\n\n    /// @notice emitted on new Epoch\n    event NewEpoch(bytes32 claim);\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice called when a dispute ends in rollups\n    /// @param ds diamond storage pointer\n    /// @param winner address of dispute winner\n    /// @param loser address of dispute loser\n    /// @param winningClaim the winning claim\n    /// @return result of dispute being finished\n    function onDisputeEnd(\n        DiamondStorage storage ds,\n        address payable winner,\n        address payable loser,\n        bytes32 winningClaim\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        // remove validator also removes validator from both bitmask\n        removeFromValidatorSetAndBothBitmasks(ds, loser);\n\n        if (winningClaim == ds.currentClaim) {\n            // first claim stood, dont need to update the bitmask\n            return\n                isConsensus(ds.claimAgreementMask, ds.consensusGoalMask)\n                    ? emitDisputeEndedAndReturn(\n                        Result.Consensus,\n                        [winningClaim, bytes32(0)],\n                        [winner, payable(0)]\n                    )\n                    : emitDisputeEndedAndReturn(\n                        Result.NoConflict,\n                        [winningClaim, bytes32(0)],\n                        [winner, payable(0)]\n                    );\n        }\n\n        // if first claim lost, and other validators have agreed with it\n        // there is a new dispute to be played\n        if (ds.claimAgreementMask != 0) {\n            return\n                emitDisputeEndedAndReturn(\n                    Result.Conflict,\n                    [ds.currentClaim, winningClaim],\n                    [getClaimerOfCurrentClaim(ds), winner]\n                );\n        }\n        // else there are no valdiators that agree with losing claim\n        // we can update current claim and check for consensus in case\n        // the winner is the only validator left\n        ds.currentClaim = winningClaim;\n        ds.claimAgreementMask = updateClaimAgreementMask(ds, winner);\n        return\n            isConsensus(ds.claimAgreementMask, ds.consensusGoalMask)\n                ? emitDisputeEndedAndReturn(\n                    Result.Consensus,\n                    [winningClaim, bytes32(0)],\n                    [winner, payable(0)]\n                )\n                : emitDisputeEndedAndReturn(\n                    Result.NoConflict,\n                    [winningClaim, bytes32(0)],\n                    [winner, payable(0)]\n                );\n    }\n\n    /// @notice called when a new epoch starts\n    /// @param ds diamond storage pointer\n    /// @return current claim\n    function onNewEpoch(DiamondStorage storage ds) internal returns (bytes32) {\n        bytes32 tmpClaim = ds.currentClaim;\n\n        // clear current claim\n        ds.currentClaim = bytes32(0);\n        // clear validator agreement bit mask\n        ds.claimAgreementMask = 0;\n\n        emit NewEpoch(tmpClaim);\n        return tmpClaim;\n    }\n\n    /// @notice called when a claim is received by rollups\n    /// @param ds diamond storage pointer\n    /// @param sender address of sender of that claim\n    /// @param claim claim received by rollups\n    /// @return result of claim, Consensus | NoConflict | Conflict\n    /// @return [currentClaim, conflicting claim] if there is Conflict\n    ///         [currentClaim, bytes32(0)] if there is Consensus or NoConflcit\n    /// @return [claimer1, claimer2] if there is  Conflcit\n    ///         [claimer1, address(0)] if there is Consensus or NoConflcit\n    function onClaim(\n        DiamondStorage storage ds,\n        address payable sender,\n        bytes32 claim\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        require(claim != bytes32(0), \"empty claim\");\n        require(isValidator(ds, sender), \"sender not allowed\");\n\n        // cant return because a single claim might mean consensus\n        if (ds.currentClaim == bytes32(0)) {\n            ds.currentClaim = claim;\n        }\n\n        if (claim != ds.currentClaim) {\n            return\n                emitClaimReceivedAndReturn(\n                    Result.Conflict,\n                    [ds.currentClaim, claim],\n                    [getClaimerOfCurrentClaim(ds), sender]\n                );\n        }\n        ds.claimAgreementMask = updateClaimAgreementMask(ds, sender);\n\n        return\n            isConsensus(ds.claimAgreementMask, ds.consensusGoalMask)\n                ? emitClaimReceivedAndReturn(\n                    Result.Consensus,\n                    [claim, bytes32(0)],\n                    [sender, payable(0)]\n                )\n                : emitClaimReceivedAndReturn(\n                    Result.NoConflict,\n                    [claim, bytes32(0)],\n                    [sender, payable(0)]\n                );\n    }\n\n    /// @notice emits dispute ended event and then return\n    /// @param result to be emitted and returned\n    /// @param claims to be emitted and returned\n    /// @param validators to be emitted and returned\n    /// @dev this function existis to make code more clear/concise\n    function emitDisputeEndedAndReturn(\n        Result result,\n        bytes32[2] memory claims,\n        address payable[2] memory validators\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        emit DisputeEnded(result, claims, validators);\n        return (result, claims, validators);\n    }\n\n    /// @notice emits claim received event and then return\n    /// @param result to be emitted and returned\n    /// @param claims to be emitted and returned\n    /// @param validators to be emitted and returned\n    /// @dev this function existis to make code more clear/concise\n    function emitClaimReceivedAndReturn(\n        Result result,\n        bytes32[2] memory claims,\n        address payable[2] memory validators\n    )\n        internal\n        returns (\n            Result,\n            bytes32[2] memory,\n            address payable[2] memory\n        )\n    {\n        emit ClaimReceived(result, claims, validators);\n        return (result, claims, validators);\n    }\n\n    /// @notice get one of the validators that agreed with current claim\n    /// @param ds diamond storage pointer\n    /// @return validator that agreed with current claim\n    function getClaimerOfCurrentClaim(DiamondStorage storage ds)\n        internal\n        view\n        returns (address payable)\n    {\n        // TODO: we are always getting the first validator\n        // on the array that agrees with the current claim to enter a dispute\n        // should this be random?\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (ds.claimAgreementMask & (1 << i) != 0) {\n                return ds.validators[i];\n            }\n        }\n        revert(\"Agreeing validator not found\");\n    }\n\n    /// @notice updates the consensus goal mask\n    /// @param ds diamond storage pointer\n    /// @return new consensus goal mask\n    function updateConsensusGoalMask(DiamondStorage storage ds)\n        internal\n        view\n        returns (uint32)\n    {\n        // consensus goal is a number where\n        // all bits related to validators are turned on\n        uint256 consensusMask = (1 << ds.validators.length) - 1;\n        return uint32(consensusMask);\n    }\n\n    /// @notice updates mask of validators that agreed with current claim\n    /// @param ds diamond storage pointer\n    /// @param sender address that of validator that will be included in mask\n    /// @return new claim agreement mask\n    function updateClaimAgreementMask(\n        DiamondStorage storage ds,\n        address payable sender\n    ) internal view returns (uint32) {\n        uint256 tmpClaimAgreement = ds.claimAgreementMask;\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (sender == ds.validators[i]) {\n                tmpClaimAgreement = (tmpClaimAgreement | (1 << i));\n                break;\n            }\n        }\n\n        return uint32(tmpClaimAgreement);\n    }\n\n    /// @notice removes a validator\n    /// @param ds diamond storage pointer\n    /// @param validator address of validator to be removed\n    function removeFromValidatorSetAndBothBitmasks(\n        DiamondStorage storage ds,\n        address validator\n    ) internal {\n        // put address(0) in validators position\n        // removes validator from claim agreement bitmask\n        // removes validator from consensus goal mask\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (validator == ds.validators[i]) {\n                ds.validators[i] = payable(0);\n                uint32 zeroMask = ~(uint32(1) << uint32(i));\n                ds.claimAgreementMask = ds.claimAgreementMask & zeroMask;\n                ds.consensusGoalMask = ds.consensusGoalMask & zeroMask;\n                break;\n            }\n        }\n    }\n\n    function isValidator(DiamondStorage storage ds, address sender)\n        internal\n        view\n        returns (bool)\n    {\n        for (uint256 i; i < ds.validators.length; i++) {\n            if (sender == ds.validators[i]) return true;\n        }\n\n        return false;\n    }\n\n    function isConsensus(uint256 claimAgreementMask, uint256 consensusGoalMask)\n        internal\n        pure\n        returns (bool)\n    {\n        return claimAgreementMask == consensusGoalMask;\n    }\n}\n"
    },
    "contracts/facets/alternatives/ValidatorManagerFacet1.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Validator Manager facet (alternative version)\npragma solidity ^0.8.0;\n\nimport {IValidatorManager} from \"../../interfaces/IValidatorManager.sol\";\n\nimport {LibValidatorManager1} from \"../../libraries/alternatives/LibValidatorManager1.sol\";\n\ncontract ValidatorManagerFacet1 is IValidatorManager {\n    /// @notice get agreement mask\n    /// @return current state of agreement mask\n    function getCurrentAgreementMask() public view returns (uint32) {\n        LibValidatorManager1.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager1.diamondStorage();\n        return validatorManagerDS.claimAgreementMask;\n    }\n\n    /// @notice get consensus goal mask\n    /// @return current consensus goal mask\n    function getConsensusGoalMask() public view returns (uint32) {\n        LibValidatorManager1.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager1.diamondStorage();\n        return validatorManagerDS.consensusGoalMask;\n    }\n\n    /// @notice get current claim\n    /// @return current claim\n    function getCurrentClaim() public view override returns (bytes32) {\n        LibValidatorManager1.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager1.diamondStorage();\n        return validatorManagerDS.currentClaim;\n    }\n}\n"
    },
    "contracts/upgrade_initializers/DiamondInit.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// @title Diamond Initialization Contract\npragma solidity ^0.8.0;\n\n// Rollups-related dependencies\nimport {Phase} from \"../interfaces/IRollups.sol\";\nimport {LibRollups} from \"../libraries/LibRollups.sol\";\nimport {LibInput} from \"../libraries/LibInput.sol\";\nimport {LibValidatorManager} from \"../libraries/LibValidatorManager.sol\";\nimport {LibClaimsMask} from \"../libraries/LibClaimsMask.sol\";\nimport {LibFeeManager} from \"../libraries/LibFeeManager.sol\";\nimport {IBank} from \"../IBank.sol\";\n\n// Diamond-related dependencies\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\"; // not in openzeppelin-contracts yet\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/// @notice diamond configurations\n/// @param templateHash state hash of the cartesi machine at t0\n/// @param inputDuration duration of input accumulation phase in seconds\n/// @param challengePeriod duration of challenge period in seconds\n/// @param inputLog2Size size of the input memory range in this machine\n/// @param feePerClaim fee per claim to reward the validators\n/// @param feeManagerBank fee manager bank address\n/// @param feeManagerOwner fee manager owner address\n/// @param validators initial validator set\n/// @dev validators have to be unique, if the same validator is added twice\n///      consensus will never be reached\nstruct DiamondConfig {\n    // RollupsFacet\n    bytes32 templateHash;\n    uint256 inputDuration;\n    uint256 challengePeriod;\n    // InputFacet\n    uint256 inputLog2Size;\n    // FeeManagerFacet\n    uint256 feePerClaim;\n    address feeManagerBank;\n    address feeManagerOwner;\n    // ValidatorManagerFacet\n    address payable[] validators;\n}\n\ncontract DiamondInit {\n    using LibValidatorManager for LibValidatorManager.DiamondStorage;\n    using LibInput for LibInput.DiamondStorage;\n\n    /// @notice initialize the diamond\n    /// @param _dConfig diamond configurations\n    function init(DiamondConfig calldata _dConfig) external {\n        initERC165();\n        initValidatorManager(_dConfig.validators);\n        initRollups(\n            _dConfig.templateHash,\n            _dConfig.inputDuration,\n            _dConfig.challengePeriod\n        );\n        initFeeManager(\n            _dConfig.feePerClaim,\n            _dConfig.feeManagerBank,\n            _dConfig.feeManagerOwner\n        );\n        initInput(_dConfig.inputLog2Size);\n    }\n\n    /// @notice initialize ERC165 data\n    function initERC165() private {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    }\n\n    /// @notice initalize the Input facet\n    /// @param _inputLog2Size size of the input memory range in this machine\n    function initInput(uint256 _inputLog2Size) private {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n\n        require(\n            _inputLog2Size >= 3 && _inputLog2Size <= 64,\n            \"Log of input size: [3,64]\"\n        );\n\n        inputDS.inputDriveSize = (1 << _inputLog2Size);\n\n        // input box gets initialized with one empty input\n        // so that the L2 DApp knows it's own address\n        inputDS.addInternalInput(\"\");\n    }\n\n    /// @notice initialize the Validator Manager facet\n    /// @param _validators initial validator set\n    function initValidatorManager(address payable[] memory _validators)\n        private\n    {\n        LibValidatorManager.DiamondStorage\n            storage validatorManagerDS = LibValidatorManager.diamondStorage();\n\n        uint256 maxNumValidators = _validators.length;\n\n        require(maxNumValidators <= 8, \"up to 8 validators\");\n\n        validatorManagerDS.validators = _validators;\n        validatorManagerDS.maxNumValidators = maxNumValidators;\n\n        // create a new ClaimsMask, with only the consensus goal set,\n        //      according to the number of validators\n        validatorManagerDS.claimsMask = LibClaimsMask\n            .newClaimsMaskWithConsensusGoalSet(maxNumValidators);\n    }\n\n    /// @notice rollups contract initialized\n    /// @param inputDuration duration of input accumulation phase in seconds\n    /// @param challengePeriod duration of challenge period in seconds\n    event RollupsInitialized(uint256 inputDuration, uint256 challengePeriod);\n\n    /// @notice initialize the Rollups facet\n    /// @param _templateHash state hash of the cartesi machine at t0\n    /// @param _inputDuration duration of input accumulation phase in seconds\n    /// @param _challengePeriod duration of challenge period in seconds\n    function initRollups(\n        bytes32 _templateHash,\n        uint256 _inputDuration,\n        uint256 _challengePeriod\n    ) private {\n        LibRollups.DiamondStorage storage rollupsDS = LibRollups\n            .diamondStorage();\n\n        rollupsDS.templateHash = _templateHash;\n        rollupsDS.inputDuration = uint32(_inputDuration);\n        rollupsDS.challengePeriod = uint32(_challengePeriod);\n        rollupsDS.inputAccumulationStart = uint32(block.timestamp);\n        rollupsDS.currentPhase_int = uint32(Phase.InputAccumulation);\n\n        emit RollupsInitialized(_inputDuration, _challengePeriod);\n    }\n\n    /// @notice FeeManagerImpl contract initialized\n    /// @param feePerClaim fee per claim to reward the validators\n    /// @param feeManagerBank fee manager bank address\n    /// @param feeManagerOwner fee manager owner address\n    event FeeManagerInitialized(\n        uint256 feePerClaim,\n        address feeManagerBank,\n        address feeManagerOwner\n    );\n\n    /// @notice initalize the Fee Manager facet\n    /// @param _feePerClaim fee per claim to reward the validators\n    /// @param _feeManagerBank fee manager bank address\n    /// @param _feeManagerOwner fee manager owner address\n    function initFeeManager(\n        uint256 _feePerClaim,\n        address _feeManagerBank,\n        address _feeManagerOwner\n    ) private {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n\n        feeManagerDS.feePerClaim = _feePerClaim;\n        feeManagerDS.bank = IBank(_feeManagerBank);\n        feeManagerDS.owner = _feeManagerOwner;\n\n        emit FeeManagerInitialized(\n            _feePerClaim,\n            _feeManagerBank,\n            _feeManagerOwner\n        );\n    }\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"LibDiamond: Must be contract owner\"\n        );\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] diamondCut,\n        address init,\n        bytes callData\n    );\n\n    bytes32 constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _selectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(\n                _newFacetAddress,\n                \"LibDiamondCut: Add facet has no code\"\n            );\n            for (\n                uint256 selectorIndex;\n                selectorIndex < _selectors.length;\n                selectorIndex++\n            ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"LibDiamondCut: Can't add function that already exists\"\n                );\n                // add facet for selector\n                ds.facets[selector] =\n                    bytes20(_newFacetAddress) |\n                    bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot =\n                    (_selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(\n                _newFacetAddress,\n                \"LibDiamondCut: Replace facet has no code\"\n            );\n            for (\n                uint256 selectorIndex;\n                selectorIndex < _selectors.length;\n                selectorIndex++\n            ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(\n                    oldFacetAddress != address(this),\n                    \"LibDiamondCut: Can't replace immutable function\"\n                );\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"LibDiamondCut: Can't replace function with same function\"\n                );\n                require(\n                    oldFacetAddress != address(0),\n                    \"LibDiamondCut: Can't replace function that doesn't exist\"\n                );\n                // replace old facet address\n                ds.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(_newFacetAddress);\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(\n                _newFacetAddress == address(0),\n                \"LibDiamondCut: Remove facet address must be address(0)\"\n            );\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (\n                uint256 selectorIndex;\n                selectorIndex < _selectors.length;\n                selectorIndex++\n            ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\n                    );\n                    // only useful if immutable functions exist\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"LibDiamondCut: Can't remove immutable function\"\n                    );\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    lastSelector = bytes4(\n                        _selectorSlot << (selectorInSlotIndex << 5)\n                    );\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) {\n            require(\n                _calldata.length == 0,\n                \"LibDiamondCut: _init is address(0) but_calldata is not empty\"\n            );\n        } else {\n            require(\n                _calldata.length > 0,\n                \"LibDiamondCut: _calldata is empty but _init is not address(0)\"\n            );\n            if (_init != address(this)) {\n                enforceHasContractCode(\n                    _init,\n                    \"LibDiamondCut: _init address has no code\"\n                );\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector)\n        external\n        view\n        returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] diamondCut, address init, bytes callData);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external view override returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new Facet[](ds.selectorCount);\n        uint8[] memory numFacetSelectors = new uint8[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](\n                    ds.selectorCount\n                );\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_ The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        override\n        returns (bytes4[] memory facetFunctionSelectors_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        facetFunctionSelectors_ = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    facetFunctionSelectors_[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(facetFunctionSelectors_, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector)\n        external\n        view\n        override\n        returns (address facetAddress_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            (selectorCount, selectorSlot) = LibDiamond\n                .addReplaceRemoveFacetSelectors(\n                    selectorCount,\n                    selectorSlot,\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].action,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "contracts/CartesiDAppFactory.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// @title Cartesi DApp Factory\npragma solidity ^0.8.0;\n\nimport {ICartesiDAppFactory} from \"./ICartesiDAppFactory.sol\";\nimport {CartesiDApp} from \"./CartesiDApp.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\nimport {IERC173} from \"./interfaces/IERC173.sol\";\nimport {DiamondInit, DiamondConfig} from \"./upgrade_initializers/DiamondInit.sol\";\nimport {IBank} from \"./IBank.sol\";\n\ncontract CartesiDAppFactory is ICartesiDAppFactory {\n    IDiamondCut public immutable diamondCutFacet;\n    DiamondInit public immutable diamondInit;\n    IBank public immutable feeManagerBank;\n    IDiamondCut.FacetCut[] public diamondCut;\n\n    struct FactoryConfig {\n        IDiamondCut diamondCutFacet;\n        DiamondInit diamondInit;\n        IBank feeManagerBank;\n        IDiamondCut.FacetCut[] diamondCut;\n    }\n\n    constructor(FactoryConfig memory _fConfig) {\n        diamondCutFacet = _fConfig.diamondCutFacet;\n        diamondInit = _fConfig.diamondInit;\n        feeManagerBank = _fConfig.feeManagerBank;\n        for (uint256 i; i < _fConfig.diamondCut.length; ++i) {\n            diamondCut.push(_fConfig.diamondCut[i]);\n        }\n    }\n\n    function newApplication(AppConfig calldata _appConfig)\n        public\n        returns (CartesiDApp)\n    {\n        CartesiDApp application = new CartesiDApp(\n            address(this),\n            address(diamondCutFacet)\n        );\n        DiamondConfig memory dConfig = DiamondConfig({\n            templateHash: _appConfig.templateHash,\n            inputDuration: _appConfig.inputDuration,\n            challengePeriod: _appConfig.challengePeriod,\n            inputLog2Size: _appConfig.inputLog2Size,\n            feePerClaim: _appConfig.feePerClaim,\n            feeManagerBank: address(feeManagerBank),\n            feeManagerOwner: _appConfig.feeManagerOwner,\n            validators: _appConfig.validators\n        });\n        IDiamondCut(address(application)).diamondCut(\n            diamondCut,\n            address(diamondInit),\n            abi.encodeWithSelector(DiamondInit.init.selector, dConfig)\n        );\n        IERC173(address(application)).transferOwnership(\n            _appConfig.diamondOwner\n        );\n        emit ApplicationCreated(application, _appConfig);\n        return application;\n    }\n}\n"
    },
    "contracts/ICartesiDAppFactory.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// @title Cartesi DApp Factory interface\npragma solidity ^0.8.0;\n\nimport {CartesiDApp} from \"./CartesiDApp.sol\";\n\ninterface ICartesiDAppFactory {\n    /// @notice application configurations\n    /// @param diamondOwner diamond owner\n    /// @param templateHash state hash of the cartesi machine at t0\n    /// @param inputDuration duration of input accumulation phase in seconds\n    /// @param challengePeriod duration of challenge period in seconds\n    /// @param inputLog2Size size of the input memory range in this machine\n    /// @param feePerClaim fee per claim to reward the validators\n    /// @param feeManagerOwner fee manager owner address\n    /// @param validators initial validator set\n    /// @dev validators have to be unique, if the same validator is added twice\n    ///      consensus will never be reached\n    struct AppConfig {\n        // DiamondCutFacet\n        address diamondOwner;\n        // RollupsFacet\n        bytes32 templateHash;\n        uint256 inputDuration;\n        uint256 challengePeriod;\n        // InputFacet\n        uint256 inputLog2Size;\n        // FeeManagerFacet\n        uint256 feePerClaim;\n        address feeManagerOwner;\n        // ValidatorManagerFacet\n        address payable[] validators;\n    }\n\n    /// @notice Deploy a new application\n    /// @param _appConfig application configurations\n    /// @return application address\n    function newApplication(AppConfig calldata _appConfig)\n        external\n        returns (CartesiDApp);\n\n    /// @notice Event emitted when a new application is deployed\n    /// @param application application address\n    /// @param config application configurations\n    event ApplicationCreated(CartesiDApp indexed application, AppConfig config);\n}\n"
    },
    "contracts/CartesiDApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"./libraries/LibDiamond.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\n\ncontract CartesiDApp {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/IFeeManager.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Fee Manager interface\npragma solidity >=0.7.0;\n\nimport {IBank} from \"../IBank.sol\";\n\ninterface IFeeManager {\n    /// @notice this function can be called to check the number of claims that's redeemable for the validator\n    /// @param  _validator address of the validator\n    function numClaimsRedeemable(address _validator)\n        external\n        view\n        returns (uint256);\n\n    /// @notice this function can be called to check the number of claims that has been redeemed for the validator\n    /// @param  _validator address of the validator\n    function getNumClaimsRedeemed(address _validator)\n        external\n        view\n        returns (uint256);\n\n    /// @notice contract owner can set/reset the value of fee per claim\n    /// @param  _value the new value of fee per claim\n    function resetFeePerClaim(uint256 _value) external;\n\n    /// @notice this function can be called to redeem fees for validators\n    /// @param  _validator address of the validator that is redeeming\n    function redeemFee(address _validator) external;\n\n    /// @notice returns the bank used to manage fees\n    function getFeeManagerBank() external view returns (IBank);\n\n    /// @notice emitted on resetting feePerClaim\n    event FeePerClaimReset(uint256 value);\n\n    /// @notice emitted on ERC20 funds redeemed by validator\n    event FeeRedeemed(address validator, uint256 claims);\n}\n"
    },
    "contracts/facets/FeeManagerFacet.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Fee Manager facet\npragma solidity >=0.8.8;\n\nimport {IBank} from \"../IBank.sol\";\nimport {IFeeManager} from \"../interfaces/IFeeManager.sol\";\nimport {LibFeeManager} from \"../libraries/LibFeeManager.sol\";\n\ncontract FeeManagerFacet is IFeeManager {\n    using LibFeeManager for LibFeeManager.DiamondStorage;\n\n    /// @notice functions modified by noReentrancy are not subject to recursion\n    modifier noReentrancy() {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        require(!feeManagerDS.lock, \"reentrancy not allowed\");\n        feeManagerDS.lock = true;\n        _;\n        feeManagerDS.lock = false;\n    }\n\n    /// @notice this function can be called to check the number of claims that's redeemable for the validator\n    /// @param  _validator address of the validator\n    function numClaimsRedeemable(address _validator)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        return feeManagerDS.numClaimsRedeemable(_validator);\n    }\n\n    /// @notice this function can be called to check the number of claims that has been redeemed for the validator\n    /// @param  _validator address of the validator\n    function getNumClaimsRedeemed(address _validator)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        return feeManagerDS.getNumClaimsRedeemed(_validator);\n    }\n\n    /// @notice contract owner can reset the value of fee per claim\n    /// @param  _value the new value of fee per claim\n    function resetFeePerClaim(uint256 _value) public override {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        feeManagerDS.onlyOwner();\n        feeManagerDS.resetFeePerClaim(_value);\n    }\n\n    /// @notice this function can be called to redeem fees for validators\n    /// @param  _validator address of the validator that is redeeming\n    function redeemFee(address _validator) public override noReentrancy {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        feeManagerDS.redeemFee(_validator);\n    }\n\n    /// @notice returns the bank used to manage fees\n    function getFeeManagerBank() public view override returns (IBank) {\n        LibFeeManager.DiamondStorage storage feeManagerDS = LibFeeManager\n            .diamondStorage();\n        return feeManagerDS.bank;\n    }\n}\n"
    },
    "contracts/facets/ERC20PortalFacet.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Generic ERC20 Portal facet\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IERC20Portal} from \"../interfaces/IERC20Portal.sol\";\n\nimport {LibInput} from \"../libraries/LibInput.sol\";\n\ncontract ERC20PortalFacet is IERC20Portal {\n    using LibInput for LibInput.DiamondStorage;\n\n    bytes32 constant INPUT_HEADER = keccak256(\"ERC20_Transfer\");\n\n    /// @notice deposit an amount of a generic ERC20 in the portal and create tokens in L2\n    /// @param _ERC20 address of the ERC20 token contract\n    /// @param _amount amount of the ERC20 token to be deposited\n    /// @param _data information to be interpreted by L2\n    /// @return hash of input generated by deposit\n    function erc20Deposit(\n        address _ERC20,\n        uint256 _amount,\n        bytes calldata _data\n    ) public override returns (bytes32) {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        IERC20 token = IERC20(_ERC20);\n\n        require(\n            token.transferFrom(msg.sender, address(this), _amount),\n            \"ERC20 transferFrom failed\"\n        );\n\n        bytes memory input = abi.encode(\n            INPUT_HEADER,\n            msg.sender,\n            _ERC20,\n            _amount,\n            _data\n        );\n\n        emit ERC20Deposited(_ERC20, msg.sender, _amount, _data);\n        return inputDS.addInternalInput(input);\n    }\n}\n"
    },
    "contracts/facets/EtherPortalFacet.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Ether Portal facet\npragma solidity ^0.8.0;\n\nimport {IEtherPortal} from \"../interfaces/IEtherPortal.sol\";\n\nimport {LibInput} from \"../libraries/LibInput.sol\";\n\ncontract EtherPortalFacet is IEtherPortal {\n    using LibInput for LibInput.DiamondStorage;\n\n    bytes32 constant INPUT_HEADER = keccak256(\"Ether_Transfer\");\n\n    /// @notice deposit an amount of Ether in the portal and create Ether in L2\n    /// @param _data information to be interpreted by L2\n    /// @return hash of input generated by deposit\n    function etherDeposit(bytes calldata _data)\n        public\n        payable\n        override\n        returns (bytes32)\n    {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        bytes memory input = abi.encode(\n            INPUT_HEADER,\n            msg.sender,\n            msg.value,\n            _data\n        );\n\n        emit EtherDeposited(msg.sender, msg.value, _data);\n        return inputDS.addInternalInput(input);\n    }\n\n    /// @notice withdraw an amount of Ether from the portal\n    /// @param _data data with withdrawal information\n    /// @dev can only be called by the Rollups contract\n    function etherWithdrawal(bytes calldata _data)\n        public\n        override\n        returns (bool)\n    {\n        // Delegate calls preserve msg.sender, msg.value and address(this)\n        require(msg.sender == address(this), \"only itself\");\n\n        (address payable receiver, uint256 value) = abi.decode(\n            _data,\n            (address, uint256)\n        );\n\n        // We used to call receiver.transfer(value) but it's no\n        // longer considered safe, as it assumes gas costs are\n        // immutable, while in fact they are not.\n        (bool success, ) = receiver.call{value: value}(\"\");\n        require(success, \"transfer failed\");\n\n        emit EtherWithdrawn(receiver, value);\n\n        return true;\n    }\n}\n"
    },
    "contracts/facets/InputFacet.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Input facet\npragma solidity ^0.8.0;\n\nimport {IInput} from \"../interfaces/IInput.sol\";\n\nimport {LibInput} from \"../libraries/LibInput.sol\";\n\ncontract InputFacet is IInput {\n    using LibInput for LibInput.DiamondStorage;\n\n    /// @notice add input to processed by next epoch\n    /// @param _input input to be understood by offchain machine\n    /// @dev offchain code is responsible for making sure\n    ///      that input size is power of 2 and multiple of 8 since\n    //       the offchain machine has a 8 byte word\n    function addInput(bytes calldata _input) public override returns (bytes32) {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        return inputDS.addInput(_input);\n    }\n\n    /// @notice get input inside inbox of currently proposed claim\n    /// @param _index index of input inside that inbox\n    /// @return hash of input at index _index\n    /// @dev currentInputBox being zero means that the inputs for\n    ///      the claimed epoch are on input box one\n    function getInput(uint256 _index) public view override returns (bytes32) {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        return inputDS.getInput(_index);\n    }\n\n    /// @notice get number of inputs inside inbox of currently proposed claim\n    /// @return number of inputs on that input box\n    /// @dev currentInputBox being zero means that the inputs for\n    ///      the claimed epoch are on input box one\n    function getNumberOfInputs() public view override returns (uint256) {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        return inputDS.getNumberOfInputs();\n    }\n\n    /// @notice get inbox currently receiveing inputs\n    /// @return input inbox currently receiveing inputs\n    function getCurrentInbox() public view override returns (uint256) {\n        LibInput.DiamondStorage storage inputDS = LibInput.diamondStorage();\n        return inputDS.currentInputBox;\n    }\n}\n"
    },
    "contracts/interfaces/IInput.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title Input interface\npragma solidity >=0.7.0;\n\ninterface IInput {\n    /// @notice adds input to correct inbox\n    /// @param _input bytes array of input\n    /// @return merkle root hash of input\n    /// @dev  msg.sender and timestamp are preppended log2 size\n    ///       has to be calculated offchain taking that into account\n    function addInput(bytes calldata _input) external returns (bytes32);\n\n    /// @notice returns input from correct input inbox\n    /// @param _index position of the input on inbox\n    /// @return root hash of input\n    function getInput(uint256 _index) external view returns (bytes32);\n\n    /// @notice returns number of inputs on correct inbox\n    /// @return number of inputs of non active inbox\n    function getNumberOfInputs() external view returns (uint256);\n\n    /// @notice returns active current inbox index\n    /// @return index of current active inbox\n    function getCurrentInbox() external view returns (uint256);\n\n    /// @notice input added\n    /// @param epochNumber which epoch this input belongs to\n    /// @param inputIndex index of the input just added\n    /// @param sender msg.sender\n    /// @param timestamp block.timestamp\n    /// @param input input data\n    event InputAdded(\n        uint256 indexed epochNumber,\n        uint256 indexed inputIndex,\n        address sender,\n        uint256 timestamp,\n        bytes input\n    );\n}\n"
    },
    "contracts/test_helper/SimpleNFT.sol": {
      "content": "// Copyright 2022 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title A Simple NFT Contract\npragma solidity ^0.8.0;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract SimpleNFT is ERC721 {\n    // name: SimpleNFT\n    // symbol: SIM\n    constructor(uint256[] memory tokenIds) ERC721(\"SimpleNFT\", \"SIM\") {\n        for (uint256 i; i < tokenIds.length; i++) {\n            _safeMint(msg.sender, tokenIds[i]);\n        }\n    }\n}\n"
    },
    "contracts/test_helper/SimpleToken.sol": {
      "content": "// Copyright 2021 Cartesi Pte. Ltd.\n\n// SPDX-License-Identifier: Apache-2.0\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n// this file except in compliance with the License. You may obtain a copy of the\n// License at http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software distributed\n// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/// @title A Simple Token\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract SimpleToken is ERC20 {\n    // name: SimpleToken\n    // symbol: SIM\n    constructor(uint256 initialSupply) ERC20(\"SimpleToken\", \"SIM\") {\n        // on Hardhat network, 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 should be the address of signers[0]\n        // generated from default mnemonic \"test test test test test test test test test test test junk\"\n        _mint(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, initialSupply);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}