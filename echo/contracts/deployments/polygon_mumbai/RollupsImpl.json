{
  "address": "0x2DE3edbcF55a1FAC46c665Bb8C0Fd95FB353deEa",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_inputDuration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_challengePeriod",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_inputLog2Size",
          "type": "uint256"
        },
        {
          "internalType": "address payable[]",
          "name": "_validators",
          "type": "address[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_epochNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_claimer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_epochHash",
          "type": "bytes32"
        }
      ],
      "name": "Claim",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_epochNumber",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_epochHash",
          "type": "bytes32"
        }
      ],
      "name": "FinalizeEpoch",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "enum Rollups.Phase",
          "name": "_newPhase",
          "type": "uint8"
        }
      ],
      "name": "PhaseChange",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_winner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_loser",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_winningClaim",
          "type": "bytes32"
        }
      ],
      "name": "ResolveDispute",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_input",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_output",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_validatorManager",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_disputeManager",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_inputDuration",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_challengePeriod",
          "type": "uint256"
        }
      ],
      "name": "RollupsCreated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_epochHash",
          "type": "bytes32"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "disputeManager",
      "outputs": [
        {
          "internalType": "contract DisputeManagerImpl",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "finalizeEpoch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentEpoch",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentPhase",
      "outputs": [
        {
          "internalType": "enum Rollups.Phase",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDisputeManagerAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInputAccumulationStart",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInputAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getOutputAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getValidatorManagerAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "input",
      "outputs": [
        {
          "internalType": "contract InputImpl",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "notifyInput",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "output",
      "outputs": [
        {
          "internalType": "contract OutputImpl",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "_winner",
          "type": "address"
        },
        {
          "internalType": "address payable",
          "name": "_loser",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_winningClaim",
          "type": "bytes32"
        }
      ],
      "name": "resolveDispute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "storageVar",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "inputDuration",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "challengePeriod",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "inputAccumulationStart",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "sealingEpochTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "currentPhase_int",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "validatorManager",
      "outputs": [
        {
          "internalType": "contract ValidatorManagerImpl",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb389959e2d23a0711afc3103234b0267ace7c8a857081e2d841df755d649d792",
  "receipt": {
    "to": null,
    "from": "0x18930e8a66a1DbE21D00581216789AAB7460Afd0",
    "contractAddress": "0x2DE3edbcF55a1FAC46c665Bb8C0Fd95FB353deEa",
    "transactionIndex": 2,
    "gasUsed": "3154082",
    "logsBloom": "0x0000000001000000000000020000000000000000000000000000002000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000080000000000000000000010000000000400000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000008000000000000000000020040000000000000000000000000000000000000000000400000000000000400000000000000000000100000000000000000000000000000010004000000000000000000000000000000000200000000000000000000000000002c000100000",
    "blockHash": "0x4219b1989842285f699875f79dfdbc19501fd898f784944cae71c7d469f9e522",
    "transactionHash": "0xb389959e2d23a0711afc3103234b0267ace7c8a857081e2d841df755d649d792",
    "logs": [
      {
        "transactionIndex": 2,
        "blockNumber": 25638500,
        "transactionHash": "0xb389959e2d23a0711afc3103234b0267ace7c8a857081e2d841df755d649d792",
        "address": "0x2DE3edbcF55a1FAC46c665Bb8C0Fd95FB353deEa",
        "topics": [
          "0x0c34d7ca767e7f7b827de620cbd78c6291e2ca28d8ac112f26c5121912ea1ecc"
        ],
        "data": "0x000000000000000000000000b5ccad9fe56fdc70d770b107a6d3b354ddf8d1e6000000000000000000000000b90467e3c4fb5ac75aab8d932a4136e5d4ee58140000000000000000000000002eec2d8242b05e9dfbad0b0a0e62b39966b1dc280000000000000000000000005fc9fb6cd7320817e70a64eace9f5c5f960f39fa00000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000093a80",
        "logIndex": 104,
        "blockHash": "0x4219b1989842285f699875f79dfdbc19501fd898f784944cae71c7d469f9e522"
      },
      {
        "transactionIndex": 2,
        "blockNumber": 25638500,
        "transactionHash": "0xb389959e2d23a0711afc3103234b0267ace7c8a857081e2d841df755d649d792",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000018930e8a66a1dbe21d00581216789aab7460afd0",
          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000e01c6ad44a03580000000000000000000000000000000000000000000000000ca45d1c42f405a7000000000000000000000000000000000000000000000c1a364c90d1e5d062e10000000000000000000000000000000000000000000000000bc440b16eaa024f000000000000000000000000000000000000000000000c1a372cad3cba1a6639",
        "logIndex": 105,
        "blockHash": "0x4219b1989842285f699875f79dfdbc19501fd898f784944cae71c7d469f9e522"
      }
    ],
    "blockNumber": 25638500,
    "cumulativeGasUsed": "4519620",
    "status": 1,
    "byzantium": true
  },
  "args": [
    86400,
    604800,
    25,
    [
      "0x18930e8a66a1DbE21D00581216789AAB7460Afd0"
    ]
  ],
  "numDeployments": 2,
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_challengePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputLog2Size\",\"type\":\"uint256\"},{\"internalType\":\"address payable[]\",\"name\":\"_validators\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_epochHash\",\"type\":\"bytes32\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_epochNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_epochHash\",\"type\":\"bytes32\"}],\"name\":\"FinalizeEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Rollups.Phase\",\"name\":\"_newPhase\",\"type\":\"uint8\"}],\"name\":\"PhaseChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_loser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_winningClaim\",\"type\":\"bytes32\"}],\"name\":\"ResolveDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_validatorManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_disputeManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_inputDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_challengePeriod\",\"type\":\"uint256\"}],\"name\":\"RollupsCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_epochHash\",\"type\":\"bytes32\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeManager\",\"outputs\":[{\"internalType\":\"contract DisputeManagerImpl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPhase\",\"outputs\":[{\"internalType\":\"enum Rollups.Phase\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDisputeManagerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInputAccumulationStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInputAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOutputAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidatorManagerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"input\",\"outputs\":[{\"internalType\":\"contract InputImpl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyInput\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"output\",\"outputs\":[{\"internalType\":\"contract OutputImpl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_winner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_loser\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_winningClaim\",\"type\":\"bytes32\"}],\"name\":\"resolveDispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storageVar\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"inputDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"challengePeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"inputAccumulationStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"sealingEpochTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"currentPhase_int\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorManager\",\"outputs\":[{\"internalType\":\"contract ValidatorManagerImpl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_challengePeriod\":\"duration of challenge period in seconds\",\"_inputDuration\":\"duration of input accumulation phase in seconds\",\"_inputLog2Size\":\"size of the input drive in this machine\",\"_validators\":\"initial validator set\"}},\"finalizeEpoch()\":{\"details\":\"can only be called if challenge period is over\"},\"getCurrentEpoch()\":{\"details\":\"if phase is input accumulation, then the epoch number is length\",\"returns\":{\"_0\":\"index of current epoch\"}},\"notifyInput()\":{\"details\":\"can only be called by input contract\"},\"resolveDispute(address,address,bytes32)\":{\"details\":\"can only be called by the dispute contract\",\"params\":{\"_loser\":\"loser of dispute\",\"_winner\":\"winner of dispute\",\"_winningClaim\":\"initial claim of winning validator\"}}},\"version\":1},\"userdoc\":{\"events\":{\"Claim(uint256,address,bytes32)\":{\"notice\":\"claim submitted\"},\"FinalizeEpoch(uint256,bytes32)\":{\"notice\":\"epoch finalized\"},\"PhaseChange(uint8)\":{\"notice\":\"phase change\"},\"ResolveDispute(address,address,bytes32)\":{\"notice\":\"dispute resolved\"},\"RollupsCreated(address,address,address,address,uint256,uint256)\":{\"notice\":\"contract created\"}},\"kind\":\"user\",\"methods\":{\"claim(bytes32)\":{\"notice\":\"TODO: add signatures for aggregated claims\"},\"constructor\":{\"notice\":\"creates contract\"},\"finalizeEpoch()\":{\"notice\":\"finalize epoch after timeout\"},\"getCurrentEpoch()\":{\"notice\":\"returns index of current (accumulating) epoch\"},\"getCurrentPhase()\":{\"notice\":\"returns the current phase\"},\"getDisputeManagerAddress()\":{\"notice\":\"returns address of dispute manager contract\"},\"getInputAccumulationStart()\":{\"notice\":\"returns the input accumulation start timestamp\"},\"getInputAddress()\":{\"notice\":\"returns address of input contract\"},\"getOutputAddress()\":{\"notice\":\"returns address of output contract\"},\"getValidatorManagerAddress()\":{\"notice\":\"returns address of validator manager contract\"},\"notifyInput()\":{\"notice\":\"called when new input arrives, manages the phase changes\"},\"resolveDispute(address,address,bytes32)\":{\"notice\":\"called when a dispute is resolved by the dispute manager\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RollupsImpl.sol\":\"RollupsImpl\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@cartesi/util/contracts/Bitmask.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\npragma solidity ^0.8.0;\\n\\n/// @title Bit Mask Library\\n/// @author Stephen Chen\\n/// @notice Implements bit mask with dynamic array\\nlibrary Bitmask {\\n    /// @notice Set a bit in the bit mask\\n    function setBit(\\n        mapping(uint256 => uint256) storage bitmask,\\n        uint256 _bit,\\n        bool _value\\n    ) public {\\n        // calculate the number of bits has been store in bitmask now\\n        uint256 positionOfMask = uint256(_bit / 256);\\n        uint256 positionOfBit = _bit % 256;\\n\\n        if (_value) {\\n            bitmask[positionOfMask] =\\n                bitmask[positionOfMask] |\\n                (1 << positionOfBit);\\n        } else {\\n            bitmask[positionOfMask] =\\n                bitmask[positionOfMask] &\\n                ~(1 << positionOfBit);\\n        }\\n    }\\n\\n    /// @notice Get a bit in the bit mask\\n    function getBit(mapping(uint256 => uint256) storage bitmask, uint256 _bit)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        // calculate the number of bits has been store in bitmask now\\n        uint256 positionOfMask = uint256(_bit / 256);\\n        uint256 positionOfBit = _bit % 256;\\n\\n        return ((bitmask[positionOfMask] & (1 << positionOfBit)) != 0);\\n    }\\n}\\n\",\"keccak256\":\"0xe35cf68672f5844589c0e56f36aa3813ca4ffb882a55a46d15adac7e3cc889bd\",\"license\":\"Apache-2.0\"},\"@cartesi/util/contracts/CartesiMath.sol\":{\"content\":\"// Copyright 2020 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title CartesiMath\\n/// @author Felipe Argento\\npragma solidity ^0.8.0;\\n\\nlibrary CartesiMath {\\n    // mapping values are packed as bytes3 each\\n    // see test/TestCartesiMath.ts for decimal values\\n    bytes constant log2tableTimes1M =\\n        hex\\\"0000000F4240182F421E8480236E082771822AD63A2DC6C0305E8532B04834C96736B3C23876D73A187A3B9D4A3D09003E5EA63FA0C540D17741F28843057D440BA745062945F60246DC1047B917488DC7495ABA4A207C4ADF8A4B98544C4B404CF8AA4DA0E64E44434EE3054F7D6D5013B750A61A5134C851BFF05247BD52CC58534DE753CC8D54486954C19C55384255AC75561E50568DE956FB575766B057D00758376F589CFA5900BA5962BC59C3135A21CA5A7EF15ADA945B34BF5B8D805BE4DF5C3AEA5C8FA95CE3265D356C5D86835DD6735E25455E73005EBFAD5F0B525F55F75F9FA25FE85A60302460770860BD0A61023061467F6189FD61CCAE620E98624FBF62902762CFD5630ECD634D12638AA963C7966403DC643F7F647A8264B4E864EEB56527EC6560906598A365D029660724663D9766738566A8F066DDDA6712476746386779AF67ACAF67DF3A6811526842FA68743268A4FC68D55C6905536934E169640A6992CF69C13169EF326A1CD46A4A186A76FF6AA38C6ACFC0\\\";\\n\\n    /// @notice Approximates log2 * 1M\\n    /// @param _num number to take log2 * 1M of\\n    /// @return approximate log2 times 1M\\n    function log2ApproxTimes1M(uint256 _num) public pure returns (uint256) {\\n        require(_num > 0, \\\"Number cannot be zero\\\");\\n        uint256 leading = 0;\\n\\n        if (_num == 1) return 0;\\n\\n        while (_num > 128) {\\n            _num = _num >> 1;\\n            leading += 1;\\n        }\\n        return (leading * uint256(1000000)) + (getLog2TableTimes1M(_num));\\n    }\\n\\n    /// @notice navigates log2tableTimes1M\\n    /// @param _num number to take log2 of\\n    /// @return result after table look-up\\n    function getLog2TableTimes1M(uint256 _num) public pure returns (uint256) {\\n        bytes3 result = 0;\\n        for (uint8 i = 0; i < 3; i++) {\\n            bytes3 tempResult = log2tableTimes1M[(_num - 1) * 3 + i];\\n            result = result | (tempResult >> (i * 8));\\n        }\\n\\n        return uint256(uint24(result));\\n    }\\n\\n    /// @notice get floor of log2 of number\\n    /// @param _num number to take floor(log2) of\\n    /// @return floor(log2) of _num\\n   function getLog2Floor(uint256 _num) public pure returns (uint8) {\\n       require(_num != 0, \\\"log of zero is undefined\\\");\\n\\n       return uint8(255 - clz(_num));\\n    }\\n\\n    /// @notice checks if a number is Power of 2\\n    /// @param _num number to check\\n    /// @return true if number is power of 2, false if not\\n    function isPowerOf2(uint256 _num) public pure returns (bool) {\\n        if (_num == 0) return false;\\n\\n        return _num & (_num - 1) == 0;\\n    }\\n\\n    /// @notice count trailing zeros\\n    /// @param _num number you want the ctz of\\n    /// @dev this a binary search implementation\\n    function ctz(uint256 _num) public pure returns (uint256) {\\n        if (_num == 0) return 256;\\n\\n        uint256 n = 0;\\n        if (_num & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) { n = n + 128; _num = _num >> 128; }\\n        if (_num & 0x000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF == 0) { n = n + 64; _num = _num >> 64; }\\n        if (_num & 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF == 0) { n = n + 32; _num = _num >> 32; }\\n        if (_num & 0x000000000000000000000000000000000000000000000000000000000000FFFF == 0) { n = n + 16; _num = _num >> 16; }\\n        if (_num & 0x00000000000000000000000000000000000000000000000000000000000000FF == 0) { n = n +  8; _num = _num >>  8; }\\n        if (_num & 0x000000000000000000000000000000000000000000000000000000000000000F == 0) { n = n +  4; _num = _num >>  4; }\\n        if (_num & 0x0000000000000000000000000000000000000000000000000000000000000003 == 0) { n = n +  2; _num = _num >>  2; }\\n        if (_num & 0x0000000000000000000000000000000000000000000000000000000000000001 == 0) { n = n +  1; }\\n\\n        return n;\\n    }\\n\\n    /// @notice count leading zeros\\n    /// @param _num number you want the clz of\\n    /// @dev this a binary search implementation\\n    function clz(uint256 _num) public pure returns (uint256) {\\n        if (_num == 0) return 256;\\n\\n        uint256 n = 0;\\n        if (_num & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000 == 0) { n = n + 128; _num = _num << 128; }\\n        if (_num & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 == 0) { n = n + 64; _num = _num << 64; }\\n        if (_num & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000 == 0) { n = n + 32; _num = _num << 32; }\\n        if (_num & 0xFFFF000000000000000000000000000000000000000000000000000000000000 == 0) { n = n + 16; _num = _num << 16; }\\n        if (_num & 0xFF00000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  8; _num = _num <<  8; }\\n        if (_num & 0xF000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  4; _num = _num <<  4; }\\n        if (_num & 0xC000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  2; _num = _num <<  2; }\\n        if (_num & 0x8000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  1; }\\n\\n        return n;\\n    }\\n}\\n\",\"keccak256\":\"0x28b74012e966438edff701decdc5ffd207b3f0244af65fbd7d397050986e58d4\",\"license\":\"Apache-2.0\"},\"@cartesi/util/contracts/Merkle.sol\":{\"content\":\"// Copyright 2020 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Library for Merkle proofs\\npragma solidity ^0.8.0;\\n\\nimport \\\"./CartesiMath.sol\\\";\\n\\nlibrary Merkle {\\n    using CartesiMath for uint256;\\n\\n    uint128 constant L_WORD_SIZE = 3; // word = 8 bytes, log = 3\\n    // number of hashes in EMPTY_TREE_HASHES\\n    uint128 constant EMPTY_TREE_SIZE = 1952; // 61*32=1952. 32 bytes per 61 indexes (64 words)\\n\\n    // merkle root hashes of trees of zero concatenated\\n    // 32 bytes for each root, first one is keccak(0), second one is\\n    // keccak(keccack(0), keccak(0)) and so on\\n\\n    bytes constant EMPTY_TREE_HASHES =\\n        hex\\\"011b4d03dd8c01f1049143cf9c4c817e4b167f1d1b83e5c6f0f10d89ba1e7bce4d9470a821fbe90117ec357e30bad9305732fb19ddf54a07dd3e29f440619254ae39ce8537aca75e2eff3e38c98011dfe934e700a0967732fc07b430dd656a233fc9a15f5b4869c872f81087bb6104b7d63e6f9ab47f2c43f3535eae7172aa7f17d2dd614cddaa4d879276b11e0672c9560033d3e8453a1d045339d34ba601b9c37b8b13ca95166fb7af16988a70fcc90f38bf9126fd833da710a47fb37a55e68e7a427fa943d9966b389f4f257173676090c6e95f43e2cb6d65f8758111e30930b0b9deb73e155c59740bacf14a6ff04b64bb8e201a506409c3fe381ca4ea90cd5deac729d0fdaccc441d09d7325f41586ba13c801b7eccae0f95d8f3933efed8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e6163e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b72122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec517a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca892b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e152499af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8bf065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a233e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698caefdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d33abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf98dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f65d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f649929927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e6191b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c99876e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977ec61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f945ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f8647bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348cafff75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172dafa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e2496d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f6d1ab973982c7ccbe6c1fae02788e4422ae22282fa49cbdb04ba54a7a238c6fc41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683916ca832592485093644e8760cd7b4c01dba1ccc82b661bf13f0e3f34acd6b88\\\";\\n\\n    /// @notice Gets merkle root hash of drive with a replacement\\n    /// @param _position position of _drive\\n    /// @param _logSizeOfReplacement log2 of size the replacement\\n    /// @param _logSizeOfFullDrive log2 of size the full drive, which can be the entire machine\\n    /// @param _replacement hash of the replacement\\n    /// @param siblings of replacement that merkle root can be calculated\\n    function getRootAfterReplacementInDrive(\\n        uint256 _position,\\n        uint256 _logSizeOfReplacement,\\n        uint256 _logSizeOfFullDrive,\\n        bytes32 _replacement,\\n        bytes32[] calldata siblings\\n    ) public pure returns (bytes32) {\\n        require(\\n            _logSizeOfFullDrive >= _logSizeOfReplacement &&\\n                _logSizeOfReplacement >= 3 &&\\n                _logSizeOfFullDrive <= 64,\\n            \\\"3 <= logSizeOfReplacement <= logSizeOfFullDrive <= 64\\\"\\n        );\\n\\n        uint256 size = 1 << _logSizeOfReplacement;\\n\\n        require(((size - 1) & _position) == 0, \\\"Position is not aligned\\\");\\n        require(\\n            siblings.length == _logSizeOfFullDrive - _logSizeOfReplacement,\\n            \\\"Proof length does not match\\\"\\n        );\\n\\n        for (uint256 i; i < siblings.length; i++) {\\n            if ((_position & (size << i)) == 0) {\\n                _replacement = keccak256(\\n                    abi.encodePacked(_replacement, siblings[i])\\n                );\\n            } else {\\n                _replacement = keccak256(\\n                    abi.encodePacked(siblings[i], _replacement)\\n                );\\n            }\\n        }\\n\\n        return _replacement;\\n    }\\n\\n    /// @notice Gets precomputed hash of zero in empty tree hashes\\n    /// @param _index of hash wanted\\n    /// @dev first index is keccak(0), second index is keccak(keccak(0), keccak(0))\\n    function getEmptyTreeHashAtIndex(uint256 _index)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        uint256 start = _index * 32;\\n        require(EMPTY_TREE_SIZE >= start + 32, \\\"index out of bounds\\\");\\n        bytes32 hashedZeros;\\n        bytes memory zeroTree = EMPTY_TREE_HASHES;\\n\\n        // first word is length, then skip index words\\n        assembly {\\n            hashedZeros := mload(add(add(zeroTree, 0x20), start))\\n        }\\n        return hashedZeros;\\n    }\\n\\n    /// @notice get merkle root of generic array of bytes\\n    /// @param _data array of bytes to be merklelized\\n    /// @param _log2Size log2 of total size of the drive\\n    /// @dev _data is padded with zeroes until is multiple of 8\\n    /// @dev root is completed with zero tree until log2size is complete\\n    /// @dev hashes are taken word by word (8 bytes by 8 bytes)\\n    function getMerkleRootFromBytes(bytes calldata _data, uint256 _log2Size)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        require(_log2Size >= 3 && _log2Size <= 64, \\\"range of log2Size: [3,64]\\\");\\n\\n        // if _data is empty return pristine drive of size log2size\\n        if (_data.length == 0) return getEmptyTreeHashAtIndex(_log2Size - 3);\\n\\n        // total size of the drive in words\\n        uint256 size = 1 << (_log2Size - 3);\\n        require(\\n            size << L_WORD_SIZE >= _data.length,\\n            \\\"data is bigger than drive\\\"\\n        );\\n        // the stack depth is log2(_data.length / 8) + 2\\n        uint256 stack_depth = 2 +\\n            ((_data.length) >> L_WORD_SIZE).getLog2Floor();\\n        bytes32[] memory stack = new bytes32[](stack_depth);\\n\\n        uint256 numOfHashes; // total number of hashes on stack (counting levels)\\n        uint256 stackLength; // total length of stack\\n        uint256 numOfJoins; // number of hashes of the same level on stack\\n        uint256 topStackLevel; // hash level of the top of the stack\\n\\n        while (numOfHashes < size) {\\n            if ((numOfHashes << L_WORD_SIZE) < _data.length) {\\n                // we still have words to hash\\n                stack[stackLength] = getHashOfWordAtIndex(_data, numOfHashes);\\n                numOfHashes++;\\n\\n                numOfJoins = numOfHashes;\\n            } else {\\n                // since padding happens in hashOfWordAtIndex function\\n                // we only need to complete the stack with pre-computed\\n                // hash(0), hash(hash(0),hash(0)) and so on\\n                topStackLevel = numOfHashes.ctz();\\n\\n                stack[stackLength] = getEmptyTreeHashAtIndex(topStackLevel);\\n\\n                //Empty Tree Hash summarizes many hashes\\n                numOfHashes = numOfHashes + (1 << topStackLevel);\\n                numOfJoins = numOfHashes >> topStackLevel;\\n            }\\n\\n            stackLength++;\\n\\n            // while there are joins, hash top of stack together\\n            while (numOfJoins & 1 == 0) {\\n                bytes32 h2 = stack[stackLength - 1];\\n                bytes32 h1 = stack[stackLength - 2];\\n\\n                stack[stackLength - 2] = keccak256(abi.encodePacked(h1, h2));\\n                stackLength = stackLength - 1; // remove hashes from stack\\n\\n                numOfJoins = numOfJoins >> 1;\\n            }\\n        }\\n        require(stackLength == 1, \\\"stack error\\\");\\n\\n        return stack[0];\\n    }\\n\\n    /// @notice Get the hash of a word in an array of bytes\\n    /// @param _data array of bytes\\n    /// @param _wordIndex index of word inside the bytes to get the hash of\\n    /// @dev if word is incomplete (< 8 bytes) it gets padded with zeroes\\n    function getHashOfWordAtIndex(bytes calldata _data, uint256 _wordIndex)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        uint256 start = _wordIndex << L_WORD_SIZE;\\n        uint256 end = start + (1 << L_WORD_SIZE);\\n\\n        // TODO: in .lua this just returns zero, but this might be more consistent\\n        require(start <= _data.length, \\\"word out of bounds\\\");\\n\\n        if (end <= _data.length) {\\n            return keccak256(abi.encodePacked(_data[start:end]));\\n        }\\n\\n        // word is incomplete\\n        // fill paddedSlice with incomplete words - the rest is going to be bytes(0)\\n        bytes memory paddedSlice = new bytes(8);\\n        uint256 remaining = _data.length - start;\\n\\n        for (uint256 i; i < remaining; i++) {\\n            paddedSlice[i] = _data[start + i];\\n        }\\n\\n        return keccak256(paddedSlice);\\n    }\\n\\n    /// @notice Calculate the root of Merkle tree from an array of power of 2 elements\\n    /// @param hashes The array containing power of 2 elements\\n    /// @return byte32 the root hash being calculated\\n    function calculateRootFromPowerOfTwo(bytes32[] memory hashes)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        // revert when the input is not of power of 2\\n        require((hashes.length).isPowerOf2(), \\\"array len not power of 2\\\");\\n\\n        if (hashes.length == 1) {\\n            return hashes[0];\\n        } else {\\n            bytes32[] memory newHashes = new bytes32[](hashes.length >> 1);\\n\\n            for (uint256 i; i < hashes.length; i += 2) {\\n                newHashes[i >> 1] = keccak256(\\n                    abi.encodePacked(hashes[i], hashes[i + 1])\\n                );\\n            }\\n\\n            return calculateRootFromPowerOfTwo(newHashes);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe9896db44cc4dab335a3e776c629186824823d316d902b2efecb4b0a3e3dfdb7\",\"license\":\"Apache-2.0\"},\"contracts/DisputeManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title DisputeManager\\npragma solidity >=0.7.0;\\n\\ninterface DisputeManager {\\n    function initiateDispute(\\n        bytes32[2] memory _claims,\\n        address payable[2] memory _claimers\\n    ) external;\\n}\\n\",\"keccak256\":\"0xaf5e1b8531469091519f02126a58161788980015d696bf95ba59679ff6366ec1\",\"license\":\"Apache-2.0\"},\"contracts/DisputeManagerImpl.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title DisputeManager\\npragma solidity ^0.8.0;\\n\\nimport \\\"./DisputeManager.sol\\\";\\nimport \\\"./Rollups.sol\\\";\\n\\ncontract DisputeManagerImpl is DisputeManager {\\n    Rollups immutable rollups; // rollups contract\\n\\n    /// @notice functions modified by onlyRollups will only be executed if\\n    //  they're called by Rollups contract, otherwise it will throw an exception\\n    modifier onlyRollups {\\n        require(\\n            msg.sender == address(rollups),\\n            \\\"Only rollups can call this functions\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _rollups) {\\n        rollups = Rollups(_rollups);\\n    }\\n\\n    /// @notice initiates a dispute betweent two players\\n    /// @param _claims conflicting claims\\n    /// @param _claimers addresses of senders of conflicting claim\\n    /// @dev this is a mock implementation that just gives the win\\n    ///      to the address in the first posititon of _claimers array\\n    function initiateDispute(\\n        bytes32[2] memory _claims,\\n        address payable[2] memory _claimers\\n    ) public override onlyRollups {\\n        rollups.resolveDispute(_claimers[0], _claimers[1], _claims[0]);\\n    }\\n}\\n\",\"keccak256\":\"0xb7c09b049c624a14302a58fe33006581a9391be12cc697c611bb0aaf6794a923\",\"license\":\"Apache-2.0\"},\"contracts/Input.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Input\\npragma solidity >=0.7.0;\\n\\ninterface Input {\\n    /// @notice adds input to correct inbox\\n    /// @param _input bytes array of input\\n    /// @return merkle root hash of input\\n    /// @dev  msg.sender and timestamp are preppended log2 size\\n    ///       has to be calculated offchain taking that into account\\n    function addInput(bytes calldata _input) external returns (bytes32);\\n\\n    /// @notice returns input from correct input inbox\\n    /// @param _index position of the input on inbox\\n    /// @return root hash of input\\n    function getInput(uint256 _index) external view returns (bytes32);\\n\\n    /// @notice returns number of inputs on correct inbox\\n    /// @return number of inputs of non active inbox\\n    function getNumberOfInputs() external view returns (uint256);\\n\\n    /// @notice returns active current inbox index\\n    /// @return index of current active inbox\\n    function getCurrentInbox() external view returns (uint256);\\n\\n    /// @notice called whenever there is a new input accumulation epoch\\n    /// @dev has to be  called even if new input accumulation happens\\n    ///      implicitly due to a new epoch\\n    function onNewInputAccumulation() external;\\n\\n    /// @notice called when a new epoch begins, clears correct input box\\n    function onNewEpoch() external;\\n\\n    /// @notice input added\\n    /// @param _epochNumber which epoch this input belongs to\\n    /// @param _inputIndex index of the input just added\\n    /// @param _sender msg.sender\\n    /// @param _timestamp block.timestamp\\n    /// @param _input input data\\n    event InputAdded(\\n        uint256 indexed _epochNumber,\\n        uint256 indexed _inputIndex,\\n        address _sender,\\n        uint256 _timestamp,\\n        bytes _input\\n    );\\n}\\n\",\"keccak256\":\"0x77b327595fd5b8a5d16f4cb42187068288c82d21f17581117d07f449d7b75939\",\"license\":\"Apache-2.0\"},\"contracts/InputImpl.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Input Implementation\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Input.sol\\\";\\nimport \\\"./Rollups.sol\\\";\\n\\ncontract InputImpl is Input {\\n    Rollups immutable rollups; // rollups contract using this input contract\\n\\n    // always needs to keep track of two input boxes:\\n    // 1 for the input accumulation of next epoch\\n    // and 1 for the messages during current epoch. To save gas we alternate\\n    // between inputBox0 and inputBox1\\n    bytes32[] inputBox0;\\n    bytes32[] inputBox1;\\n\\n    uint256 immutable inputDriveSize; // size of input flashdrive\\n    uint256 currentInputBox;\\n\\n    /// @param _rollups address of rollups contract that will manage inboxes\\n    /// @param _log2Size size of the input drive of the machine\\n    constructor(address _rollups, uint256 _log2Size) {\\n        require(_log2Size >= 3 && _log2Size <= 64, \\\"log size: [3,64]\\\");\\n\\n        rollups = Rollups(_rollups);\\n        inputDriveSize = (1 << _log2Size);\\n    }\\n\\n    /// @notice add input to processed by next epoch\\n    /// @param _input input to be understood by offchain machine\\n    /// @dev offchain code is responsible for making sure\\n    ///      that input size is power of 2 and multiple of 8 since\\n    // the offchain machine has a 8 byte word\\n    function addInput(bytes calldata _input) public override returns (bytes32) {\\n        require(\\n            _input.length > 0 && _input.length <= inputDriveSize,\\n            \\\"input len: (0,driveSize]\\\"\\n        );\\n\\n        // notifyInput returns true if that input\\n        // belongs to a new epoch\\n        if (rollups.notifyInput()) {\\n            swapInputBox();\\n        }\\n\\n        // points to correct inputBox\\n        bytes32[] storage inputBox = currentInputBox == 0 ? inputBox0 : inputBox1;\\n\\n        // keccak 64 bytes into 32 bytes\\n        bytes32 keccakMetadata =\\n            keccak256(\\n                abi.encode(\\n                    msg.sender,\\n                    block.number,\\n                    block.timestamp,\\n                    rollups.getCurrentEpoch(), // epoch index\\n                    inputBox.length // input index\\n                )\\n            );\\n\\n        bytes32 keccakInput = keccak256(_input);\\n\\n        bytes32 inputHash = keccak256(abi.encode(keccakMetadata, keccakInput));\\n\\n        // add input to correct inbox\\n        inputBox.push(inputHash);\\n\\n        emit InputAdded(\\n            rollups.getCurrentEpoch(),\\n            inputBox.length - 1,\\n            msg.sender,\\n            block.timestamp,\\n            _input\\n        );\\n\\n        return inputHash;\\n    }\\n\\n    /// @notice get input inside inbox of currently proposed claim\\n    /// @param _index index of input inside that inbox\\n    /// @return hash of input at index _index\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getInput(uint256 _index) public view override returns (bytes32) {\\n        return currentInputBox == 0 ? inputBox1[_index] : inputBox0[_index];\\n    }\\n\\n    /// @notice get number of inputs inside inbox of currently proposed claim\\n    /// @return number of inputs on that input box\\n    /// @dev currentInputBox being zero means that the inputs for\\n    ///      the claimed epoch are on input box one\\n    function getNumberOfInputs() public view override returns (uint256) {\\n        return currentInputBox == 0 ? inputBox1.length : inputBox0.length;\\n    }\\n\\n    /// @notice get inbox currently receiveing inputs\\n    /// @return input inbox currently receiveing inputs\\n    function getCurrentInbox() public view override returns (uint256) {\\n        return currentInputBox;\\n    }\\n\\n    /// @notice called when a new input accumulation phase begins\\n    ///         swap inbox to receive inputs for upcoming epoch\\n    /// @dev can only be called by Rollups contract\\n    function onNewInputAccumulation() public override {\\n        onlyRollups();\\n        swapInputBox();\\n    }\\n\\n    /// @notice called when a new epoch begins, clears deprecated inputs\\n    /// @dev can only be called by Rollups contract\\n    function onNewEpoch() public override {\\n        // clear input box for new inputs\\n        // the current input box should be accumulating inputs\\n        // for the new epoch already. So we clear the other one.\\n        onlyRollups();\\n        currentInputBox == 0 ? delete inputBox1 : delete inputBox0;\\n    }\\n\\n    /// @notice check if message sender is Rollups\\n    function onlyRollups() internal view {\\n        require(msg.sender == address(rollups), \\\"Only rollups\\\");\\n    }\\n\\n    /// @notice changes current input box\\n    function swapInputBox() internal {\\n        currentInputBox == 0 ? currentInputBox = 1 : currentInputBox = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x5bfff1c97a0317a02ac73bf7d85cafecdf6e44901021eb9690afca831abee0ef\",\"license\":\"Apache-2.0\"},\"contracts/Output.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Output\\npragma solidity >=0.7.0;\\n\\ninterface Output {\\n    /// @param _epochIndex which epoch the output belongs to\\n    /// @param _inputIndex which input, inside the epoch, the output belongs to\\n    /// @param _outputIndex index of output inside the input\\n    /// @param _outputMetadataArrayDriveHash hash of the output's metadata drive where this output is in\\n    /// @param _epochVoucherDriveHash merkle root of all epoch's voucher metadata drive hashes\\n    /// @param _epochNoticeDriveHash hash of NoticeMetadataArrayDrive\\n    /// @param _epochMachineFinalState hash of the machine state claimed this epoch\\n    /// @param _outputMetadataProof proof that this output's metadata is in meta data drive\\n    /// @param _epochOutputDriveProof proof that this output metadata drive is in epoch's Output drive\\n    struct OutputValidityProof {\\n        uint256 epochIndex;\\n        uint256 inputIndex;\\n        uint256 outputIndex;\\n        bytes32 outputMetadataArrayDriveHash;\\n        bytes32 epochVoucherDriveHash;\\n        bytes32 epochNoticeDriveHash;\\n        bytes32 epochMachineFinalState;\\n        bytes32[] outputMetadataProof;\\n        bytes32[] epochOutputDriveProof;\\n    }\\n\\n    /// @notice executes voucher\\n    /// @param _destination address that will execute the payload\\n    /// @param _payload payload to be executed by destination\\n    /// @param _v validity proof for this encoded voucher\\n    /// @return true if voucher was executed successfully\\n    /// @dev  vouchers can only be executed once\\n    function executeVoucher(\\n        address _destination,\\n        bytes calldata _payload,\\n        OutputValidityProof calldata _v\\n    ) external returns (bool);\\n\\n    /// @notice called by rollups when an epoch is finalized\\n    /// @param _epochHash hash of finalized epoch\\n    /// @dev an epoch being finalized means that its vouchers can be called\\n    function onNewEpoch(bytes32 _epochHash) external;\\n\\n    /// @notice get number of finalized epochs\\n    function getNumberOfFinalizedEpochs() external view returns (uint256);\\n\\n    /// @notice get log2 size of voucher metadata drive\\n    function getVoucherMetadataLog2Size()\\n        external\\n        pure\\n        returns (uint256);\\n\\n    /// @notice get log2 size of epoch voucher drive\\n    function getEpochVoucherLog2Size()\\n        external\\n        pure\\n        returns (uint256);\\n\\n    /// @notice get log2 size of notice metadata drive\\n    function getNoticeMetadataLog2Size()\\n        external\\n        pure\\n        returns (uint256);\\n\\n    /// @notice get log2 size of epoch notice drive\\n    function getEpochNoticeLog2Size()\\n        external\\n        pure\\n        returns (uint256);\\n\\n    event VoucherExecuted(uint256 voucherPosition);\\n}\\n\",\"keccak256\":\"0xe3434f190b59d71f0deab32ee8d29df20a818758bc5a540ac69e0a128d3f2992\",\"license\":\"Apache-2.0\"},\"contracts/OutputImpl.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Output Implementation\\npragma solidity ^0.8.0;\\n\\nimport \\\"@cartesi/util/contracts/Bitmask.sol\\\";\\nimport \\\"@cartesi/util/contracts/Merkle.sol\\\";\\n\\nimport \\\"./Output.sol\\\";\\n\\ncontract OutputImpl is Output {\\n    // Here we only need 248 bits as keys in the mapping, but we use 256 bits for gas optimization\\n    using Bitmask for mapping(uint256 => uint256);\\n\\n    uint256 constant KECCAK_LOG2_SIZE = 5; // keccak log2 size\\n\\n    // max size of voucher metadata drive 32 * (2^16) bytes\\n    uint256 constant VOUCHER_METADATA_LOG2_SIZE = 21;\\n    // max size of epoch voucher drive 32 * (2^32) bytes\\n    uint256 constant EPOCH_VOUCHER_LOG2_SIZE = 37;\\n\\n    // max size of notice metadata drive 32 * (2^16) bytes\\n    uint256 constant NOTICE_METADATA_LOG2_SIZE = 21;\\n    // max size of epoch notice drive 32 * (2^32) bytes\\n    uint256 constant EPOCH_NOTICE_LOG2_SIZE = 37;\\n\\n    address immutable rollups; // rollups contract using this validator\\n    mapping(uint256 => uint256) internal voucherBitmask;\\n    bytes32[] epochHashes;\\n\\n    bool lock; //reentrancy lock\\n\\n    /// @notice functions modified by noReentrancy are not subject to recursion\\n    modifier noReentrancy() {\\n        require(!lock, \\\"reentrancy not allowed\\\");\\n        lock = true;\\n        _;\\n        lock = false;\\n    }\\n\\n    /// @notice functions modified by onlyRollups will only be executed if\\n    // they're called by Rollups contract, otherwise it will throw an exception\\n    modifier onlyRollups {\\n        require(msg.sender == rollups, \\\"Only rollups\\\");\\n        _;\\n    }\\n\\n    // @notice creates OutputImpl contract\\n    // @params _rollups address of rollupscontract\\n    constructor(address _rollups)\\n    {\\n        rollups = _rollups;\\n    }\\n\\n    /// @notice executes voucher\\n    /// @param _encodedVoucher encoded voucher mocking the behaviour\\n    //          of abi.encode(address _destination, bytes _payload)\\n    /// @param _v validity proof for this encoded voucher\\n    /// @return true if voucher was executed successfully\\n    /// @dev  vouchers can only be executed once\\n    function executeVoucher(\\n        address _destination,\\n        bytes calldata _payload,\\n        OutputValidityProof calldata _v\\n    ) public override noReentrancy returns (bool) {\\n        bytes memory encodedVoucher = abi.encode(_destination, _payload);\\n\\n        // check if validity proof matches the voucher provided\\n        isValidVoucherProof(encodedVoucher, epochHashes[_v.epochIndex], _v);\\n\\n        uint256 voucherPosition =\\n            getBitMaskPosition(_v.outputIndex, _v.inputIndex, _v.epochIndex);\\n\\n        // check if voucher has been executed\\n        require(\\n            !voucherBitmask.getBit(voucherPosition),\\n            \\\"re-execution not allowed\\\"\\n        );\\n\\n        // execute voucher\\n        (bool succ, ) = address(_destination).call(_payload);\\n\\n        // if properly executed, mark it as executed and emit event\\n        if (succ) {\\n            voucherBitmask.setBit(voucherPosition, true);\\n            emit VoucherExecuted(voucherPosition);\\n        }\\n\\n        return succ;\\n    }\\n\\n    /// @notice called by rollups when an epoch is finalized\\n    /// @param _epochHash hash of finalized epoch\\n    /// @dev an epoch being finalized means that its vouchers can be called\\n    function onNewEpoch(bytes32 _epochHash) public override onlyRollups {\\n        epochHashes.push(_epochHash);\\n    }\\n\\n    /// @notice functions modified by isValidProof will only be executed if\\n    //  the validity proof is valid\\n    //  @dev _epochOutputDriveHash must be _v.epochVoucherDriveHash or\\n    //                                  or _v.epochNoticeDriveHash\\n    function isValidProof(\\n        bytes memory _encodedOutput,\\n        bytes32 _epochHash,\\n        bytes32 _epochOutputDriveHash,\\n        uint256 _epochOutputLog2Size,\\n        uint256 _outputMetadataLog2Size,\\n        OutputValidityProof calldata _v\\n    ) internal pure returns (bool) {\\n        // prove that outputs hash is represented in a finalized epoch\\n        require(\\n            keccak256(\\n                abi.encodePacked(\\n                    _v.epochVoucherDriveHash,\\n                    _v.epochNoticeDriveHash,\\n                    _v.epochMachineFinalState\\n                )\\n            ) == _epochHash,\\n            \\\"epochHash incorrect\\\"\\n        );\\n\\n        // prove that output metadata drive is contained in epoch's output drive\\n        require(\\n            Merkle.getRootAfterReplacementInDrive(\\n                getIntraDrivePosition(_v.inputIndex, KECCAK_LOG2_SIZE),\\n                KECCAK_LOG2_SIZE,\\n                _epochOutputLog2Size,\\n                keccak256(abi.encodePacked(_v.outputMetadataArrayDriveHash)),\\n                _v.epochOutputDriveProof\\n            ) == _epochOutputDriveHash,\\n            \\\"epochOutputDriveHash incorrect\\\"\\n        );\\n\\n        // The hash of the output is converted to bytes (abi.encode) and\\n        // treated as data. The metadata output drive stores that data while\\n        // being indifferent to its contents. To prove that the received\\n        // output is contained in the metadata output drive we need to\\n        // prove that x, where:\\n        // x = keccak(\\n        //          keccak(\\n        //              keccak(hashOfOutput[0:7]),\\n        //              keccak(hashOfOutput[8:15])\\n        //          ),\\n        //          keccak(\\n        //              keccak(hashOfOutput[16:23]),\\n        //              keccak(hashOfOutput[24:31])\\n        //          )\\n        //     )\\n        // is contained in it. We can't simply use hashOfOutput because the\\n        // log2size of the leaf is three (8 bytes) not  five (32 bytes)\\n        bytes32 merkleRootOfHashOfOutput =\\n            Merkle.getMerkleRootFromBytes(\\n                abi.encodePacked(keccak256(_encodedOutput)),\\n                KECCAK_LOG2_SIZE\\n            );\\n\\n        // prove that merkle root hash of bytes(hashOfOutput) is contained\\n        // in the output metadata array drive\\n        require(\\n            Merkle.getRootAfterReplacementInDrive(\\n                getIntraDrivePosition(_v.outputIndex, KECCAK_LOG2_SIZE),\\n                KECCAK_LOG2_SIZE,\\n                _outputMetadataLog2Size,\\n                merkleRootOfHashOfOutput,\\n                _v.outputMetadataProof\\n            ) == _v.outputMetadataArrayDriveHash,\\n            \\\"outputMetadataArrayDriveHash incorrect\\\"\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @notice functions modified by isValidVoucherProof will only be executed if\\n    //  the validity proof is valid\\n    function isValidVoucherProof(\\n        bytes memory _encodedVoucher,\\n        bytes32 _epochHash,\\n        OutputValidityProof calldata _v\\n    )\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return isValidProof(\\n            _encodedVoucher,\\n            _epochHash,\\n            _v.epochVoucherDriveHash,\\n            EPOCH_VOUCHER_LOG2_SIZE,\\n            VOUCHER_METADATA_LOG2_SIZE,\\n            _v\\n        );\\n    }\\n\\n    /// @notice functions modified by isValidNoticeProof will only be executed if\\n    //  the validity proof is valid\\n    function isValidNoticeProof(\\n        bytes memory _encodedNotice,\\n        bytes32 _epochHash,\\n        OutputValidityProof calldata _v\\n    )\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return isValidProof(\\n            _encodedNotice,\\n            _epochHash,\\n            _v.epochNoticeDriveHash,\\n            EPOCH_NOTICE_LOG2_SIZE,\\n            NOTICE_METADATA_LOG2_SIZE,\\n            _v\\n        );\\n    }\\n\\n    /// @notice get voucher position on bitmask\\n    /// @param _voucher of voucher inside the input\\n    /// @param _input which input, inside the epoch, the voucher belongs to\\n    /// @param _epoch which epoch the voucher belongs to\\n    /// @return position of that voucher on bitmask\\n    function getBitMaskPosition(\\n        uint256 _voucher,\\n        uint256 _input,\\n        uint256 _epoch\\n    ) public pure returns (uint256) {\\n        // voucher * 2 ** 128 + input * 2 ** 64 + epoch\\n        // this can't overflow because its impossible to have > 2**128 vouchers\\n        return (((_voucher << 128) | (_input << 64)) | _epoch);\\n    }\\n\\n    /// @notice returns the position of a intra drive on a drive\\n    //          with  contents with the same size\\n    /// @param _index index of intra drive\\n    /// @param _log2Size of intra drive\\n    function getIntraDrivePosition(uint256 _index, uint256 _log2Size)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (_index << _log2Size);\\n    }\\n\\n    /// @notice get number of finalized epochs\\n    function getNumberOfFinalizedEpochs()\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return epochHashes.length;\\n    }\\n\\n    /// @notice get log2 size of voucher metadata drive\\n    function getVoucherMetadataLog2Size()\\n        public\\n        pure\\n        override\\n        returns (uint256)\\n    {\\n        return VOUCHER_METADATA_LOG2_SIZE;\\n    }\\n\\n    /// @notice get log2 size of epoch voucher drive\\n    function getEpochVoucherLog2Size()\\n        public\\n        pure\\n        override\\n        returns (uint256)\\n    {\\n        return EPOCH_VOUCHER_LOG2_SIZE;\\n    }\\n\\n    /// @notice get log2 size of notice metadata drive\\n    function getNoticeMetadataLog2Size()\\n        public\\n        pure\\n        override\\n        returns (uint256)\\n    {\\n        return NOTICE_METADATA_LOG2_SIZE;\\n    }\\n\\n    /// @notice get log2 size of epoch notice drive\\n    function getEpochNoticeLog2Size()\\n        public\\n        pure\\n        override\\n        returns (uint256)\\n    {\\n        return EPOCH_NOTICE_LOG2_SIZE;\\n    }\\n}\\n\",\"keccak256\":\"0xb9f9853a59073d3c474bfae2eb1aa3d8cb9e9a702e05e17e076e5214392e68d2\",\"license\":\"Apache-2.0\"},\"contracts/Rollups.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Interface Rollups contract\\npragma solidity >=0.7.0;\\n\\nimport \\\"./Input.sol\\\";\\nimport \\\"./Output.sol\\\";\\nimport \\\"./ValidatorManager.sol\\\";\\n\\ninterface Rollups {\\n    // InputAccumulation - Inputs being accumulated for currrent epoch\\n    // AwaitingConsensus - No disagreeing claims (or no claims)\\n    // AwaitingDispute - Waiting for dispute to be over\\n    // inputs received during InputAccumulation will be included in the\\n    // current epoch. Inputs received while WaitingClaims or ChallengesInProgress\\n    // are accumulated for the next epoch\\n    enum Phase {InputAccumulation, AwaitingConsensus, AwaitingDispute}\\n\\n    /// @notice claim the result of current epoch\\n    /// @param _epochHash hash of epoch\\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\\n    //       and that claim != bytes32(0)\\n    /// TODO: add signatures for aggregated claims\\n    function claim(bytes32 _epochHash) external;\\n\\n    /// @notice finalize epoch after timeout\\n    /// @dev can only be called if challenge period is over\\n    function finalizeEpoch() external;\\n\\n    /// @notice called when new input arrives, manages the phase changes\\n    /// @dev can only be called by input contract\\n    function notifyInput() external returns (bool);\\n\\n    /// @notice called when a dispute is resolved by the dispute manager\\n    /// @param _winner winner of dispute\\n    /// @param _loser lose of sipute\\n    /// @param _winningClaim initial claim of winning validator\\n    /// @dev can only by the dispute contract\\n    function resolveDispute(\\n        address payable _winner,\\n        address payable _loser,\\n        bytes32 _winningClaim\\n    ) external;\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    //       of finalized epochs array, else there are two epochs two non\\n    //       finalized epochs, one awaiting consensus/dispute and another\\n    //      accumulating input\\n    function getCurrentEpoch() external view returns (uint256);\\n\\n    /// @notice returns address of input contract\\n    function getInputAddress() external view returns (address);\\n\\n    /// @notice returns address of output contract\\n    function getOutputAddress() external view returns (address);\\n\\n    /// @notice returns address of validator manager contract\\n    function getValidatorManagerAddress() external view returns (address);\\n\\n    /// @notice returns address of dispute manager contract\\n    function getDisputeManagerAddress() external view returns (address);\\n\\n    // events\\n\\n    /// @notice contract created\\n    /// @param _input address of input contract\\n    /// @param _output address of output contract\\n    /// @param _validatorManager address of validatorManager contract\\n    /// @param _disputeManager address of disputeManager contract\\n    /// @param _inputDuration duration of input accumulation phase in seconds\\n    /// @param _challengePeriod duration of challenge period in seconds\\n    event RollupsCreated(\\n        address _input,\\n        address _output,\\n        address _validatorManager,\\n        address _disputeManager,\\n        uint256 _inputDuration,\\n        uint256 _challengePeriod\\n    );\\n\\n    /// @notice claim submitted\\n    /// @param _epochHash claim being submitted by this epoch\\n    /// @param _claimer address of current claimer\\n    /// @param _epochNumber number of the epoch being submitted\\n    event Claim(uint256 indexed _epochNumber, address _claimer, bytes32 _epochHash);\\n\\n    /// @notice epoch finalized\\n    /// @param _epochNumber number of the epoch being finalized\\n    /// @param _epochHash claim being submitted by this epoch\\n    event FinalizeEpoch(uint256 indexed _epochNumber, bytes32 _epochHash);\\n\\n    /// @notice dispute resolved\\n    /// @param _winner winner of dispute\\n    /// @param _loser loser of dispute\\n    /// @param _winningClaim initial claim of winning validator\\n    event ResolveDispute(\\n        address _winner,\\n        address _loser,\\n        bytes32 _winningClaim\\n    );\\n\\n    /// @notice phase change\\n    /// @param _newPhase new phase\\n    event PhaseChange(Phase _newPhase);\\n}\\n\",\"keccak256\":\"0xbe254b4a01ae4b5e77d300c8cb456ac5ea8fa162a028b824c0987ba8524aae7a\",\"license\":\"Apache-2.0\"},\"contracts/RollupsImpl.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Rollups Impl\\npragma solidity ^0.8.0;\\n\\nimport \\\"./InputImpl.sol\\\";\\nimport \\\"./OutputImpl.sol\\\";\\nimport \\\"./ValidatorManagerImpl.sol\\\";\\nimport \\\"./Rollups.sol\\\";\\nimport \\\"./DisputeManagerImpl.sol\\\";\\n\\ncontract RollupsImpl is Rollups {\\n    ////\\n    //                             All claims agreed OR challenge period ended\\n    //                              functions: claim() or finalizeEpoch()\\n    //                        +--------------------------------------------------+\\n    //                        |                                                  |\\n    //               +--------v-----------+   new input after IPAD     +---------+----------+\\n    //               |                    +--------------------------->+                    |\\n    //   START  ---> | Input Accumulation |   firt claim after IPAD    | Awaiting Consensus |\\n    //               |                    +--------------------------->+                    |\\n    //               +-+------------------+                            +-----------------+--+\\n    //                 ^                                                                 ^  |\\n    //                 |                                              dispute resolved   |  |\\n    //                 |  dispute resolved                            before challenge   |  |\\n    //                 |  after challenge     +--------------------+  period ended       |  |\\n    //                 |  period ended        |                    +---------------------+  |\\n    //                 +----------------------+  Awaiting Dispute  |                        |\\n    //                                        |                    +<-----------------------+\\n    //                                        +--------------------+    conflicting claim\\n    ///\\n\\n    InputImpl public input; // contract responsible for inputs\\n    OutputImpl public output; // contract responsible for outputs\\n    ValidatorManagerImpl public validatorManager; // contract responsible for validators\\n    DisputeManagerImpl public disputeManager; // contract responsible for dispute resolution\\n\\n    struct StorageVar {\\n        uint32 inputDuration; // duration of input accumulation phase in seconds\\n        uint32 challengePeriod; // duration of challenge period in seconds\\n        uint32 inputAccumulationStart; // timestamp when current input accumulation phase started\\n        uint32 sealingEpochTimestamp; // timestamp on when a proposed epoch (claim) becomes challengeable\\n        uint32 currentPhase_int; // current phase in integer form\\n    }\\n    StorageVar public storageVar;\\n\\n    /// @notice functions modified by onlyInputContract can only be called\\n    // by input contract\\n    modifier onlyInputContract {\\n        require(msg.sender == address(input), \\\"only Input Contract\\\");\\n        _;\\n    }\\n\\n    /// @notice functions modified by onlyDisputeContract can only be called\\n    // by dispute contract\\n    modifier onlyDisputeContract {\\n        require(msg.sender == address(disputeManager), \\\"only Dispute Contract\\\");\\n        _;\\n    }\\n\\n    /// @notice creates contract\\n    /// @param _inputDuration duration of input accumulation phase in seconds\\n    /// @param _challengePeriod duration of challenge period in seconds\\n    /// @param _inputLog2Size size of the input drive in this machine\\n    /// @param _validators initial validator set\\n    constructor(\\n        uint256 _inputDuration,\\n        uint256 _challengePeriod,\\n        // input constructor variables\\n        uint256 _inputLog2Size,\\n        // validator manager constructor variables\\n        address payable[] memory _validators\\n    ) {\\n        input = new InputImpl(address(this), _inputLog2Size);\\n        output = new OutputImpl(address(this));\\n        validatorManager = new ValidatorManagerImpl(address(this), _validators);\\n        disputeManager = new DisputeManagerImpl(address(this));\\n\\n        storageVar = StorageVar(\\n            uint32(_inputDuration),\\n            uint32(_challengePeriod),\\n            uint32(block.timestamp),\\n            0,\\n            uint32(Phase.InputAccumulation)\\n        );\\n\\n        emit RollupsCreated(\\n            address(input),\\n            address(output),\\n            address(validatorManager),\\n            address(disputeManager),\\n            _inputDuration,\\n            _challengePeriod\\n        );\\n    }\\n\\n    /// @notice claim the result of current epoch\\n    /// @param _epochHash hash of epoch\\n    /// @dev ValidatorManager makes sure that msg.sender is allowed\\n    //       and that claim != bytes32(0)\\n    /// TODO: add signatures for aggregated claims\\n    function claim(bytes32 _epochHash) public override {\\n        ValidatorManager.Result result;\\n        bytes32[2] memory claims;\\n        address payable[2] memory claimers;\\n\\n        Phase currentPhase = Phase(storageVar.currentPhase_int);\\n        uint256 inputAccumulationStart = storageVar.inputAccumulationStart;\\n        uint256 inputDuration = storageVar.inputDuration;\\n\\n        if (\\n            currentPhase == Phase.InputAccumulation &&\\n            block.timestamp > inputAccumulationStart + inputDuration\\n        ) {\\n            currentPhase = Phase.AwaitingConsensus;\\n            storageVar.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n            emit PhaseChange(Phase.AwaitingConsensus);\\n\\n            // warns input of new epoch\\n            input.onNewInputAccumulation();\\n            // update timestamp of sealing epoch proposal\\n            storageVar.sealingEpochTimestamp = uint32(block.timestamp);\\n        }\\n\\n        require(\\n            currentPhase == Phase.AwaitingConsensus,\\n            \\\"Phase != AwaitingConsensus\\\"\\n        );\\n        (result, claims, claimers) = validatorManager.onClaim(\\n            payable(msg.sender),\\n            _epochHash\\n        );\\n\\n        // emit the claim event before processing it\\n        // so if the epoch is finalized in this claim (consensus)\\n        // the number of final epochs doesnt gets contaminated\\n        emit Claim(output.getNumberOfFinalizedEpochs(), msg.sender, _epochHash);\\n\\n        resolveValidatorResult(result, claims, claimers);\\n    }\\n\\n    /// @notice finalize epoch after timeout\\n    /// @dev can only be called if challenge period is over\\n    function finalizeEpoch() public override {\\n        Phase currentPhase = Phase(storageVar.currentPhase_int);\\n        require(\\n            currentPhase == Phase.AwaitingConsensus,\\n            \\\"Phase != Awaiting Consensus\\\"\\n        );\\n\\n        uint256 sealingEpochTimestamp = storageVar.sealingEpochTimestamp;\\n        uint256 challengePeriod = storageVar.challengePeriod;\\n        require(\\n            block.timestamp > sealingEpochTimestamp + challengePeriod,\\n            \\\"Challenge period not over\\\"\\n        );\\n\\n        require(\\n            validatorManager.getCurrentClaim() != bytes32(0),\\n            \\\"No Claim to be finalized\\\"\\n        );\\n\\n        startNewEpoch();\\n    }\\n\\n    /// @notice called when new input arrives, manages the phase changes\\n    /// @dev can only be called by input contract\\n    function notifyInput() public override onlyInputContract returns (bool) {\\n        Phase currentPhase = Phase(storageVar.currentPhase_int);\\n        uint256 inputAccumulationStart = storageVar.inputAccumulationStart;\\n        uint256 inputDuration = storageVar.inputDuration;\\n\\n        if (\\n            currentPhase == Phase.InputAccumulation &&\\n            block.timestamp > inputAccumulationStart + inputDuration\\n        ) {\\n            storageVar.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n            emit PhaseChange(Phase.AwaitingConsensus);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @notice called when a dispute is resolved by the dispute manager\\n    /// @param _winner winner of dispute\\n    /// @param _loser loser of dispute\\n    /// @param _winningClaim initial claim of winning validator\\n    /// @dev can only be called by the dispute contract\\n    function resolveDispute(\\n        address payable _winner,\\n        address payable _loser,\\n        bytes32 _winningClaim\\n    ) public override onlyDisputeContract {\\n        ValidatorManager.Result result;\\n        bytes32[2] memory claims;\\n        address payable[2] memory claimers;\\n\\n        (result, claims, claimers) = validatorManager.onDisputeEnd(\\n            _winner,\\n            _loser,\\n            _winningClaim\\n        );\\n\\n        // restart challenge period\\n        storageVar.sealingEpochTimestamp = uint32(block.timestamp);\\n\\n        emit ResolveDispute(_winner, _loser, _winningClaim);\\n        resolveValidatorResult(result, claims, claimers);\\n    }\\n\\n    /// @notice starts new epoch\\n    function startNewEpoch() internal {\\n        // reset input accumulation start and deactivate challenge period start\\n        storageVar.currentPhase_int = uint32(Phase.InputAccumulation);\\n        emit PhaseChange(Phase.InputAccumulation);\\n        storageVar.inputAccumulationStart = uint32(block.timestamp);\\n        storageVar.sealingEpochTimestamp = type(uint32).max;\\n\\n        bytes32 finalClaim = validatorManager.onNewEpoch();\\n\\n        // emit event before finalized epoch is added to the Output contract's storage\\n        emit FinalizeEpoch(output.getNumberOfFinalizedEpochs(), finalClaim);\\n\\n        output.onNewEpoch(finalClaim);\\n        input.onNewEpoch();\\n    }\\n\\n    /// @notice resolve results returned by validator manager\\n    /// @param _result result from claim or dispute operation\\n    /// @param _claims array of claims in case of new conflict\\n    /// @param _claimers array of claimers in case of new conflict\\n    function resolveValidatorResult(\\n        ValidatorManager.Result _result,\\n        bytes32[2] memory _claims,\\n        address payable[2] memory _claimers\\n    ) internal {\\n        if (_result == ValidatorManager.Result.NoConflict) {\\n            Phase currentPhase = Phase(storageVar.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingConsensus) {\\n                storageVar.currentPhase_int = uint32(Phase.AwaitingConsensus);\\n                emit PhaseChange(Phase.AwaitingConsensus);\\n            }\\n        } else if (_result == ValidatorManager.Result.Consensus) {\\n            startNewEpoch();\\n        } else {\\n            // for the case when _result == ValidatorManager.Result.Conflict\\n            Phase currentPhase = Phase(storageVar.currentPhase_int);\\n            if (currentPhase != Phase.AwaitingDispute) {\\n                storageVar.currentPhase_int = uint32(Phase.AwaitingDispute);\\n                emit PhaseChange(Phase.AwaitingDispute);\\n            }\\n            disputeManager.initiateDispute(_claims, _claimers);\\n        }\\n    }\\n\\n    /// @notice returns index of current (accumulating) epoch\\n    /// @return index of current epoch\\n    /// @dev if phase is input accumulation, then the epoch number is length\\n    //       of finalized epochs array, else there are two non finalized epochs,\\n    //       one awaiting consensus/dispute and another accumulating input\\n\\n    function getCurrentEpoch() public view override returns (uint256) {\\n        uint256 finalizedEpochs = output.getNumberOfFinalizedEpochs();\\n\\n        Phase currentPhase = Phase(storageVar.currentPhase_int);\\n\\n        return\\n            currentPhase == Phase.InputAccumulation\\n                ? finalizedEpochs\\n                : finalizedEpochs + 1;\\n    }\\n\\n    /// @notice returns address of input contract\\n    function getInputAddress() public view override returns (address) {\\n        return address(input);\\n    }\\n\\n    /// @notice returns address of output contract\\n    function getOutputAddress() public view override returns (address) {\\n        return address(output);\\n    }\\n\\n    /// @notice returns address of validator manager contract\\n    function getValidatorManagerAddress()\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        return address(validatorManager);\\n    }\\n\\n    /// @notice returns address of dispute manager contract\\n    function getDisputeManagerAddress() public view override returns (address) {\\n        return address(disputeManager);\\n    }\\n\\n    /// @notice returns the current phase\\n    function getCurrentPhase() public view returns (Phase) {\\n        Phase currentPhase = Phase(storageVar.currentPhase_int);\\n        return currentPhase;\\n    }\\n\\n    /// @notice returns the input accumulation start timestamp\\n    function getInputAccumulationStart() public view returns (uint256) {\\n        uint256 inputAccumulationStart = storageVar.inputAccumulationStart;\\n        return inputAccumulationStart;\\n    }\\n}\\n\",\"keccak256\":\"0x47afc7761a6c5312591927ef36469cfbf1caa36b33dc6fd010e699c94d8db4ba\",\"license\":\"Apache-2.0\"},\"contracts/ValidatorManager.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager\\npragma solidity >=0.7.0;\\n\\n// TODO: What is the incentive for validators to not just copy the first claim that arrived?\\ninterface ValidatorManager {\\n    // NoConflict - No conflicting claims or consensus\\n    // Consensus - All validators had equal claims\\n    // Conflict - Claim is conflicting with previous one\\n    enum Result {NoConflict, Consensus, Conflict}\\n\\n    // @notice called when a claim is received by rollups\\n    // @params _sender address of sender of that claim\\n    // @params _claim claim received by rollups\\n    // @returns result of claim, signaling current state of claims\\n    function onClaim(address payable _sender, bytes32 _claim)\\n        external\\n        returns (\\n            Result,\\n            bytes32[2] memory claims,\\n            address payable[2] memory claimers\\n        );\\n\\n    // @notice called when a dispute ends in rollups\\n    // @params _winner address of dispute winner\\n    // @params _loser address of dispute loser\\n    // @returns result of dispute being finished\\n    function onDisputeEnd(\\n        address payable _winner,\\n        address payable _loser,\\n        bytes32 _winningClaim\\n    )\\n        external\\n        returns (\\n            Result,\\n            bytes32[2] memory claims,\\n            address payable[2] memory claimers\\n        );\\n\\n    // @notice called when a new epoch starts\\n    function onNewEpoch() external returns (bytes32);\\n\\n    // @notice get current claim\\n    function getCurrentClaim() external view returns (bytes32);\\n\\n    // @notice emitted on Claim received\\n    event ClaimReceived(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    // @notice emitted on Dispute end\\n    event DisputeEnded(\\n        Result result,\\n        bytes32[2] claims,\\n        address payable[2] validators\\n    );\\n\\n    // @notice emitted on new Epoch\\n    event NewEpoch(bytes32 claim);\\n}\\n\",\"keccak256\":\"0xd294eb8264d00d3c714ab8cbe058556d83f73089bc539ca5f48f095dd6e475f7\",\"license\":\"Apache-2.0\"},\"contracts/ValidatorManagerImpl.sol\":{\"content\":\"// Copyright 2021 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Validator Manager Implementation\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ValidatorManager.sol\\\";\\n\\ncontract ValidatorManagerImpl is ValidatorManager {\\n    address immutable rollups; // rollups contract using this validator\\n    bytes32 currentClaim; // current claim - first claim of this epoch\\n    address payable[] validators; // current validators\\n\\n    // A bit set for each validator that agrees with current claim,\\n    // on their respective positions\\n    uint32 claimAgreementMask;\\n\\n    // Every validator who should approve (in order to reach consensus) will have a one set on this mask\\n    // This mask is updated if a validator is added or removed\\n    uint32 consensusGoalMask;\\n\\n    // @notice functions modified by onlyRollups will only be executed if\\n    // they're called by Rollups contract, otherwise it will throw an exception\\n    function onlyRollups() internal view {\\n        require(msg.sender == rollups, \\\"Only rollups\\\");\\n    }\\n\\n    // @notice populates validators array and creates a consensus mask\\n    // @params _rollups address of rollupscontract\\n    // @params _validators initial validator set\\n    // @dev validators have to be unique, if the same validator is added twice\\n    //      consensus will never be reached\\n    constructor(address _rollups, address payable[] memory _validators) {\\n        rollups = _rollups;\\n        validators = _validators;\\n\\n        // create consensus goal, represents the scenario where all\\n        // all validators claimed and agreed\\n        consensusGoalMask = updateConsensusGoalMask();\\n    }\\n\\n    // @notice called when a claim is received by rollups\\n    // @params _sender address of sender of that claim\\n    // @params _claim claim received by rollups\\n    // @return result of claim, Consensus | NoConflict | Conflict\\n    // @return [currentClaim, conflicting claim] if there is Conflict\\n    //         [currentClaim, bytes32(0)] if there is Consensus\\n    //         [bytes32(0), bytes32(0)] if there is NoConflcit\\n    // @return [claimer1, claimer2] if there is  Conflcit\\n    //         [claimer1, address(0)] if there is Consensus\\n    //         [address(0), address(0)] if there is NoConflcit\\n    function onClaim(address payable _sender, bytes32 _claim)\\n        public\\n        override\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        onlyRollups();\\n        require(_claim != bytes32(0), \\\"empty claim\\\");\\n        require(isValidator(_sender), \\\"sender not allowed\\\");\\n\\n        // cant return because a single claim might mean consensus\\n        if (currentClaim == bytes32(0)) {\\n            currentClaim = _claim;\\n        }\\n\\n        if (_claim != currentClaim) {\\n            return\\n                emitClaimReceivedAndReturn(\\n                    Result.Conflict,\\n                    [currentClaim, _claim],\\n                    [getClaimerOfCurrentClaim(), _sender]\\n                );\\n        }\\n        claimAgreementMask = updateClaimAgreementMask(_sender);\\n\\n        return\\n            isConsensus(claimAgreementMask, consensusGoalMask)\\n                ? emitClaimReceivedAndReturn(\\n                    Result.Consensus,\\n                    [_claim, bytes32(0)],\\n                    [_sender, payable(0)]\\n                )\\n                : emitClaimReceivedAndReturn(\\n                    Result.NoConflict,\\n                    [bytes32(0), bytes32(0)],\\n                    [payable(0), payable(0)]\\n                );\\n    }\\n\\n    // @notice called when a dispute ends in rollups\\n    // @params _winner address of dispute winner\\n    // @params _loser address of dispute loser\\n    // @returns result of dispute being finished\\n    function onDisputeEnd(\\n        address payable _winner,\\n        address payable _loser,\\n        bytes32 _winningClaim\\n    )\\n        public\\n        override\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        onlyRollups();\\n\\n        // remove validator also removes validator from both bitmask\\n        removeFromValidatorSetAndBothBitmasks(_loser);\\n\\n        if (_winningClaim == currentClaim) {\\n            // first claim stood, dont need to update the bitmask\\n            return\\n                isConsensus(claimAgreementMask, consensusGoalMask)\\n                    ? emitDisputeEndedAndReturn(\\n                        Result.Consensus,\\n                        [_winningClaim, bytes32(0)],\\n                        [_winner, payable(0)]\\n                    )\\n                    : emitDisputeEndedAndReturn(\\n                        Result.NoConflict,\\n                        [bytes32(0), bytes32(0)],\\n                        [payable(0), payable(0)]\\n                    );\\n        }\\n\\n        // if first claim lost, and other validators have agreed with it\\n        // there is a new dispute to be played\\n        if (claimAgreementMask != 0) {\\n            return\\n                emitDisputeEndedAndReturn(\\n                    Result.Conflict,\\n                    [currentClaim, _winningClaim],\\n                    [getClaimerOfCurrentClaim(), _winner]\\n                );\\n        }\\n        // else there are no valdiators that agree with losing claim\\n        // we can update current claim and check for consensus in case\\n        // the winner is the only validator left\\n        currentClaim = _winningClaim;\\n        claimAgreementMask = updateClaimAgreementMask(_winner);\\n        return\\n            isConsensus(claimAgreementMask, consensusGoalMask)\\n                ? emitDisputeEndedAndReturn(\\n                    Result.Consensus,\\n                    [_winningClaim, bytes32(0)],\\n                    [_winner, payable(0)]\\n                )\\n                : emitDisputeEndedAndReturn(\\n                    Result.NoConflict,\\n                    [bytes32(0), bytes32(0)],\\n                    [payable(0), payable(0)]\\n                );\\n    }\\n\\n    // @notice called when a new epoch starts\\n    // @return current claim\\n    function onNewEpoch() public override returns (bytes32) {\\n        onlyRollups();\\n\\n        bytes32 tmpClaim = currentClaim;\\n\\n        // clear current claim\\n        currentClaim = bytes32(0);\\n        // clear validator agreement bit mask\\n        claimAgreementMask = 0;\\n\\n        emit NewEpoch(tmpClaim);\\n        return tmpClaim;\\n    }\\n\\n    // @notice get agreement mask\\n    // @return current state of agreement mask\\n    function getCurrentAgreementMask() public view returns (uint32) {\\n        return claimAgreementMask;\\n    }\\n\\n    // @notice get consensus goal mask\\n    // @return current consensus goal mask\\n    function getConsensusGoalMask() public view returns (uint32) {\\n        return consensusGoalMask;\\n    }\\n\\n    // @notice get current claim\\n    // @return current claim\\n    function getCurrentClaim() public view override returns (bytes32) {\\n        return currentClaim;\\n    }\\n\\n    // INTERNAL FUNCTIONS\\n\\n    // @notice emits dispute ended event and then return\\n    // @param _result to be emitted and returned\\n    // @param _claims to be emitted and returned\\n    // @param _validators to be emitted and returned\\n    // @dev this function existis to make code more clear/concise\\n    function emitDisputeEndedAndReturn(\\n        Result _result,\\n        bytes32[2] memory _claims,\\n        address payable[2] memory _validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit DisputeEnded(_result, _claims, _validators);\\n        return (_result, _claims, _validators);\\n    }\\n\\n    // @notice emits claim received event and then return\\n    // @param _result to be emitted and returned\\n    // @param _claims to be emitted and returned\\n    // @param _validators to be emitted and returned\\n    // @dev this function existis to make code more clear/concise\\n    function emitClaimReceivedAndReturn(\\n        Result _result,\\n        bytes32[2] memory _claims,\\n        address payable[2] memory _validators\\n    )\\n        internal\\n        returns (\\n            Result,\\n            bytes32[2] memory,\\n            address payable[2] memory\\n        )\\n    {\\n        emit ClaimReceived(_result, _claims, _validators);\\n        return (_result, _claims, _validators);\\n    }\\n\\n    // @notice get one of the validators that agreed with current claim\\n    // @return validator that agreed with current claim\\n    function getClaimerOfCurrentClaim()\\n        internal\\n        view\\n        returns (address payable)\\n    {\\n        // TODO: we are always getting the first validator\\n        // on the array that agrees with the current claim to enter a dispute\\n        // should this be random?\\n        for (uint256 i; i < validators.length; i++) {\\n            if (claimAgreementMask & (1 << i) != 0) {\\n                return validators[i];\\n            }\\n        }\\n        revert(\\\"Agreeing validator not found\\\");\\n    }\\n\\n    // @notice updates the consensus goal mask\\n    // @return new consensus goal mask\\n    function updateConsensusGoalMask() internal view returns (uint32) {\\n        // consensus goal is a number where\\n        // all bits related to validators are turned on\\n        uint256 consensusMask = (1 << validators.length) - 1;\\n        return uint32(consensusMask);\\n    }\\n\\n    // @notice updates mask of validators that agreed with current claim\\n    // @params _sender address that of validator that will be included in mask\\n    // @return new claim agreement mask\\n    function updateClaimAgreementMask(address payable _sender)\\n        internal\\n        view\\n        returns (uint32)\\n    {\\n        uint256 tmpClaimAgreement = claimAgreementMask;\\n        for (uint256 i; i < validators.length; i++) {\\n            if (_sender == validators[i]) {\\n                tmpClaimAgreement = (tmpClaimAgreement | (1 << i));\\n                break;\\n            }\\n        }\\n\\n        return uint32(tmpClaimAgreement);\\n    }\\n\\n    // @notice removes a validator\\n    // @params address of validator to be removed\\n    // @returns new claim agreement bitmask\\n    // @returns new consensus goal bitmask\\n    function removeFromValidatorSetAndBothBitmasks(address _validator)\\n        internal\\n    {\\n        // put address(0) in validators position\\n        // removes validator from claim agreement bitmask\\n        // removes validator from consensus goal mask\\n        for (uint256 i; i < validators.length; i++) {\\n            if (_validator == validators[i]) {\\n                validators[i] = payable(0);\\n                uint32 zeroMask = ~(uint32(1) << uint32(i));\\n                claimAgreementMask = claimAgreementMask & zeroMask;\\n                consensusGoalMask = consensusGoalMask & zeroMask;\\n                break;\\n            }\\n        }\\n    }\\n\\n    function isValidator(address _sender) internal view returns (bool) {\\n        for (uint256 i; i < validators.length; i++) {\\n            if (_sender == validators[i]) return true;\\n        }\\n        return false;\\n    }\\n\\n    function isConsensus(\\n        uint256 _claimAgreementMask,\\n        uint256 _consensusGoalMask\\n    ) internal pure returns (bool) {\\n        return _claimAgreementMask == _consensusGoalMask;\\n    }\\n}\\n\",\"keccak256\":\"0x2fee6aa439d9419eb0d0da98db3d42b807aec7f9e66d2870278987d15ebc766a\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162003b1538038062003b1583398101604081905262000034916200030f565b30826040516200004490620002a4565b6001600160a01b0390921682526020820152604001604051809103906000f08015801562000076573d6000803e3d6000fd5b50600080546001600160a01b0319166001600160a01b03929092169190911790556040513090620000a790620002b2565b6001600160a01b039091168152602001604051809103906000f080158015620000d4573d6000803e3d6000fd5b50600160006101000a8154816001600160a01b0302191690836001600160a01b0316021790555030816040516200010b90620002c0565b6200011892919062000401565b604051809103906000f08015801562000135573d6000803e3d6000fd5b50600280546001600160a01b0319166001600160a01b039290921691909117905560405130906200016690620002ce565b6001600160a01b039091168152602001604051809103906000f08015801562000193573d6000803e3d6000fd5b50600380546001600160a01b0319166001600160a01b039283169081179091556040805160a0808201835263ffffffff898116808452898216602080860182905242909316858701819052600060608088018290526080978801829052600480546001600160401b03191690951764010000000090940293909317600160401b600160a01b03191668010000000000000000909202600160601b600160a01b0319169190911790925590546001546002548751928a168352908916938201939093529190961681850152948501939093528301879052908201859052517f0c34d7ca767e7f7b827de620cbd78c6291e2ca28d8ac112f26c5121912ea1ecc9181900360c00190a1505050506200045f565b61081e806200164183390190565b610d0f8062001e5f83390190565b610c7f8062002b6e83390190565b61032880620037ed83390190565b634e487b7160e01b600052604160045260246000fd5b80516001600160a01b03811681146200030a57600080fd5b919050565b600080600080608085870312156200032657600080fd5b8451602080870151604088015160608901519397509095509350906001600160401b03808211156200035757600080fd5b818801915088601f8301126200036c57600080fd5b815181811115620003815762000381620002dc565b8060051b604051601f19603f83011681018181108582111715620003a957620003a9620002dc565b60405291825284820192508381018501918b831115620003c857600080fd5b938501935b82851015620003f157620003e185620002f2565b84529385019392850192620003cd565b989b979a50959850505050505050565b6001600160a01b038381168252604060208084018290528451918401829052600092858201929091906060860190855b818110156200045157855185168352948301949183019160010162000431565b509098975050505050505050565b6111d2806200046f6000396000f3fe608060405234801561001057600080fd5b50600436106101005760003560e01c8063ddf7bcf011610097578063f20eaeb811610066578063f20eaeb81461025e578063f3cca85a14610271578063f544c3a614610282578063fe55bde91461029557600080fd5b8063ddf7bcf01461020d578063eaed3f4f14610222578063eaf5cb1a14610235578063eb71b0931461024657600080fd5b806382ae9ef7116100d357806382ae9ef7146101c7578063a3a40ea5146101cf578063b97dd9e2146101e4578063bd66528a146101fa57600080fd5b806321ae6567146101055780632cd007ed1461012f5780634ecfd8d6146101405780636c827cb114610155575b600080fd5b6002546001600160a01b03165b6040516001600160a01b0390911681526020015b60405180910390f35b6001546001600160a01b0316610112565b61015361014e366004610f3b565b6102a8565b005b6004546101909063ffffffff808216916401000000008104821691600160401b8204811691600160601b8104821691600160801b9091041685565b6040805163ffffffff968716815294861660208601529285169284019290925283166060830152909116608082015260a001610126565b610153610423565b6101d76105f5565b6040516101269190610f92565b6101ec610621565b604051908152602001610126565b610153610208366004610fba565b610705565b600454600160401b900463ffffffff166101ec565b600054610112906001600160a01b031681565b6003546001600160a01b0316610112565b61024e6109ed565b6040519015158152602001610126565b600154610112906001600160a01b031681565b6000546001600160a01b0316610112565b600354610112906001600160a01b031681565b600254610112906001600160a01b031681565b6003546001600160a01b031633146102ff5760405162461bcd60e51b81526020600482015260156024820152741bdb9b1e48111a5cdc1d5d194810dbdb9d1c9858dd605a1b60448201526064015b60405180910390fd5b6000610309610f05565b610311610f05565b600254604051630d7dc39360e21b81526001600160a01b038881166004830152878116602483015260448201879052909116906335f70e4c9060640160a060405180830381600087803b15801561036757600080fd5b505af115801561037b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061039f919061100a565b6004805463ffffffff60601b1916600160601b4263ffffffff1602179055604080516001600160a01b03808c1682528a16602082015290810188905292955090935091507f2afbde4d47160a9c5de25b0df88d5b83e705286f2a447cac162db5e99ad6f5d29060600160405180910390a161041b838383610af7565b505050505050565b600454600090600160801b900463ffffffff16600281111561044757610447610f7c565b9050600181600281111561045d5761045d610f7c565b146104aa5760405162461bcd60e51b815260206004820152601b60248201527f506861736520213d204177616974696e6720436f6e73656e737573000000000060448201526064016102f6565b60045463ffffffff600160601b82048116916401000000009004166104cf81836110d8565b421161051d5760405162461bcd60e51b815260206004820152601960248201527f4368616c6c656e676520706572696f64206e6f74206f7665720000000000000060448201526064016102f6565b600254604080516320867f6960e21b815290516000926001600160a01b031691638219fda4916004808301926020929190829003018186803b15801561056257600080fd5b505afa158015610576573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061059a91906110fe565b14156105e85760405162461bcd60e51b815260206004820152601860248201527f4e6f20436c61696d20746f2062652066696e616c697a6564000000000000000060448201526064016102f6565b6105f0610c9d565b505050565b6004546000908190600160801b900463ffffffff16600281111561061b5761061b610f7c565b92915050565b600080600160009054906101000a90046001600160a01b03166001600160a01b03166383552b4d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561067257600080fd5b505afa158015610686573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106aa91906110fe565b600454909150600090600160801b900463ffffffff1660028111156106d1576106d1610f7c565b905060008160028111156106e7576106e7610f7c565b146106fc576106f78260016110d8565b6106fe565b815b9250505090565b600061070f610f05565b610717610f05565b600454600090600160801b900463ffffffff16600281111561073b5761073b610f7c565b60045490915063ffffffff600160401b820481169116600083600281111561076557610765610f7c565b14801561077a575061077781836110d8565b42115b15610837576004805463ffffffff60801b1916600160801b1790556040516001935060008051602061117d833981519152906107b7908590610f92565b60405180910390a1600080546040805163851867b360e01b815290516001600160a01b039092169263851867b39260048084019382900301818387803b15801561080057600080fd5b505af1158015610814573d6000803e3d6000fd5b50506004805463ffffffff60601b1916600160601b4263ffffffff160217905550505b600183600281111561084b5761084b610f7c565b146108985760405162461bcd60e51b815260206004820152601a60248201527f506861736520213d204177616974696e67436f6e73656e73757300000000000060448201526064016102f6565b60025460405163fabc6a2960e01b8152336004820152602481018990526001600160a01b039091169063fabc6a299060440160a060405180830381600087803b1580156108e457600080fd5b505af11580156108f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061091c919061100a565b600154604080516383552b4d60e01b81529051949a509298509096506001600160a01b0316916383552b4d91600480820192602092909190829003018186803b15801561096857600080fd5b505afa15801561097c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a091906110fe565b60408051338152602081018a90527fd31325e5dc55b03edf08c70299d3b1bc8d4c2ca8512c90138ddd03e3f54fce6c910160405180910390a26109e4868686610af7565b50505050505050565b600080546001600160a01b03163314610a3e5760405162461bcd60e51b81526020600482015260136024820152721bdb9b1e48125b9c1d5d0810dbdb9d1c9858dd606a1b60448201526064016102f6565b600454600090600160801b900463ffffffff166002811115610a6257610a62610f7c565b60045490915063ffffffff600160401b8204811691166000836002811115610a8c57610a8c610f7c565b148015610aa15750610a9e81836110d8565b42115b15610aed576004805463ffffffff60801b1916600160801b17905560405160008051602061117d83398151915290610adb90600190610f92565b60405180910390a16001935050505090565b6000935050505090565b6000836002811115610b0b57610b0b610f7c565b1415610b9457600454600090600160801b900463ffffffff166002811115610b3557610b35610f7c565b90506001816002811115610b4b57610b4b610f7c565b14610b8e576004805463ffffffff60801b1916600160801b17905560405160008051602061117d83398151915290610b8590600190610f92565b60405180910390a15b50505050565b6001836002811115610ba857610ba8610f7c565b1415610bb6576105f0610c9d565b600454600090600160801b900463ffffffff166002811115610bda57610bda610f7c565b90506002816002811115610bf057610bf0610f7c565b14610c33576004805463ffffffff60801b1916600160811b17905560405160008051602061117d83398151915290610c2a90600290610f92565b60405180910390a15b600354604051632c83c47160e11b81526001600160a01b039091169063590788e290610c659086908690600401611117565b600060405180830381600087803b158015610c7f57600080fd5b505af1158015610c93573d6000803e3d6000fd5b5050505050505050565b6004805463ffffffff60801b1916905560405160008051602061117d83398151915290610ccc90600090610f92565b60405180910390a16004805463ffffffff60601b1963ffffffff4216600160401b02166fffffffffffffffff0000000000000000199091161763ffffffff60601b178155600254604080516379fa798360e01b815290516000936001600160a01b03909316926379fa79839280820192602092909182900301818787803b158015610d5657600080fd5b505af1158015610d6a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d8e91906110fe565b9050600160009054906101000a90046001600160a01b03166001600160a01b03166383552b4d6040518163ffffffff1660e01b815260040160206040518083038186803b158015610dde57600080fd5b505afa158015610df2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e1691906110fe565b6040518281527f6e3d05bc77b9307d9ba574c7c3196a746edd51104ded1c823edc63be4b8a63c39060200160405180910390a2600154604051638252b1dd60e01b8152600481018390526001600160a01b0390911690638252b1dd90602401600060405180830381600087803b158015610e8f57600080fd5b505af1158015610ea3573d6000803e3d6000fd5b505060008054604080516379fa798360e01b815290516001600160a01b0390921694506379fa79839350600480820193929182900301818387803b158015610eea57600080fd5b505af1158015610efe573d6000803e3d6000fd5b5050505050565b60405180604001604052806002906020820280368337509192915050565b6001600160a01b0381168114610f3857600080fd5b50565b600080600060608486031215610f5057600080fd5b8335610f5b81610f23565b92506020840135610f6b81610f23565b929592945050506040919091013590565b634e487b7160e01b600052602160045260246000fd5b6020810160038310610fb457634e487b7160e01b600052602160045260246000fd5b91905290565b600060208284031215610fcc57600080fd5b5035919050565b6040805190810167ffffffffffffffff8111828210171561100457634e487b7160e01b600052604160045260246000fd5b60405290565b600080600060a0848603121561101f57600080fd5b83516003811061102e57600080fd5b92506020603f8501861361104157600080fd5b611049610fd3565b80606087018881111561105b57600080fd5b8388015b81811015611076578051845292840192840161105f565b5081955088607f89011261108957600080fd5b611091610fd3565b925082915060a08801898111156110a757600080fd5b808210156110c95781516110ba81610f23565b845292840192908401906110a7565b50508093505050509250925092565b600082198211156110f957634e487b7160e01b600052601160045260246000fd5b500190565b60006020828403121561111057600080fd5b5051919050565b60808101818460005b600281101561113f578151835260209283019290910190600101611120565b505050604082018360005b60028110156111725781516001600160a01b031683526020928301929091019060010161114a565b505050939250505056feed606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8fa264697066735822122098e7f91abf8af465969726f09e88b1a8a2c53c88c140c40da2f40c312e0db84c64736f6c6343000809003360c060405234801561001057600080fd5b5060405161081e38038061081e83398101604081905261002f9161009e565b60038110158015610041575060408111155b6100845760405162461bcd60e51b815260206004820152601060248201526f6c6f672073697a653a205b332c36345d60801b604482015260640160405180910390fd5b6001600160a01b039091166080526001901b60a0526100d8565b600080604083850312156100b157600080fd5b82516001600160a01b03811681146100c857600080fd5b6020939093015192949293505050565b60805160a05161070c61011260003960006101720152600081816101e8015281816102a5015281816103ed01526104ce015261070c6000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80631ab6dcab1461006757806379fa79831461007d578063851867b314610087578063a459600e1461008f578063e7955244146100a2578063f32078e8146100aa575b600080fd5b6002545b60405190815260200160405180910390f35b6100856100bd565b005b6100856100e6565b61006b61009d366004610576565b6100f6565b61006b61014a565b61006b6100b836600461058f565b610164565b6100c56104c3565b600254156100da576100d8600080610544565b565b6100d860016000610544565b6100ee6104c3565b6100d861052a565b6000600254600014610125576000828154811061011557610115610601565b9060005260206000200154610144565b6001828154811061013857610138610601565b90600052602060002001545b92915050565b600060025460001461015d575060005490565b5060015490565b6000811580159061019557507f00000000000000000000000000000000000000000000000000000000000000008211155b6101e65760405162461bcd60e51b815260206004820152601860248201527f696e707574206c656e3a2028302c647269766553697a655d000000000000000060448201526064015b60405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663eb71b0936040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561024157600080fd5b505af1158015610255573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102799190610617565b156102865761028661052a565b600060025460001461029957600161029c565b60005b905060003343427f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b97dd9e26040518163ffffffff1660e01b815260040160206040518083038186803b1580156102fc57600080fd5b505afa158015610310573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103349190610640565b8554604080516001600160a01b0390961660208701528501939093526060840191909152608083015260a082015260c0016040516020818303038152906040528051906020012090506000858560405161038f929190610659565b6040805191829003822060208301859052908201819052915060009060600160408051601f1981840301815291905280516020918201208554600181810188556000888152939093200181905585549092506103eb9190610669565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663b97dd9e26040518163ffffffff1660e01b815260040160206040518083038186803b15801561044457600080fd5b505afa158015610458573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061047c9190610640565b7fa15a0da5519c084484141aaa73e525cee96062f5decc97e070f0c4da27738bc733428b8b6040516104b1949392919061068e565b60405180910390a39695505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146100d85760405162461bcd60e51b815260206004820152600c60248201526b4f6e6c7920726f6c6c75707360a01b60448201526064016101dd565b60025415610539576000600255565b600160028190555b50565b508054600082559060005260206000209081019061054191905b80821115610572576000815560010161055e565b5090565b60006020828403121561058857600080fd5b5035919050565b600080602083850312156105a257600080fd5b823567ffffffffffffffff808211156105ba57600080fd5b818501915085601f8301126105ce57600080fd5b8135818111156105dd57600080fd5b8660208285010111156105ef57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561062957600080fd5b8151801515811461063957600080fd5b9392505050565b60006020828403121561065257600080fd5b5051919050565b8183823760009101908152919050565b60008282101561068957634e487b7160e01b600052601160045260246000fd5b500390565b6001600160a01b0385168152602081018490526060604082018190528101829052818360808301376000818301608090810191909152601f909201601f19160101939250505056fea2646970667358221220b1aa0e1533cd8db484ac6d6e5b46ccefe63aab5485d4e4f2bbf4449ca1be829a64736f6c6343000809003360a060405234801561001057600080fd5b50604051610d0f380380610d0f83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b608051610c8461008b60003960006104780152610c846000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80638021be81116100715780638021be811461013e5780638252b1dd1461014557806383552b4d1461015a578063a238203614610162578063a981588a1461013e578063f3af7efd1461016257600080fd5b806310517cfc146100ae5780633ad58a27146100d35780633c0d9958146100f65780635e439a0c146101185780636190d81e1461012b575b600080fd5b6100c06100bc366004610876565b1b90565b6040519081526020015b60405180910390f35b6100e66100e13660046108c7565b610169565b60405190151581526020016100ca565b6100c06101043660046109a6565b608083901b604083901b1781179392505050565b6100e66101263660046108c7565b610187565b6100e66101393660046109d2565b61019d565b60156100c0565b610158610153366004610a88565b61046d565b005b6001546100c0565b60256100c0565b600061017f84848460a001356025601587610508565b949350505050565b600061017f848484608001356025601587610508565b60025460009060ff16156101f15760405162461bcd60e51b81526020600482015260166024820152751c99595b9d1c985b98de481b9bdd08185b1b1bddd95960521b60448201526064015b60405180910390fd5b6002805460ff1916600117905560405160009061021690879087908790602001610aa1565b604051602081830303815290604052905061025381600185600001358154811061024257610242610ae1565b906000526020600020015485610187565b5060006020840135604090811b9085013560801b178435176040516303fbaf7360e01b81526000600482015260248101829052909150736Fc1eACde8ec4898711Ec3b03bbCc666361A136A906303fbaf739060440160206040518083038186803b1580156102c057600080fd5b505af41580156102d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f89190610af7565b156103455760405162461bcd60e51b815260206004820152601860248201527f72652d657865637574696f6e206e6f7420616c6c6f776564000000000000000060448201526064016101e8565b6000876001600160a01b03168787604051610361929190610b20565b6000604051808303816000865af19150503d806000811461039e576040519150601f19603f3d011682016040523d82523d6000602084013e6103a3565b606091505b505090508015610458576040516306449da160e41b8152600060048201526024810183905260016044820152736Fc1eACde8ec4898711Ec3b03bbCc666361A136A90636449da109060640160006040518083038186803b15801561040657600080fd5b505af415801561041a573d6000803e3d6000fd5b505050507f0eb7ee080f865f1cadc4f54daf58cc3b8879e888832867d13351edcec0fbdc548260405161044f91815260200190565b60405180910390a15b6002805460ff19169055979650505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146104d45760405162461bcd60e51b815260206004820152600c60248201526b4f6e6c7920726f6c6c75707360a01b60448201526064016101e8565b6001805480820182556000919091527fb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf60155565b60408051608080840135602083015260a08401359282019290925260c08301356060820152600091879101604051602081830303815290604052805190602001201461058c5760405162461bcd60e51b8152602060048201526013602482015272195c1bd8da12185cda081a5b98dbdc9c9958dd606a1b60448201526064016101e8565b8473DA9aafbDcda3a5DDFE0D1372ebd6201efE7F23246379de4601602085013560051b60058887606001356040516020016105c991815260200190565b60408051601f1981840301815291905280516020909101206105ef6101008a018a610b30565b6040518763ffffffff1660e01b815260040161061096959493929190610b81565b60206040518083038186803b15801561062857600080fd5b505af415801561063c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106609190610bd8565b146106ad5760405162461bcd60e51b815260206004820152601e60248201527f65706f63684f757470757444726976654861736820696e636f7272656374000060448201526064016101e8565b600073DA9aafbDcda3a5DDFE0D1372ebd6201efE7F232463c84583a189805190602001206040516020016106e391815260200190565b60405160208183030381529060405260056040518363ffffffff1660e01b8152600401610711929190610bf1565b60206040518083038186803b15801561072957600080fd5b505af415801561073d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107619190610bd8565b9050606083013573DA9aafbDcda3a5DDFE0D1372ebd6201efE7F23246379de4601604086013560051b6005888661079b60e08b018b610b30565b6040518763ffffffff1660e01b81526004016107bc96959493929190610b81565b60206040518083038186803b1580156107d457600080fd5b505af41580156107e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061080c9190610bd8565b146108685760405162461bcd60e51b815260206004820152602660248201527f6f75747075744d65746164617461417272617944726976654861736820696e636044820152651bdc9c9958dd60d21b60648201526084016101e8565b506001979650505050505050565b6000806040838503121561088957600080fd5b50508035926020909101359150565b634e487b7160e01b600052604160045260246000fd5b600061012082840312156108c157600080fd5b50919050565b6000806000606084860312156108dc57600080fd5b833567ffffffffffffffff808211156108f457600080fd5b818601915086601f83011261090857600080fd5b81358181111561091a5761091a610898565b604051601f8201601f19908116603f0116810190838211818310171561094257610942610898565b8160405282815289602084870101111561095b57600080fd5b8260208601602083013760006020848301015280975050505060208601359350604086013591508082111561098f57600080fd5b5061099c868287016108ae565b9150509250925092565b6000806000606084860312156109bb57600080fd5b505081359360208301359350604090920135919050565b600080600080606085870312156109e857600080fd5b84356001600160a01b03811681146109ff57600080fd5b9350602085013567ffffffffffffffff80821115610a1c57600080fd5b818701915087601f830112610a3057600080fd5b813581811115610a3f57600080fd5b886020828501011115610a5157600080fd5b602083019550809450506040870135915080821115610a6f57600080fd5b50610a7c878288016108ae565b91505092959194509250565b600060208284031215610a9a57600080fd5b5035919050565b6001600160a01b03841681526040602082018190528101829052818360608301376000818301606090810191909152601f909201601f1916010192915050565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610b0957600080fd5b81518015158114610b1957600080fd5b9392505050565b8183823760009101908152919050565b6000808335601e19843603018112610b4757600080fd5b83018035915067ffffffffffffffff821115610b6257600080fd5b6020019150600581901b3603821315610b7a57600080fd5b9250929050565b86815285602082015284604082015283606082015260a060808201528160a0820152600060018060fb1b03831115610bb857600080fd5b8260051b808560c08501376000920160c001918252509695505050505050565b600060208284031215610bea57600080fd5b5051919050565b604081526000835180604084015260005b81811015610c1f5760208187018101516060868401015201610c02565b81811115610c31576000606083860101525b50602083019390935250601f91909101601f19160160600191905056fea26469706673582212207e7041ea77f3f912f78f0a06a2d971a7e3210272aff13d326deaf6d2d1fbb99564736f6c6343000809003360a06040523480156200001157600080fd5b5060405162000c7f38038062000c7f833981016040819052620000349162000169565b6001600160a01b038216608052805162000056906001906020840190620000a7565b506200006162000089565b600260046101000a81548163ffffffff021916908363ffffffff16021790555050506200027a565b600180546000918291620000a1919081901b62000254565b92915050565b828054828255906000526020600020908101928215620000ff579160200282015b82811115620000ff57825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190620000c8565b506200010d92915062000111565b5090565b5b808211156200010d576000815560010162000112565b6001600160a01b03811681146200013e57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b8051620001648162000128565b919050565b600080604083850312156200017d57600080fd5b82516200018a8162000128565b602084810151919350906001600160401b0380821115620001aa57600080fd5b818601915086601f830112620001bf57600080fd5b815181811115620001d457620001d462000141565b8060051b604051601f19603f83011681018181108582111715620001fc57620001fc62000141565b6040529182528482019250838101850191898311156200021b57600080fd5b938501935b828510156200024457620002348562000157565b8452938501939285019262000220565b8096505050505050509250929050565b6000828210156200027557634e487b7160e01b600052601160045260246000fd5b500390565b6080516109e96200029660003960006104f601526109e96000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c8063012ad61c1461006757806335f70e4c1461008b57806379fa7983146100ad5780638219fda4146100c3578063f6023815146100cb578063fabc6a29146100e1575b600080fd5b60025463ffffffff165b60405163ffffffff90911681526020015b60405180910390f35b61009e610099366004610886565b6100f4565b604051610082939291906108c2565b6100b56102ce565b604051908152602001610082565b6000546100b5565b600254640100000000900463ffffffff16610071565b61009e6100ef36600461094a565b610324565b60006100fe61084c565b61010661084c565b61010e6104eb565b61011785610554565b6000548414156101b757600254640100000000810463ffffffff90811691161461017257604080518082018252600080825260208083018290528351808501909452818452830181905261016d9290919061062f565b6101ac565b6040805180820182528581526000602080830182905283518085019094526001600160a01b038a1684528301526101ac916001919061062f565b9250925092506102c5565b60025463ffffffff161561020e576101ac6002604051806040016040528060005481526020018781525060405180604001604052806101f4610688565b6001600160a01b0390811682528b1660209091015261062f565b600084905561021c86610732565b6002805463ffffffff191663ffffffff928316908117918290556102499290916401000000009004161490565b61028457604080518082018252600080825260208083018290528351808501909452818452830181905261027f9290919061062f565b6102be565b6040805180820182528581526000602080830182905283518085019094526001600160a01b038a1684528301526102be916001919061062f565b9250925092505b93509350939050565b60006102d86104eb565b600080549080556002805463ffffffff191690556040518181527fddc860800a99149017c480ec51523bf4143b7215e78956ae5c31e5c568f5383a9060200160405180910390a1919050565b600061032e61084c565b61033661084c565b61033e6104eb565b8361037e5760405162461bcd60e51b815260206004820152600b60248201526a656d70747920636c61696d60a81b60448201526064015b60405180910390fd5b610387856107a3565b6103c85760405162461bcd60e51b81526020600482015260126024820152711cd95b99195c881b9bdd08185b1b1bddd95960721b6044820152606401610375565b6000546103d55760008490555b60005484146104325761042760026040518060400160405280600054815260200187815250604051806040016040528061040d610688565b6001600160a01b0390811682528a16602090910152610807565b9250925092506104e4565b61043b85610732565b6002805463ffffffff191663ffffffff928316908117918290556104689290916401000000009004161490565b6104a357604080518082018252600080825260208083018290528351808501909452818452830181905261049e92909190610807565b6104dd565b6040805180820182528581526000602080830182905283518085019094526001600160a01b03891684528301526104dd9160019190610807565b9250925092505b9250925092565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146105525760405162461bcd60e51b815260206004820152600c60248201526b4f6e6c7920726f6c6c75707360a01b6044820152606401610375565b565b60005b60015481101561062b576001818154811061057457610574610974565b6000918252602090912001546001600160a01b0383811691161415610619576000600182815481106105a8576105a8610974565b600091825260209091200180546001600160a01b03929092166001600160a01b03199092169190911790556002805464010000000063ffffffff198216600163ffffffff8087169190911b198481168216928317849004161690910267ffffffffffffffff19909216171790555050565b806106238161098a565b915050610557565b5050565b600061063961084c565b61064161084c565b7f09201c193a07cae1df95ae692cc698685574c942a04514c48a4c3249f38594ff868686604051610674939291906108c2565b60405180910390a150939492935090919050565b6000805b6001548110156106e9576002546001821b1663ffffffff16156106d757600181815481106106bc576106bc610974565b6000918252602090912001546001600160a01b031692915050565b806106e18161098a565b91505061068c565b5060405162461bcd60e51b815260206004820152601c60248201527f4167726565696e672076616c696461746f72206e6f7420666f756e64000000006044820152606401610375565b60025460009063ffffffff16815b60015481101561079c576001818154811061075d5761075d610974565b6000918252602090912001546001600160a01b038581169116141561078a57806001901b8217915061079c565b806107948161098a565b915050610740565b5092915050565b6000805b6001548110156107fe57600181815481106107c4576107c4610974565b6000918252602090912001546001600160a01b03848116911614156107ec5750600192915050565b806107f68161098a565b9150506107a7565b50600092915050565b600061081161084c565b61081961084c565b7f495383aed97965c56495cdbadedfe9667a1b028c54d3fc4b5335895146e02b70868686604051610674939291906108c2565b60405180604001604052806002906020820280368337509192915050565b80356001600160a01b038116811461088157600080fd5b919050565b60008060006060848603121561089b57600080fd5b6108a48461086a565b92506108b26020850161086a565b9150604084013590509250925092565b60a08101600385106108e457634e487b7160e01b600052602160045260246000fd5b84825260208083018560005b600281101561090d578151835291830191908301906001016108f0565b505050606083018460005b600281101561093e5781516001600160a01b031683529183019190830190600101610918565b50505050949350505050565b6000806040838503121561095d57600080fd5b6109668361086a565b946020939093013593505050565b634e487b7160e01b600052603260045260246000fd5b60006000198214156109ac57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220307d873058c34130048a9909f469a9bc90b3eed5d8037ef76f5dab36284f5eb064736f6c6343000809003360a060405234801561001057600080fd5b5060405161032838038061032883398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b608051610297610091600039600081816050015261010201526102976000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063590788e214610030575b600080fd5b61004361003e36600461019b565b610045565b005b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146100cd5760405162461bcd60e51b8152602060048201526024808201527f4f6e6c7920726f6c6c7570732063616e2063616c6c20746869732066756e6374604482015263696f6e7360e01b606482015260840160405180910390fd5b805160208201518351604051632767ec6b60e11b81526001600160a01b039384166004820152918316602483015260448201527f000000000000000000000000000000000000000000000000000000000000000090911690634ecfd8d690606401600060405180830381600087803b15801561014857600080fd5b505af115801561015c573d6000803e3d6000fd5b505050505050565b6040805190810167ffffffffffffffff8111828210171561019557634e487b7160e01b600052604160045260246000fd5b60405290565b600080608083850312156101ae57600080fd5b83601f8401126101bd57600080fd5b6101c5610164565b8060408501868111156101d757600080fd5b855b818110156101f15780358452602093840193016101d9565b5081945086605f87011261020457600080fd5b61020c610164565b9250829150608086018781111561022257600080fd5b808210156102545781356001600160a01b03811681146102425760008081fd5b84526020938401939190910190610222565b509396909550935050505056fea26469706673582212200a0bc85bbb603e01e12e026e73b6a114fe768b0bb0d7f9de9837eb39ee08c2c664736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101005760003560e01c8063ddf7bcf011610097578063f20eaeb811610066578063f20eaeb81461025e578063f3cca85a14610271578063f544c3a614610282578063fe55bde91461029557600080fd5b8063ddf7bcf01461020d578063eaed3f4f14610222578063eaf5cb1a14610235578063eb71b0931461024657600080fd5b806382ae9ef7116100d357806382ae9ef7146101c7578063a3a40ea5146101cf578063b97dd9e2146101e4578063bd66528a146101fa57600080fd5b806321ae6567146101055780632cd007ed1461012f5780634ecfd8d6146101405780636c827cb114610155575b600080fd5b6002546001600160a01b03165b6040516001600160a01b0390911681526020015b60405180910390f35b6001546001600160a01b0316610112565b61015361014e366004610f3b565b6102a8565b005b6004546101909063ffffffff808216916401000000008104821691600160401b8204811691600160601b8104821691600160801b9091041685565b6040805163ffffffff968716815294861660208601529285169284019290925283166060830152909116608082015260a001610126565b610153610423565b6101d76105f5565b6040516101269190610f92565b6101ec610621565b604051908152602001610126565b610153610208366004610fba565b610705565b600454600160401b900463ffffffff166101ec565b600054610112906001600160a01b031681565b6003546001600160a01b0316610112565b61024e6109ed565b6040519015158152602001610126565b600154610112906001600160a01b031681565b6000546001600160a01b0316610112565b600354610112906001600160a01b031681565b600254610112906001600160a01b031681565b6003546001600160a01b031633146102ff5760405162461bcd60e51b81526020600482015260156024820152741bdb9b1e48111a5cdc1d5d194810dbdb9d1c9858dd605a1b60448201526064015b60405180910390fd5b6000610309610f05565b610311610f05565b600254604051630d7dc39360e21b81526001600160a01b038881166004830152878116602483015260448201879052909116906335f70e4c9060640160a060405180830381600087803b15801561036757600080fd5b505af115801561037b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061039f919061100a565b6004805463ffffffff60601b1916600160601b4263ffffffff1602179055604080516001600160a01b03808c1682528a16602082015290810188905292955090935091507f2afbde4d47160a9c5de25b0df88d5b83e705286f2a447cac162db5e99ad6f5d29060600160405180910390a161041b838383610af7565b505050505050565b600454600090600160801b900463ffffffff16600281111561044757610447610f7c565b9050600181600281111561045d5761045d610f7c565b146104aa5760405162461bcd60e51b815260206004820152601b60248201527f506861736520213d204177616974696e6720436f6e73656e737573000000000060448201526064016102f6565b60045463ffffffff600160601b82048116916401000000009004166104cf81836110d8565b421161051d5760405162461bcd60e51b815260206004820152601960248201527f4368616c6c656e676520706572696f64206e6f74206f7665720000000000000060448201526064016102f6565b600254604080516320867f6960e21b815290516000926001600160a01b031691638219fda4916004808301926020929190829003018186803b15801561056257600080fd5b505afa158015610576573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061059a91906110fe565b14156105e85760405162461bcd60e51b815260206004820152601860248201527f4e6f20436c61696d20746f2062652066696e616c697a6564000000000000000060448201526064016102f6565b6105f0610c9d565b505050565b6004546000908190600160801b900463ffffffff16600281111561061b5761061b610f7c565b92915050565b600080600160009054906101000a90046001600160a01b03166001600160a01b03166383552b4d6040518163ffffffff1660e01b815260040160206040518083038186803b15801561067257600080fd5b505afa158015610686573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106aa91906110fe565b600454909150600090600160801b900463ffffffff1660028111156106d1576106d1610f7c565b905060008160028111156106e7576106e7610f7c565b146106fc576106f78260016110d8565b6106fe565b815b9250505090565b600061070f610f05565b610717610f05565b600454600090600160801b900463ffffffff16600281111561073b5761073b610f7c565b60045490915063ffffffff600160401b820481169116600083600281111561076557610765610f7c565b14801561077a575061077781836110d8565b42115b15610837576004805463ffffffff60801b1916600160801b1790556040516001935060008051602061117d833981519152906107b7908590610f92565b60405180910390a1600080546040805163851867b360e01b815290516001600160a01b039092169263851867b39260048084019382900301818387803b15801561080057600080fd5b505af1158015610814573d6000803e3d6000fd5b50506004805463ffffffff60601b1916600160601b4263ffffffff160217905550505b600183600281111561084b5761084b610f7c565b146108985760405162461bcd60e51b815260206004820152601a60248201527f506861736520213d204177616974696e67436f6e73656e73757300000000000060448201526064016102f6565b60025460405163fabc6a2960e01b8152336004820152602481018990526001600160a01b039091169063fabc6a299060440160a060405180830381600087803b1580156108e457600080fd5b505af11580156108f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061091c919061100a565b600154604080516383552b4d60e01b81529051949a509298509096506001600160a01b0316916383552b4d91600480820192602092909190829003018186803b15801561096857600080fd5b505afa15801561097c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a091906110fe565b60408051338152602081018a90527fd31325e5dc55b03edf08c70299d3b1bc8d4c2ca8512c90138ddd03e3f54fce6c910160405180910390a26109e4868686610af7565b50505050505050565b600080546001600160a01b03163314610a3e5760405162461bcd60e51b81526020600482015260136024820152721bdb9b1e48125b9c1d5d0810dbdb9d1c9858dd606a1b60448201526064016102f6565b600454600090600160801b900463ffffffff166002811115610a6257610a62610f7c565b60045490915063ffffffff600160401b8204811691166000836002811115610a8c57610a8c610f7c565b148015610aa15750610a9e81836110d8565b42115b15610aed576004805463ffffffff60801b1916600160801b17905560405160008051602061117d83398151915290610adb90600190610f92565b60405180910390a16001935050505090565b6000935050505090565b6000836002811115610b0b57610b0b610f7c565b1415610b9457600454600090600160801b900463ffffffff166002811115610b3557610b35610f7c565b90506001816002811115610b4b57610b4b610f7c565b14610b8e576004805463ffffffff60801b1916600160801b17905560405160008051602061117d83398151915290610b8590600190610f92565b60405180910390a15b50505050565b6001836002811115610ba857610ba8610f7c565b1415610bb6576105f0610c9d565b600454600090600160801b900463ffffffff166002811115610bda57610bda610f7c565b90506002816002811115610bf057610bf0610f7c565b14610c33576004805463ffffffff60801b1916600160811b17905560405160008051602061117d83398151915290610c2a90600290610f92565b60405180910390a15b600354604051632c83c47160e11b81526001600160a01b039091169063590788e290610c659086908690600401611117565b600060405180830381600087803b158015610c7f57600080fd5b505af1158015610c93573d6000803e3d6000fd5b5050505050505050565b6004805463ffffffff60801b1916905560405160008051602061117d83398151915290610ccc90600090610f92565b60405180910390a16004805463ffffffff60601b1963ffffffff4216600160401b02166fffffffffffffffff0000000000000000199091161763ffffffff60601b178155600254604080516379fa798360e01b815290516000936001600160a01b03909316926379fa79839280820192602092909182900301818787803b158015610d5657600080fd5b505af1158015610d6a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d8e91906110fe565b9050600160009054906101000a90046001600160a01b03166001600160a01b03166383552b4d6040518163ffffffff1660e01b815260040160206040518083038186803b158015610dde57600080fd5b505afa158015610df2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e1691906110fe565b6040518281527f6e3d05bc77b9307d9ba574c7c3196a746edd51104ded1c823edc63be4b8a63c39060200160405180910390a2600154604051638252b1dd60e01b8152600481018390526001600160a01b0390911690638252b1dd90602401600060405180830381600087803b158015610e8f57600080fd5b505af1158015610ea3573d6000803e3d6000fd5b505060008054604080516379fa798360e01b815290516001600160a01b0390921694506379fa79839350600480820193929182900301818387803b158015610eea57600080fd5b505af1158015610efe573d6000803e3d6000fd5b5050505050565b60405180604001604052806002906020820280368337509192915050565b6001600160a01b0381168114610f3857600080fd5b50565b600080600060608486031215610f5057600080fd5b8335610f5b81610f23565b92506020840135610f6b81610f23565b929592945050506040919091013590565b634e487b7160e01b600052602160045260246000fd5b6020810160038310610fb457634e487b7160e01b600052602160045260246000fd5b91905290565b600060208284031215610fcc57600080fd5b5035919050565b6040805190810167ffffffffffffffff8111828210171561100457634e487b7160e01b600052604160045260246000fd5b60405290565b600080600060a0848603121561101f57600080fd5b83516003811061102e57600080fd5b92506020603f8501861361104157600080fd5b611049610fd3565b80606087018881111561105b57600080fd5b8388015b81811015611076578051845292840192840161105f565b5081955088607f89011261108957600080fd5b611091610fd3565b925082915060a08801898111156110a757600080fd5b808210156110c95781516110ba81610f23565b845292840192908401906110a7565b50508093505050509250925092565b600082198211156110f957634e487b7160e01b600052601160045260246000fd5b500190565b60006020828403121561111057600080fd5b5051919050565b60808101818460005b600281101561113f578151835260209283019290910190600101611120565b505050604082018360005b60028110156111725781516001600160a01b031683526020928301929091019060010161114a565b505050939250505056feed606d544c2202d032d2626c390923e6f260ca5d89625bba0cfe70d2bdda4e8fa264697066735822122098e7f91abf8af465969726f09e88b1a8a2c53c88c140c40da2f40c312e0db84c64736f6c63430008090033",
  "libraries": {
    "Bitmask": "0x6Fc1eACde8ec4898711Ec3b03bbCc666361A136A",
    "Merkle": "0xDA9aafbDcda3a5DDFE0D1372ebd6201efE7F2324"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_challengePeriod": "duration of challenge period in seconds",
          "_inputDuration": "duration of input accumulation phase in seconds",
          "_inputLog2Size": "size of the input drive in this machine",
          "_validators": "initial validator set"
        }
      },
      "finalizeEpoch()": {
        "details": "can only be called if challenge period is over"
      },
      "getCurrentEpoch()": {
        "details": "if phase is input accumulation, then the epoch number is length",
        "returns": {
          "_0": "index of current epoch"
        }
      },
      "notifyInput()": {
        "details": "can only be called by input contract"
      },
      "resolveDispute(address,address,bytes32)": {
        "details": "can only be called by the dispute contract",
        "params": {
          "_loser": "loser of dispute",
          "_winner": "winner of dispute",
          "_winningClaim": "initial claim of winning validator"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "Claim(uint256,address,bytes32)": {
        "notice": "claim submitted"
      },
      "FinalizeEpoch(uint256,bytes32)": {
        "notice": "epoch finalized"
      },
      "PhaseChange(uint8)": {
        "notice": "phase change"
      },
      "ResolveDispute(address,address,bytes32)": {
        "notice": "dispute resolved"
      },
      "RollupsCreated(address,address,address,address,uint256,uint256)": {
        "notice": "contract created"
      }
    },
    "kind": "user",
    "methods": {
      "claim(bytes32)": {
        "notice": "TODO: add signatures for aggregated claims"
      },
      "constructor": {
        "notice": "creates contract"
      },
      "finalizeEpoch()": {
        "notice": "finalize epoch after timeout"
      },
      "getCurrentEpoch()": {
        "notice": "returns index of current (accumulating) epoch"
      },
      "getCurrentPhase()": {
        "notice": "returns the current phase"
      },
      "getDisputeManagerAddress()": {
        "notice": "returns address of dispute manager contract"
      },
      "getInputAccumulationStart()": {
        "notice": "returns the input accumulation start timestamp"
      },
      "getInputAddress()": {
        "notice": "returns address of input contract"
      },
      "getOutputAddress()": {
        "notice": "returns address of output contract"
      },
      "getValidatorManagerAddress()": {
        "notice": "returns address of validator manager contract"
      },
      "notifyInput()": {
        "notice": "called when new input arrives, manages the phase changes"
      },
      "resolveDispute(address,address,bytes32)": {
        "notice": "called when a dispute is resolved by the dispute manager"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3838,
        "contract": "contracts/RollupsImpl.sol:RollupsImpl",
        "label": "input",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(InputImpl)3221"
      },
      {
        "astId": 3841,
        "contract": "contracts/RollupsImpl.sol:RollupsImpl",
        "label": "output",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(OutputImpl)3714"
      },
      {
        "astId": 3844,
        "contract": "contracts/RollupsImpl.sol:RollupsImpl",
        "label": "validatorManager",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(ValidatorManagerImpl)6421"
      },
      {
        "astId": 3847,
        "contract": "contracts/RollupsImpl.sol:RollupsImpl",
        "label": "disputeManager",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(DisputeManagerImpl)2227"
      },
      {
        "astId": 3861,
        "contract": "contracts/RollupsImpl.sol:RollupsImpl",
        "label": "storageVar",
        "offset": 0,
        "slot": "4",
        "type": "t_struct(StorageVar)3858_storage"
      }
    ],
    "types": {
      "t_contract(DisputeManagerImpl)2227": {
        "encoding": "inplace",
        "label": "contract DisputeManagerImpl",
        "numberOfBytes": "20"
      },
      "t_contract(InputImpl)3221": {
        "encoding": "inplace",
        "label": "contract InputImpl",
        "numberOfBytes": "20"
      },
      "t_contract(OutputImpl)3714": {
        "encoding": "inplace",
        "label": "contract OutputImpl",
        "numberOfBytes": "20"
      },
      "t_contract(ValidatorManagerImpl)6421": {
        "encoding": "inplace",
        "label": "contract ValidatorManagerImpl",
        "numberOfBytes": "20"
      },
      "t_struct(StorageVar)3858_storage": {
        "encoding": "inplace",
        "label": "struct RollupsImpl.StorageVar",
        "members": [
          {
            "astId": 3849,
            "contract": "contracts/RollupsImpl.sol:RollupsImpl",
            "label": "inputDuration",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 3851,
            "contract": "contracts/RollupsImpl.sol:RollupsImpl",
            "label": "challengePeriod",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 3853,
            "contract": "contracts/RollupsImpl.sol:RollupsImpl",
            "label": "inputAccumulationStart",
            "offset": 8,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 3855,
            "contract": "contracts/RollupsImpl.sol:RollupsImpl",
            "label": "sealingEpochTimestamp",
            "offset": 12,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 3857,
            "contract": "contracts/RollupsImpl.sol:RollupsImpl",
            "label": "currentPhase_int",
            "offset": 16,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}