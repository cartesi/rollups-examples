# Nix Builder Dapp

This proof of concept allows you to run Nix build inside the Cartesi virtual machine.

We built Nix tools for riscv64 and installed them on the `cartesi/python:3.10-slim-jammy` image in order to create a reproducible build of a generic software given his depencencies. At the moment the docker image depends on a specific package that we are going to build (GNU hello).

Since we don't have internet access inside the Cartesi VM we need to provide all the (transitive) dependencies sources, using the nix terminology, we need to provide all the fixed output derivations from the target derivation closure.

Right now this operation has to be done manually running:

```shell
nix derivation show -r nixpkgs#hello | jq -r '.[] | select(.outputs.out.hash and .env.urls) | .env.urls' | uniq | sort > fo-drvs`.
```

Then the Dockerfile will copy the produced file containing all the dependencies sources 

```shell
for url in $(cat ./hello-fo-drvs.txt) ; do nix-prefetch-url $url; done
```

## Build Nix for riscv

This requires Nix installed with `nix-command` and `flakes` extra experimental features enabled:

```shell
nix build github:aciceri/nix/riscv64#hydraJobs.binaryTarballCross.x86_64-linux.riscv64-linux -L
```

Check `./result` for the tarball containing binaries and installation scripts that will be copied by the `Dockerfile`.

Currently the `Dockerfile` expects the tarball to be named ` nix-tarball.tar.xz` and contain a folder named  `nix-tarball`, so a manually renaming is needed.


## Interacting with the application

Build

```shell
docker buildx bake --load
```

Run

```shell
docker compose -f ../docker-compose.yml -f ./docker-compose.override.yml up
```

Then to ensure that everything is up & running you can use the [frontend-console](../frontend-console) application to interact with the DApp.
Ensure that the [application has already been built](../frontend-console/README.md#building) before using it.

First, go to a separate terminal window and switch to the `frontend-console` directory:

```shell
cd frontend-console
```

Then, send an input as follows:

```shell
yarn start input send --payload "message"
yarn run v1.22.5
$ ts-node src/index.ts input send --payload Nix-loves-Cartesi
connecting to http://localhost:8545
connected to chain 31337
using account "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
sending "Nix-loves-Cartesi"
transaction: 0x7d65ecd902ffb9279e1f1f4208b2712b766f704249f950277529500057852ed0
waiting for confirmation...
input 1 added to epoch 0
✨  Done in 11.15s.
```

In order to verify the notices generated by your inputs, run the command:

```shell
yarn start notice list
yarn run v1.22.5
$ ts-node src/index.ts notice list
querying http://localhost:4000/graphql for notices of {}...
[{"id":"1","epoch":0,"input":1,"notice":0,"payload":"{\"version\": \"nix (Nix) 2.16.0pre20230512_dirty\\n\", \"path\": \"/nix/store/yx04lw06p3zlkb6sli7ghmq3an9pdqi6-hello-world\\n/nix/store/yx04lw06p3zlkb6sli7ghmq3an9pdqi6-hello-world\\n\", \"content\": \"Hello world!\"}"}]
✨  Done in 3.44s.
```

You will be able to get in response the Nix version, the path and the content result of the built app installed on the docker image

